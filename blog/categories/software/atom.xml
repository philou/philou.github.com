<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: software | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/software/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2017-05-12T06:29:13+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Incremental architecture, a cure against architecture astronauts]]></title>
    <link href="http://philippe.bourgau.net/incremental-architecture-a-cure-against-architecture-astronauts/"/>
    <updated>2017-04-24T06:52:00+02:00</updated>
    <id>http://philippe.bourgau.net/incremental-architecture-a-cure-against-architecture-astronauts</id>
    <content type="html"><![CDATA[<p>Back in 2001, when I started to code for a living, fresh out of school, I was mainly doing a form of <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a>. After a few months of maintaining my own mess, I started to recall my university lessons : we should be doing design before coding &hellip;</p>

<p>When I was asked to re-engineer the &lsquo;wizards UI&rsquo;, I paused my coding to design something clean from scratch. It worked quite well at first : the overall code was a lot simpler and contained a lot less duplication than before. Seeing this new shiny UI, product people asked for new features. Unfortunately, I hadn&rsquo;t thought of them when designing this little framework. I was almost back at my initial situation.</p>

<p>That&rsquo;s how I started to look for another way to design software. At about the same time the <a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_3?ie=UTF8&amp;qid=1493096057&amp;sr=8-3&amp;keywords=extreme+programming">eXtreme Programming book</a> fell into my hands. That&rsquo;s where I discovered the idea of incremental design and architecture.</p>

<p><a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_3?ie=UTF8&amp;qid=1493096057&amp;sr=8-3&amp;keywords=extreme+programming"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/xp-1ed.jpg" alt="Front cover of the first edition of the XP book" /></a></p>

<h2>What is Incremental Archi</h2>

<p>Let&rsquo;s start with the antithesis of incremental architecture :</p>

<h3>Astronaut Architecture</h3>

<p>The term &ldquo;Architecture Astronaut&rdquo; was coined by <a href="https://www.joelonsoftware.com">Joel Spolsky</a> back in 2001. If you haven&rsquo;t read this <a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">classic post</a> yet, I strongly encourage you to do so. Basically, he explains that we should not be impressed by architects going over their heads talking about too abstract stuff.</p>

<p>Incremental is the exact opposite of astronaut architecture</p>

<h3>Two Schools to Software Architecture</h3>

<p>Traditional architecture is about taking up-front choices that will be difficult to change. Incremental architecture is about preparing for non-stop change and taking decisions as late as possible.</p>

<p>The idea in incremental architecture is really simple : keep your code simple, clean and automatically tested in order to be able to simply adapt your code and architecture when definitely needed.</p>

<h3>Pros and Cons of incremental architecture</h3>

<p>The first reaction of most software engineers (me included, remember how my story started) is that it can only work on trivial stuff. After practicing it for about a decade, I am now convinced it works most of the time. I&rsquo;m not alone, <a href="http://www.jamesshore.com/Agile-Book/incremental_design.html">James Shore</a> (who wrote the more on the subject) also shares my view:</p>

<blockquote><p>Common thought is that distributed processing, persistence, internationalization, security, and transaction structure are so complex that you must consider them from the start of your project. I disagree; I&rsquo;ve dealt with all of them incrementally.</p>

<p>Two issues that remain difficult to change are choice of programming language and platform. I wouldn&rsquo;t want to make those decisions incrementally!</p></blockquote>

<p>I would add published APIs to this list.</p>

<p>Granted, there are situations that incremental architecture alone cannot handle, what about its good points then ?</p>

<p>In all the other cases (and that means most of the time), here is what you get :</p>

<ul>
<li>As you won&rsquo;t need to deal with future use cases, you&rsquo;ll do less work</li>
<li>That in turn, will keep your code simpler, decreasing time to release new features</li>
<li>As change is built-in, you&rsquo;ll be able to improve your architecture in ways you could not have imagined from the start !</li>
</ul>


<p><a href="https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1493096137&amp;sr=1-1&amp;keywords=the+art+of+agile+development"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/art-of-agile.jpg" alt="Front cover of the Art of Agile Software Development book" /></a></p>

<p>If you cannot see how this could possibly work ? Read on !</p>

<h2>How to do it</h2>

<h3>eXtreme Programming</h3>

<p>As I said earlier, incremental architecture emerged from eXtreme Programming. It won&rsquo;t come as a surprise that in order to work well incremental architecture requires the XP practices to be in place. In particular, the code base should be automatically tested, the continuous integration cycle should take less than 10 minutes, the design should be simple. The team should be good at doing refactoring.</p>

<p>Don&rsquo;t expect to be able to do incremental architecture without these practices in place. But this alone might be enough already !</p>

<p><a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1493096197&amp;sr=1-1&amp;keywords=fowler+refactoring"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/refactoring.jpg" alt="Front cover of the Martin Fowler's refactoring book" /></a></p>

<h3>Architecture Vision</h3>

<p>At work, where our team consists of 9 developers, it&rsquo;s not always that simple to coordinate and all pull in the same direction. That&rsquo;s why we find it useful to share a very long term architecture vision (<a href="https://www.thoughtworks.com/insights/blog/enabling-incremental-design-and-evolutionary-architecture">Enabling Incremental Design and Evolutionary Architecture</a>). This will help people to make coherent decisions when hesitating between 2 alternate designs.</p>

<p>The vision can be the result of the work of a pair, or a mob brainstorming or whatever. Building this vision is typically an activity where experienced programmers can contribute a lot of value.</p>

<p>Once this vision is shared and understood by the team, every time a pair has to work on a story, they can orient the design towards it. But always as little as possible to finish the work at hand, remember the XP motos <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS (Keep It Simple &amp; Stupid)</a> &amp; <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI (You Ain&rsquo;t Gonna Need It</a>.</p>

<p>One final word &hellip; a vision is just that : a vision ! It might turn out true, or false, be ready to change it as circumstances change.</p>

<h3>Spikes</h3>

<p>At times, even with a story in your hands and a long term architecture sketch on the whiteboard, you might have difficulties to know how to change your design to fulfill both.</p>

<p>As always in XP, in case of uncertainty, use <a href="http://agiledictionary.com/209/spike/">Spikes</a> ! Spikes are short time-boxed experiments of throwaway code, which goal is to answer a specific design question.</p>

<h3>How to mitigate the risks</h3>

<p>What about these topics that don&rsquo;t yield to incremental architecture ? What if you discover late that you need to change your platform ? Or your API ?</p>

<p>Obviously, you should think about these questions up-front. Hopefully, there are usually not that difficult to answer. But, over time, Non-Functional-Requirements and technologies change. Large and long living systems are particularly likely to need to change to a new platform someday.</p>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix had the answer</a> : build your system out of small tools, that do only one thing well, and that communicate through a standard protocol. Systems built that way can be re-written one piece at a time.</p>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/Ken_n_dennis.jpg" alt="Ken Thompson and Dennis Ritchie, the creators of Unix" /></a><div class="image-credits">Photo from <a href="https://commons.wikimedia.org/wiki/File:Ken_n_dennis.jpg">WikiMedia</a></div></p>

<p>The modern version of this is the micro-services architecture. Incremental architecture allows you to start with a monolith, split it when you need to, and replace micro-services as needed.   With the safety of simple code and a great automated test harness. Interestingly, successful software systems that were architectured up-front also take this road &hellip; without the safety !</p>

<h3>The Architect</h3>

<p>Good news : no more PowerPoints and a lot more coding with the team ! Here is what&rsquo;s expected from an incremental architect :</p>

<ul>
<li>To code with the team. As Bertrand Meyer once said &ldquo;<a href="http://stal.blogspot.fr/2008/08/architect-always-implements.html">Bubbles (aka. diagrams) don&rsquo;t crash</a>&rdquo;, it&rsquo;s plain too easy, and wrong, to mandate architecture without living with the consequences</li>
<li>To come up with more ideas when drafting the long term vision</li>
<li>To keep an eye on the &lsquo;long term&rsquo; while being the navigator in pair programming</li>
<li>In the second edition of the <a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0321278658/ref=sr_1_1?ie=UTF8&amp;qid=1493096057&amp;sr=8-1&amp;keywords=extreme+programming">XP book</a> Kent Beck suggests that the architect should write large scale tests to stress the system and demonstrate architecture issues to the team</li>
<li>To delegate as much as possible to the team. However smart the architect, the team as a whole is smarter ! Delegating architecture increases motivation and the quality of the outcome.</li>
</ul>


<h2>End of the story</h2>

<p>I&rsquo;ve been practicing incremental architecture and design for a long time now. It made my life a lot simpler ! Most architecture questions become backlog items to prioritize.</p>

<p>One last advice : be prepared to re-read <a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">Joel Spolsky&rsquo;s article</a> whenever you get caught up in architecture meetings &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developer ! Are you losing your rat race ?]]></title>
    <link href="http://philippe.bourgau.net/developer-are-you-losing-your-rat-race/"/>
    <updated>2017-02-09T05:37:00+01:00</updated>
    <id>http://philippe.bourgau.net/developer-are-you-losing-your-rat-race</id>
    <content type="html"><![CDATA[<blockquote><p>A rat race is an endless, self-defeating, or pointless pursuit. It conjures up the image of the futile efforts of a lab rat trying to escape while running around a maze or in a wheel.</p></blockquote>

<p>Are we building our own <del>maze</del> self defeating landscape by our exacerbated focus on technology ? Let me explain.</p>

<p><img class="center" src="/imgs/2017-02-09-developer-are-you-losing-your-rat-race/rat-maze.jpg" title="A rat in a maze" ></p>

<h2>The context</h2>

<p>As <a href="https://en.wikipedia.org/wiki/Marc_Andreessen">Marc Andreessen</a> famously said &ldquo;Software is eating the world&rdquo;, which means that there is more and more demand for software. At the same time, giant countries like China, India, Russia or Brazil are producing more and more master&rsquo;s degrees every year. This also means more and more software engineers. The consequence is that there has never been so many new technologies emerging than these days. The software landscape his huge, growing and complex.</p>

<p>That&rsquo;s great for progress, but it&rsquo;s a puzzle for hiring. In this chaotic environment, years of experience with a particular technology is something that remains easy to measure, that&rsquo;s why employers (and developers) tend to use keywords to cast for a job.</p>

<h2>The effects</h2>

<p>As a result, developers tend to pick a few technologies to become masters at, to put them on their CV and get job offers. There&rsquo;s a danger with specializing on a particular technology : eventually, it will become deprecated, in this keyword driven world, it&rsquo;s almost like if you&rsquo;ll have to start from zero again. Even if a specialization is wide enough now, as time goes on and more and more technologies are created, any area of expertise will become a tiny spot in all the landscape. One might think this is only an issue for old guys that did not stay up to date &hellip; I strongly believe this is wrong, it happened to all past technologies, I don&rsquo;t see why today&rsquo;s latest .js framework wouldn&rsquo;t be legacy stuff one day.</p>

<p>One could think that sticking to a good employer is a good fix against that. It is &hellip; for some time ! Sticking to an company actually means <em>betting</em> on this company. What would happen if it went out of business, or through difficult times and you&rsquo;re asked to leave ? When you reach the job market after so long with a single employer, you&rsquo;ll be a de-facto specialist, on proprietary stuff that no one is interested about.</p>

<p>Finally, you might work hard not to specialize, but it&rsquo;s going to be a lot more difficult to get a job as a generalist, only a few shops actually hire this way.</p>

<p>To summarize, we are forced into specialization, which is great in the short term, but risky in the long run.</p>

<h2>1€ advice</h2>

<p>So what can we do about this ? Obviously, we cannot change the world &hellip; The only ones we can act on are ourselves !</p>

<h3>Learning</h3>

<p>In our fast moving tech world, learning remains key ! But instead of trying to keep up with all the cool new techs that are invented every day, we should study fundamental skills, and only learn just enough specific skills to get the job done. To me fundamental skills are all the things you&rsquo;ll apply whatever the language and technology you are using, for example :</p>

<ul>
<li>design</li>
<li>architecture (whatever that is &hellip;)</li>
<li>clean code</li>
<li>refactoring</li>
<li>legacy code</li>
<li>testing</li>
<li>tooling</li>
<li>mentoring &amp; coaching</li>
<li>programming paradigms (functional, dynamic, static, imperative, OO, concurrent &hellip;)</li>
<li>process flow</li>
<li>communication</li>
<li>product definition</li>
<li>concurrency</li>
<li>performance</li>
</ul>


<p>I wrote <a href="http://philippe.bourgau.net/how-to-keep-up-with-software-technologies/">this post</a> that explains how I did learn some of these skills (by no mean would I say that this is the only way). Good mastery of these skills should be enough to quickly get up to speed in any project you are involved. This other article <a href="https://blog.bradfieldcs.com/in-2017-learn-every-language-59b11f68eee#.l2n6kouuz">In 2017, learn <em>every</em> language</a>, which I found through the excellent <a href="http://www.hackernewsletter.com/">hackernewsletter</a>, explains how this is possible.</p>

<p>Unfortunately, knowing is not enough &hellip;</p>

<h3>Selling</h3>

<p>How do you convince others that you are up to the job in a particular technology ? Unfortunately, I don&rsquo;t have a definitive answer yet &hellip;</p>

<p>Regularly, people try to coin a word to describe the competent generalist developer : polyglot, full stack, craftsman &hellip; If it&rsquo;s good enough, it usually gets taken over quite fast by the industry and just becomes yet another buzzword (the only exception being eXtreme Programming, but who would like to hire and eXtreme Programmer ?).</p>

<p>In <a href="https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397/ref=sr_1_1?ie=UTF8&amp;qid=1473135683&amp;sr=8-1&amp;keywords=soft+skills">Soft Skills</a>, John Somnez says the trick is to explain to people that you might not have experience in a technology &lsquo;yet&rsquo;. This might work, if your resume gets through, which is not sure.</p>

<p>Here&rsquo;s my try : the next time I&rsquo;ll polish my resume, I&rsquo;ll try to put forward my fundamental skills first, for example with 5 stars self-assessments. Only after will I add something like &ldquo;By the way, I could work with tech X Y Z &hellip;&rdquo;.</p>

<h3>Independence</h3>

<p><a href="https://www.amazon.com/End-Jobs-Meaning-9-5/dp/1619613352/ref=sr_1_1?ie=UTF8&amp;qid=1486713381&amp;sr=8-1&amp;keywords=the+end+of+jobs"><img class="center" src="/imgs/2017-02-09-developer-are-you-losing-your-rat-race/the-end-of-jobs.jpg" title="Cover of the book &lsquo;The End of Jobs&rsquo;" ></a></p>

<p>Being your own boss could be a solution in the long term. I recently listened to <a href="https://www.amazon.com/End-Jobs-Meaning-9-5/dp/1619613352/ref=sr_1_1?ie=UTF8&amp;qid=1486713381&amp;sr=8-1&amp;keywords=the+end+of+jobs">The End of Jobs</a> in which the author explains that entrepreneurship is an accessible alternative these days, and that like any skill, it&rsquo;s learnable. The catch is that there are no schools, no diplomas, and that it seems a lot riskier in the short run. Despite that, he makes the point that the skills you&rsquo;ll learn makes it quite safe in the long run !</p>

<h2>Questions</h2>

<p>I feel like my post asks more questions than it provides answers :&ndash;). Honestly, I&rsquo;d really love to read other people&rsquo;s opinions and ideas. What are your tricks to market yourself on new technologies ? As a community, what could we do to fight our planned obsolescence ? Do you think I&rsquo;m totally wrong and that the problem does not exist ? What do you think ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Plain English Introduction To Paxos Protocol]]></title>
    <link href="http://philippe.bourgau.net/a-plain-english-introduction-to-paxos-protocol/"/>
    <updated>2017-01-16T08:20:00+01:00</updated>
    <id>http://philippe.bourgau.net/a-plain-english-introduction-to-paxos-protocol</id>
    <content type="html"><![CDATA[<p>A few weeks ago, I had to have a look at the distributed consensus protocol <a href="https://en.wikipedia.org/wiki/Paxos_%28computer_science%29">Paxos</a>. Even though I know its purpose and I&rsquo;ve built and used distributed systems and databases in the past, Paxos remains mind boggling at first !</p>

<h2>The hard way</h2>

<p>The best overall description I found is <a href="https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm">this answer by Vineet Gupta on Quora</a>. After turning my head around it for a while, I finally gained the instinctive understanding which comes when you &lsquo;get&rsquo; something.</p>

<p>As a way to both help others to understand Paxos faster and to burn all this in my own memory, I though it would he a good idea to illustrate it as a story (I was inspired by <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/">A plain English introduction to CAP Theorem</a> which I found really instructive; I also later discovered that the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/The-Part-Time-Parliament.pdf">original Paxos paper</a> itself related the protocol using the metaphor of a parliament).</p>

<p><img class="center" src="/imgs/2017-01-16-a-plain-english-introduction-to-paxos-protocol/greek.jpg" title="A drawing of an ancient Greek hero typing at a computer" ></p>

<h2>Once upon a time &hellip;</h2>

<p>&hellip; there were 3 brothers and sisters, Kath, Joe &amp; Tom, living happily. They lived far away, and it was not easy for them to meet and spend some time together. Neither did they have phone or internet, for this was a long time ago. All they had to discuss and share news was good old mail &hellip;</p>

<p>Unfortunately, one day, the worst happened : their parents die. All 3 are informed by a letter from the notary, telling them that they need to sell the family house in order to pay for their inherited debts. It also advises to use Paxos to agree on a price (Note : I never said the story was going to be chronologically sound !).</p>

<h2>The happy end</h2>

<p>As the oldest in the family, Kath decides to take things in hand, and starts the whole thing. She knows Paxos consists of 2 phases : &lsquo;prepare&rsquo; and &lsquo;accept&rsquo;.</p>

<h3>Prepare Phase</h3>

<p>Kath sends a signed and dated price value proposal to her brothers, by mail.</p>

<p>Joe and Tom both receive the letter from Kath, they think the price is fair. In order to send their agreements back to Kath, they make a copy of the proposition, mark it as agreed, date it, sign it, and send it back.</p>

<h3>Accept Phase</h3>

<p>Joe lives a bit further away from Kath than Tom does, so correspondence between Kath and Tom is usually faster. Kath indeed receives the agreement from Tom first, she knows she can go on with the protocol straight away, because Paxos relies on majority, and not unanimity. In his letter, Tom agreed to the same price she proposed, so she just picks this one as the final price to agree on.</p>

<p>She sends new letters, called accept letters this time, to her brothers to finalize the agreement. In these letters, she specifies the price that they are agreeing on, plus the date at which it was first suggested (see Prepare Phase). When Tom and Joe receive the accept letter, they simply need to check that the time and price of the proposal to make sure it is what they agreed on, before sending back their final accept letter.</p>

<p>At the time when Kath receives the accept letters from her brothers, everyone knows that the price has been agreed.</p>

<p><a href="https://www.taschen.com/pages/en/catalogue/children/all/06787/facts.the_fairy_tales_of_the_brothers_grimm.htm"><img class="center" src="/imgs/2017-01-16-a-plain-english-introduction-to-paxos-protocol/grimm-brothers.jpg" title="Cover of the book &ldquo;The Fairy Tales of the Grimm Brothers&rdquo;" ></a></p>

<h3>After</h3>

<p>She then informs the notary on the agreed price. This one sends an information letter to the Kath, Tom &amp; Joe. The house is sold pretty quickly, leaving the family out of financial problems for the rest of their lives &hellip;</p>

<h2>Shit happens</h2>

<p>That story went unexpectedly well ! Let&rsquo;s see different variations about what would happen in real life.</p>

<h3>Joe is particularly slow to answer</h3>

<p>Joe has never been good at paperwork &hellip; he&rsquo;s always out partying and having fun, and he does not want to bother answering letters. When Joe receives the prepare letter from Kath, he does not reply straightaway but leaves it on his desk to handle later. Meanwhile, Tom answers as soon as he got the letter. As mentioned before, Paxos relies on majority, as soon as Kath gets Tom&rsquo;s answer, she can continue to the next phase. In fact, the accept phase also relies on majority, so she can continue to the end of the protocol if Tom continues to answer.</p>

<p>In this case, Joe would receive the accept letter before he sent his answer to the prepare letter, and would know that the consensus is moving on without him. He can try to catch up or not, but the consensus can be reach without him.</p>

<h3>Tom wants to speed things up by becoming the master</h3>

<p>Tom has always been the hurried brother. He does not like when things linger forever but prefers things to be done quickly. As soon as he receives the letter from the notary, he starts waiting impatiently for the prepare letter from his sister. Kath, on her part, takes a lot of time to settle on a price. Not knowing what is going on, Tom decides to take action, and to takes on the master role : he sends his own copies of the prepare letters. While these letters are in the mail, Kath finally settles on a price, and sends hers.</p>

<p>Joe gets Tom&rsquo;s proposal first. Thinking that it&rsquo;s a change in the plan, he responds straight away by signing the proposal and taking a copy for himself. The following day, he receives Kath&rsquo;s proposal ! He&rsquo;s a bit surprised, but hopefully, Paxos tells him exactly what to do in this situation. By agreeing to Tom&rsquo;s proposal, he made a promise to stick to it whatever happens later. Here the date on Kath&rsquo;s proposal is later than on Tom&rsquo;s, so Joe is going to answer to Kath that he agrees but to to Tom&rsquo;s proposal, of which he&rsquo;ll join a copy.</p>

<p>After receiving the Joe&rsquo;s agreement on his proposal, Tom has the majority, and should be able to end the protocol.</p>

<p>What about Kath ?</p>

<p>She should have received Tom&rsquo;s proposal, and rejected it, because she had already proposed a later value. That will not prevent Tom to reach a consensus.</p>

<p>She should have received Joe&rsquo;s agreement to Tom&rsquo;s proposal. The same way, she might as well have received Tom&rsquo;s agreement to his own proposal as an answer to hers. She&rsquo;d get the majority of agreements, so she might then want to push on. For the accept letter, she must pick a value that has been accepted, in this case, it&rsquo;s Tom&rsquo;s proposed value ! Everything ends as expected as she&rsquo;ll reach the same price as Tom.</p>

<h3>Tom wants a higher price an becomes the master</h3>

<p>Imagine Tom is obsessed about money ! When he receives Kath&rsquo;s proposal, he&rsquo;s outraged ! Believing the house has a lot more value than the proposed price, he sets on to act as a master in Paxos and sends his own proposal letters to his brother and sister.</p>

<p>Unfortunately, when they receive his proposal, they have already agreed to Kath&rsquo;s older proposal, so they send him back a copy of it as an agreement. Having received agreements to Kath&rsquo;s value only, he cannot push forward his value. Whether he continues his Paxos or not does not really matter, as he would reach the same value as Kath would.</p>

<h3>River flood split between brothers and Kath</h3>

<p><a href="http://riniwuzhere.deviantart.com/art/Fairytale-Map-of-Wurzburg-393850325"><img class="center" src="/imgs/2017-01-16-a-plain-english-introduction-to-paxos-protocol/fairytale-map.jpg" title="A drawing of a fairy tale map with a wide river in the middle" ></a></p>

<p>There&rsquo;s a wide river that separates Kath from Joe and Tom. While they were trying to reach consensus, the river flood, cutting all communication between the brothers and their sister. Kath might abort the consensus as she won&rsquo;t be able to get answers from the majority. On their side, Joe or Tom can takeover the consensus, take on the master role, and still reach a price, as they form a majority. As soon as the river would settle, the messages would arrive to both parties, eventually informing Kath that a price was accepted.</p>

<h3>Lots of others</h3>

<p>You can imagine zillions of ways in which the consensus between Kath, Joe and Tom could go wrong. For example :</p>

<ul>
<li>Mail is so slow that Kath sends new proposals</li>
<li>One letter gets lost and arrives after Kath made a new proposal</li>
<li>Kath is struck by a lightning</li>
</ul>


<p>Go ahead and execute Paxos step by step on all of them, you&rsquo;ll see that whatever happens, Kath, Joe and Tom will reach a price.</p>

<h2>More Formally</h2>

<p>Now that you have an instinctive understanding of Paxos, I encourage you to read out <a href="https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm">the full explanation I found on Quora</a>. Here is a extract with the protocol part :</p>

<blockquote><h3>Protocol Steps:</h3>

<h4>1) Prepare Phase:</h4>

<ul>
<li><p>A node chooses to become the Leader and selects a sequence number x and value v to create a proposal P1(x, v). It sends this proposal to the acceptors and waits till a majority responds.</p></li>
<li><p>An Acceptor on receiving the proposal P1(x, v1) does the following:</p>

<ul>
<li>If this is the first proposal to which the Acceptor is going to agree, reply ‘agree’ – this is now a promise that the Acceptor would reject all future proposal requests &lt; x</li>
<li>If there are already proposals to which the Acceptor has agreed:
compare x to the highest seq number proposal it has already agreed to, say P2(y, v2)

<ul>
<li>If x &lt; y, reply ‘reject’ along with y</li>
<li>If x > y, reply ‘agree’ along with P2(y, v2)</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>2) Accept Phase</h4>

<ul>
<li><p>If a majority of Acceptors fail to reply or reply ‘reject’, the Leader abandons the proposal and may start again.</p></li>
<li><p>If a majority of Acceptors reply ‘agree’, the Leader will also receive the values of proposals they have already accepted. The Leader picks any of these values (or if no values have been accepted yet, uses its own) and sends a ‘accept request’ message with the proposal number and value.</p></li>
<li><p>When an Acceptor receives a ‘accept request’ message, it sends an ‘accept’ only if the following two conditions are met, otherwise it sends a ‘reject’:</p>

<ul>
<li>Value is same as any of the previously accepted proposals</li>
<li>Seq number is the highest proposal number the Acceptor has agreed to</li>
</ul>
</li>
<li><p>If the Leader does not receive an ‘accept’ message from a majority, abandon the proposal and start again. However if the Leader does receive an ‘accept’ from a majority, the protocol can be considered terminated. As an optimization, the Leader may send ‘commit’ to the other nodes.</p></li>
</ul>
</blockquote>

<p>And here are the key concepts to map my story to this formal description of Paxos.</p>

<table>
<thead>
<tr>
<th></th>
<th> Story </th>
<th> Paxos</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> proposal letter (and copy of) </td>
<td> P(x,v)</td>
</tr>
<tr>
<td></td>
<td> Date (and time) </td>
<td> sequence number</td>
</tr>
</tbody>
</table>


<br/>


<p>At the time of slow mail based communication, using the date and time down to the second is enough to build up unique sequence numbers. In our current time of digital messages, it&rsquo;s another story, typical Paxos implementation assigns a different and disjoint infinite set of integers for every participant, it does not exactly follow &lsquo;time&rsquo;, but it&rsquo;s enough for the algorithm to work.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Happens to Non-Enthusiast Programmers in the Long Run ?]]></title>
    <link href="http://philippe.bourgau.net/what-happens-to-non-enthusiast-programmers-in-the-long-run/"/>
    <updated>2017-01-10T05:57:00+01:00</updated>
    <id>http://philippe.bourgau.net/what-happens-to-non-enthusiast-programmers-in-the-long-run</id>
    <content type="html"><![CDATA[<p>A few months ago, after receiving good feedback from my regular readers, I posted my latest article <a href="/is-there-any-room-for-the-not-passionate-developer/">Is There Any Room for the Not-Passionate Developer ?</a> on <a href="https://news.ycombinator.com/">Hackernews</a> and <a href="https://www.reddit.com/r/programming/">Reddit</a>. I got a <a href="/how-to-use-hackernews-and-reddit-for-blogging/">huge number of visits</a>, a lot more than I typically get !</p>

<p>I also got a lot more comments, some nice, some tough, some agreeable and some challenging !</p>

<p><img class="center" src="/imgs/2017-01-10-what-happens-to-non-enthusiast-programmers-in-the-long-run/professional.jpg" title="A logo of a guy wearing a suit" ></p>

<h2>First, a summary</h2>

<p>In this previous article, I wanted to contrast the different views about work/life balance in the software industry.</p>

<p>Some, like agile gurus and companies like Basecamp, and <a href="http://lifehacker.com/working-over-40-hours-a-week-makes-you-less-productive-1725646811">studies</a>, strongly advocate for sane work hours. They explain that it results in greater productivity and healthy life.</p>

<p>On the other hand, the software field is always bubbling with novelty, and keeping up to date with technologies is by itself a challenge that takes time. For some companies, which might already be fighting for their survival against competition, it is almost impossible to grant some extra training time to their employees. The problem becomes particularly difficult when engineers get older, become parents and cannot afford to spend some extra time learning the latest JavaScript framework.</p>

<p>As a conclusion, I said that for most of us, it&rsquo;s really difficult to remain a developer in the long run without the grit that only passion for programming brings. I encourage you to <a href="/is-there-any-room-for-the-not-passionate-developer/">read it</a> for more details.</p>

<h2>What I learned from the comments</h2>

<p>First of all, thanks a lot for all these, they were very valuable, they forced me to think even more about the issue.</p>

<h3>People have been burnt !</h3>

<p>The word &lsquo;passion&rsquo; in particular, triggered engaged comments. As some pointed out, &lsquo;enthusiast&rsquo; or &lsquo;professional&rsquo; should be favored. It seems that some companies have asked their employees for unquestionable passion for their business (and not for engineering or programming) at the cost of the people&rsquo;s own lives. As a commenter said, a lot of shops do not integrate the absolute necessity for their programmers to learn continuously in their business model. It made me kind of sad to feel once more this state of our industry.</p>

<p>As a result, people are weary of any statement of &lsquo;passion&rsquo; in the workplace, and would prefer to be seen as very skilled professional, dedicated to keeping their skills up to date.</p>

<h3>The particular question of France</h3>

<p><img class="center" src="/imgs/2017-01-10-what-happens-to-non-enthusiast-programmers-in-the-long-run/france.jpg" title="A photo of the Eiffel tower" ></p>

<p>I received some comments from all over the world, but my observations came from where I work : in France. Here, all in all, we have at least 7 weeks of paid leaves per year. It&rsquo;s a lot more than in other parts of the world. I think it&rsquo;s around 2 weeks in the US (other <a href="https://www.bloomberg.com/news/articles/2016-10-18/americans-work-25-more-than-europeans-study-finds">sources</a> point the same fact). Imagine two companies, one from France, and one from the US. The one in the US can invest 5 weeks per year in exploratory learning (which can result in good things for both the business and the employee) while still producing as much as the french one.</p>

<p>Obviously, there are other parameters to take into account for overall productivity like hours per day, the effects of holidays or long hours on creativity, or funding &hellip; but here are some facts about software engineering in France :</p>

<ul>
<li>20% time policy, hackathons and other exploratory learning are extremely rare (I&rsquo;ve seen it once in 15 years)</li>
<li>It&rsquo;s slowly getting better, but if you remain a programmer in your thirties, you&rsquo;re seen as a loser</li>
<li>France has no software powerhouse like Microsoft, Google, Apple &hellip;</li>
</ul>


<p>This lead me to this open question : What&rsquo;s the effect of the 7 weeks of paid leaves on the french software industry ?</p>

<p>By no means will I try to give an answer, I just don&rsquo;t know. Plus, for those who might be wondering : I love my 7 weeks of holidays !</p>

<h2>The conclusion I came to</h2>

<p>Yet, I can try to draw a conclusion at the individual level. In France, if you&rsquo;re not really enthusiastic about programming, you won&rsquo;t put the extra effort off-the-job to learn the latest technologies. Within a few years, you&rsquo;ll be &lsquo;deprecated&rsquo;, which will leave you with mainly 2 options :</p>

<ul>
<li>become a manager</li>
<li>stick to your current codebase (and become completely dependent of your employer)</li>
</ul>


<p>To me, the sad truth is that if you want to make a career as a professional developer in France, you&rsquo;d better be ready to spend some of your free time practicing !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I got my feet wet with machine learning with 'The First 20 Hours']]></title>
    <link href="http://philippe.bourgau.net/how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours/"/>
    <updated>2016-12-29T21:09:00+01:00</updated>
    <id>http://philippe.bourgau.net/how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours</id>
    <content type="html"><![CDATA[<p>I&rsquo;m currently wrapping up an alpha of a unit testing <a href="https://github.com/philou/complexity-assert">ruby gem</a> that allows to assert the complexity of a piece of code. It&rsquo;s the result of an experiment to learn some <a href="https://en.wikipedia.org/wiki/Machine_learning">Machine Learning</a> skills in 20 hours &hellip; not bad for a first a try at Data Science ! This is the story of this experiment.</p>

<h2>How it all started ?</h2>

<p><a href="https://www.amazon.com/First-20-Hours-Learn-Anything/dp/1591846943/ref=sr_1_1?ie=UTF8&amp;qid=1483258282&amp;sr=8-1&amp;keywords=the+first+20+hours"><img class="center" src="/imgs/2016-12-29-how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours/book-cover.jpg" title="The cover of the book &lsquo;The First 20 Hours&rsquo;" ></a></p>

<p>A few months ago, I read <a href="https://www.amazon.com/First-20-Hours-Learn-Anything/dp/1591846943/ref=sr_1_1?ie=UTF8&amp;qid=1483258282&amp;sr=8-1&amp;keywords=the+first+20+hours">The First 20 Hours</a>. The book describes a technique to get up to speed and learn some practical skills on any particular subject in only 20 hours. As examples, the author details how he managed to teach himself a pretty decent level of Yoga, Ukulele, Wind Surfing, Programming, Go and touch typing.</p>

<p>I decided to give it a try. In order to get a boost, I found a few motivated people at work to do it with me. I started by presenting them the technique described in the book, and asked everyone what they wanted to learn. After a quick vote, we set out to learn more about Machine Learning.</p>

<h2>The technique</h2>

<p>The method is meant to allow anyone to learn necessary skills to accomplish a specific task in about 20 hours. I my case, I could expect to get a basic understanding of the Machine Learning concepts, as well as some practical skills to do something involving Machine Learning. Here are the details of the technique :</p>

<ol>
<li>H0 : Deep dive in the main concepts and theory of machine learning</li>
<li>H6 : Define an ambitious and practical goal or skill level to achieve by the end, and an outline of how to get there</li>
<li>H6 to H20 : Learn by doing</li>
</ol>


<p>As you see, the technique is pretty simple !</p>

<h2>How did it work ?</h2>

<h3>For the group</h3>

<p>The plan for the group was :</p>

<ul>
<li>to meet weekly for 2 hours</li>
<li>to share what we learned at the end of every session</li>
<li>to bound by similar goals</li>
</ul>


<p>At first, people were enthusiastic about learning something like machine learning. After a while, I started to get the following remarks :</p>

<ul>
<li>&ldquo;I don&rsquo;t really see the point of doing this together rather than independently&rdquo;</li>
<li>&ldquo;I&rsquo;m feeling a bit lost by not having a concrete goal and a plan from H0&rdquo;</li>
<li>&ldquo;I picked up a target that&rsquo;s too large for me&rdquo;</li>
</ul>


<p>The learning curve must have proven too steep, because as time went by, a lot of people droped out, and we ended up being only 2 !</p>

<h3>For me</h3>

<p>The first phase was the toughest. As the author had warned in his book, &ldquo;You&rsquo;ll get deep above your head in theory and concepts you don&rsquo;t know&rdquo;, &ldquo;You&rsquo;ll feel lost&rdquo;. He had some reassuring words though : &ldquo;The steeper the learning curve, the more you&rsquo;ll be learning !&rdquo; I actually like this feeling of unknown things to learn, and that&rsquo;s why I stuck to it.</p>

<p>I took me 8 hours, and not 6 to get a good overall grasp of Machine Learning techniques. The theory was just too wide and interesting and I could not cut the learning after just 6 hours :&ndash;). I studied <a href="https://xyclade.github.io/MachineLearning/#cross-validation">Machine Learning for developers</a> plus a few other pages for details on specific points. I took and kept notes about what I learned. I chose my subject &ldquo;unit testing algorithm complexity&rdquo; for the following reasons :</p>

<ul>
<li>I could imagine some utility</li>
<li>I had been writing benchmarks at work for 3 years, and I knew the practice well enough</li>
<li>It&rsquo;s pretty easy to generate data for this subject : just run your algorithm !</li>
<li>It seems a good first step, doable with basic Machine Learning techniques like linear regression</li>
<li>It seems small enough to get something working in 12 hours</li>
<li>I could use ruby, which I find both fast and pleasant to program</li>
</ul>


<p>This is the plan I set out :</p>

<ol>
<li>Generate data with a linear algorithm (O(n))</li>
<li>Run linear regression on the data</li>
<li>Compute the the <a href="https://xyclade.github.io/MachineLearning/#root-mean-squared-error-rmse">RMSE</a> of the model</li>
<li>Deal with Garbage Collection in order to make reduce its noise</li>
<li>Deal with interpreter warm-up for the same reason</li>
<li>Generate data for a constant (O(1)) algorithm and build a model for it</li>
<li>Find a way to identify if an algorithm is constant or linear from it&rsquo;s execution timings</li>
<li>Generate data for a quadratic (O(2)) algorithm and build a model for it</li>
<li>Identify if an algorithm is constant, linear or quadratic</li>
<li>Package all this in an <a href="http://rspec.info/">RSpec</a> library</li>
</ol>


<p>It started well, and I made good progress. Unfortunately, as people dropped out of the group and I got more urgent things to do at work, I had to pause my project for a while. It&rsquo;s only been since last week that I got some time during my holidays to finish this off. I&rsquo;m currently at H18, and I&rsquo;ve completed all steps from 1 to 9.</p>

<p>As I said the project is still in early alpha. They is a lot of points in which it could be improved (more complexities, faster, more reliable &hellip;). Even though I did not tackle the more advanced machine learning techniques, I now understand the overall process of ML : explore to get an intuitive grasp of the data, try out a model, see what happens, and repeat &hellip; I feel that learning these more advanced techniques would be easier now.</p>

<h2>My opinion on the method</h2>

<p>Overall, I found the experiment really effective, it&rsquo;s possible to learn quite a lot by focusing on it for 20 hours. A word of warning though : you need to be really motivated and ready to stick through difficulties.</p>

<p>It&rsquo;s also been very pleasant. I&rsquo;ve always loved to learn new things, so I might be a little biased on that aspect. I liked the first part when I felt that there was a lot to learn in a large subject I knew almost nothing about. I loved the second part too, although this might be more related to machine learning, because I felt like exploring an unknown (data set) and trying to understand it.</p>

<p>I&rsquo;ve never been afraid to learn something, doing this experiment taught me I can learn anything fast ! I&rsquo;ll definitely re-use it again.</p>

<p>One last word about doing this in group. My own experiment did not work very well. Most people were not comfortable with the first &lsquo;explore&rsquo; phase. I guess one could make it work better by starting 6 or 8 hours before the rest of the group, enough to grasp the basic concepts and come up with a few end goals. Having concrete targets from day 1 should help people to stick through and to collaborate. The &lsquo;guide&rsquo; could also help the others through the first phase.</p>

<p>Stay tuned, I&rsquo;ll present my gem in <a href="/verify-the-big-o-complexity-of-ruby-code-in-rspec/">a following post</a></p>
]]></content>
  </entry>
  
</feed>
