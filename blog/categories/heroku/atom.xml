<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2016-07-13T05:39:56+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to boot a new Rails project with Docker and Heroku]]></title>
    <link href="http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku/"/>
    <updated>2016-07-13T04:55:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku</id>
    <content type="html"><![CDATA[<p>A few years ago, I used <a href="http://www.heroku.com">Heroku</a> to deploy my <a href="https://github.com/philou/mes-courses">side-project</a>. It provides great service, but I remember that updates to the Heroku Stack was a nightmare &hellip; Versions of the OS (and nearly everything) changed. The migration was a matter of days, and while doing a side-project, this was difficult. At the time, I remember thinking that using branches and VMs would have been the solution.</p>

<p>Now that I started to use Heroku again, I decided to use <a href="http://www.docker.com">Docker</a> from the beginning. More specifically, I am expecting :</p>

<ul>
<li>to have a minimal setup on my host machine</li>
<li>to use the same infrastructure in dev than in production</li>
<li>to simplify switching to a new machine</li>
<li>to simplify the migration to the next Heroku stack</li>
</ul>


<p>As an added benefit, if ever someone else joins me in my side-project, it will be a matter of minutes before we can all work on the same infrastructure !</p>

<p>Heroku provides a <a href="https://devcenter.heroku.com/articles/local-development-with-docker">tutorial</a> about how to deploy an existing <a href="http://rubyonrails.org/">Rails</a> app to heroku using containers. Unfortunately, I did yet have an existing rails app &hellip; So the first challenge I faced, was how to create a Rails app without actually installing Rails on my machine. The trick is to bootstrap rails in docker itself before packaging all this for Heroku.</p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/logos.jpg" title="The 3 logos of Rails, Docker and Heroku" ></p>

<h2>1. Install the required software</h2>

<p>I installed only 4 things on my host machine
&ndash; Docker <a href="https://docs.docker.com/engine/installation/">instructions</a>
&ndash; Docker Compose <a href="https://docs.docker.com/compose/install/">instructions</a>
&ndash; Heroku Toolbelt <a href="https://toolbelt.heroku.com/">instructions</a>
&ndash; Heroku container plugin <code>heroku plugins:install heroku-container-tools</code></p>

<p>That&rsquo;s all I changed to my host machine.</p>

<h2>2. Setup docker</h2>

<p>First, let&rsquo;s create a new dir and step into it. Run :
<code>bash
mkdir docker-rails-heroku
cd docker-rails-heroku
</code>
To prepare the Heroku setup, create a <code>Procfile</code>
<code>
web: bundle exec puma -C config/puma.rb
</code>
and <code>app.json</code>
```json
{
  &ldquo;name&rdquo;: &ldquo;Docker Rails Heroku&rdquo;,
  &ldquo;description&rdquo;: &ldquo;An example app.json for container-deploy&rdquo;,
  &ldquo;image&rdquo;: &ldquo;heroku/ruby&rdquo;,
  &ldquo;addons&rdquo;: [</p>

<pre><code>"heroku-postgresql"
</code></pre>

<p>  ]
}
<code>
To generate docker files for Heroku, run :
</code>bash
heroku container:init
```
You want to run Rails in dev mode locally, so we need to override Heroku&rsquo;s default env (<a href="/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode/">Check my previous post for details</a>)</p>

<p>Create an <code>.env</code> file
<code>
RAILS_ENV=development
</code>
and <code>docker-compose.override.yml</code>
```yaml
web:
  volumes:</p>

<pre><code>- '.:/app/user'
</code></pre>

<p>  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>shell:
  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>```</p>

<h2>3. Create the Rails app</h2>

<p>It&rsquo;s now time to follow <a href="https://docs.docker.com/compose/rails/">the official docker-compose rails tutorial</a> to bootstrap the rails app and directories :</p>

<p>Change <code>Dockerfile</code> to
```</p>

<h1>FROM heroku/ruby</h1>

<p>FROM ruby:2.2.0
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs
RUN mkdir /myapp
WORKDIR /myapp
ADD Gemfile /myapp/Gemfile
ADD Gemfile.lock /myapp/Gemfile.lock
RUN bundle install
ADD . /myapp
```</p>

<p>Create a bootstrap <code>Gemfile</code> with the content
<code>ruby
source 'https://rubygems.org'
gem 'rails', '4.2.0'
</code>
Bundle install within the container requires a existing <code>Gemfile.lock</code>
```bash</p>

<h1>Create an empty Gemfile.lock</h1>

<p>touch Gemfile.lock
```</p>

<p>It&rsquo;s now time to build your docker container to be able to run rails and generate your source files. Run the following :
```bash</p>

<h1>Build your containers</h1>

<p>docker-compose build</p>

<h1>Run rails within the shell container and generate rails files</h1>

<p>docker-compose run shell bundle exec rails new . &mdash;force &mdash;database=postgresql &mdash;skip-bundle
```</p>

<p>Unfortunately, rails is ran as root inside the container. We can change ownership and rights with this command :
```bash</p>

<h1>Change ownership</h1>

<p>sudo chown -R $USER:$USER .</p>

<h1>Change rights</h1>

<p>sudo chmod -R ug+rw .
```</p>

<h2>4. Make it Heroku ready</h2>

<p>Now that the rails files are generated, It&rsquo;s time to replace the bootstrap settings with real Heroku Dockerfile</p>

<p>Revert <code>Dockerfile</code> to simply :
<code>
FROM heroku/ruby
</code></p>

<p>Heroku uses <a href="http://puma.io/">Puma</a> so we need to add it to our <code>Gemfile</code>
```ruby</p>

<h1>Use Puma as the app server</h1>

<p>gem &lsquo;puma&rsquo;, &lsquo;~> 3.0&rsquo;
<code>
We also need to add a config file for Puma. Create</code>config/puma.rb<code>with this content (you can check [heroku doc](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#adding-puma-to-your-application) for details)
</code>ruby
workers Integer(ENV[&lsquo;WEB_CONCURRENCY&rsquo;] || 2)
threads_count = Integer(ENV[&lsquo;RAILS_MAX_THREADS&rsquo;] || 5)
threads threads_count, threads_count</p>

<p>preload_app!</p>

<p>rackup      DefaultRackup
port        ENV[&lsquo;PORT&rsquo;]     || 3000
environment ENV[&lsquo;RACK_ENV&rsquo;] || &lsquo;development&rsquo;</p>

<p>on_worker_boot do
  # Worker specific setup for Rails 4.1+
  # See: <a href="https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot</a>
  ActiveRecord::Base.establish_connection
end
```</p>

<p>It should now be possible to rebuild the container, and run the app :
```bash</p>

<h1>Rebuild the containers</h1>

<p>docker-compose build</p>

<h1>Start the rails app using the web container</h1>

<p>docker-compose up web
```
The app should be accessible at <a href="http://0.0.0.0:8080">http://0.0.0.0:8080</a></p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/rails-homepage.jpg" title="The default homepage for a new Rails application" ></p>

<h2>5. Deploying to heroku</h2>

<p>We&rsquo;re almost ready to deploy to heroku.</p>

<p>First, we need to exclude development files from our image. For this, we need to create a <code>.dockerignore</code> file with the content
<code>
.git*
db/*.sqlite3
db/*.sqlite3-journal
log/*
tmp/*
Dockerfile
.env
docker-compose.yml
docker-compose.override.yml
README.rdoc
</code>
It&rsquo;s then classic Heroku deploy commands :</p>

<p>```bash</p>

<h1>create an Heroku app</h1>

<p>heroku apps:create &lt;your-app-name></p>

<h1>And deploy to it</h1>

<p>heroku container:release &mdash;app &lt;your-app-name>
```</p>

<p>Your app should be accessible on line at <a href="https://">https://</a>&lt;your-app-name>.herokuapp.com/</p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/deployed-to-heroku.jpg" title="The typical error message when you deploy a new Rails app to heroku" ></p>

<p>Rails does not provide a default homepage in production. But you can check the logs with</p>

<p><code>bash
heroku logs --app &lt;your-app-name&gt;
</code></p>

<h2>6. Running commands</h2>

<p>When in development mode, you might want to run rails or other commands on your source code again. The shell container exists just for that, run <code>docker-compose run shell ...</code>.
```bash</p>

<h1>For example, to update your bundle</h1>

<p>docker-compose run shell bundle update
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Compose trick : How to have an overridable environment variable in development mode ?]]></title>
    <link href="http://philippe.bourgau.net/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode/"/>
    <updated>2016-07-04T03:55:00+00:00</updated>
    <id>http://philippe.bourgau.net/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode</id>
    <content type="html"><![CDATA[<p>I have recently been playing with <a href="https://www.docker.com/">Docker</a> and <a href="https://docs.docker.com/compose/">Docker Compose</a> while starting <a href="https://github.com/philou/planning-poker">my new side project</a>. I&rsquo;ve fallen into a situation where my production container uses a value for an environment variable, but while developing, I&rsquo;ll need both a different default and the ability to override this value.</p>

<p>I&rsquo;m using <a href="http://rubyonrails.org/">Rails</a> and found various references about how to deploy Rails app using Docker, but in the end, I decided to use <a href="http://www.heroku.com">Heroku</a> which handles a lot of ops for me. Rails uses the RAILS_ENV environment variable to know if it&rsquo;s going to run in development, test or production mode. The <a href="https://hub.docker.com/r/heroku/ruby/">heroku/ruby</a> image sets <code>RAILS_ENV=production</code>, but we usually want to use <code>RAILS_ENV=development</code> locally. I could have overridden RAILS_ENV in a docker-compose.override.yml file, but that would prevent me from running my app in production locally.</p>

<h2>The trick</h2>

<p>I eventually fixed my issue with combination of 2 files.</p>

<h3>docker-compose.override.yml</h3>

<p>```yaml
web:
  &hellip;
  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>&hellip;
```</p>

<h3>.env</h3>

<p><code>bash
RAILS_ENV=development
</code></p>

<h3>The logs</h3>

<p>My app starts in development mode by default :</p>

<p><code>bash
philou@philou-UX31E:~/code/planning-poker$ docker-compose up web
Starting planningpoker_herokuPostgresql_1
Recreating planningpoker_web_1
Attaching to planningpoker_web_1
web_1               | Puma starting in single mode...
web_1               | * Version 3.4.0 (ruby 2.2.3-p173), codename: Owl Bowl Brawl
web_1               | * Min threads: 5, max threads: 5
web_1               | * Environment: development
web_1               | * Listening on tcp://0.0.0.0:8080
web_1               | Use Ctrl-C to stop
</code></p>

<p>But I can still override RAILS_ENV to test for example :</p>

<p><code>bash
philou@philou-UX31E:~/code/planning-poker$ RAILS_ENV=test docker-compose up web
planningpoker_herokuPostgresql_1 is up-to-date
Recreating planningpoker_web_1
Attaching to planningpoker_web_1
web_1               | Puma starting in single mode...
web_1               | * Version 3.4.0 (ruby 2.2.3-p173), codename: Owl Bowl Brawl
web_1               | * Min threads: 5, max threads: 5
web_1               | * Environment: test
web_1               | * Listening on tcp://0.0.0.0:8080
web_1               | Use Ctrl-C to stop
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automatic Travis daily build with Heroku scheduler]]></title>
    <link href="http://philippe.bourgau.net/automatic-travis-daily-build-with-heroku-scheduler/"/>
    <updated>2014-03-24T06:31:00+00:00</updated>
    <id>http://philippe.bourgau.net/automatic-travis-daily-build-with-heroku-scheduler</id>
    <content type="html"><![CDATA[<p>As <a href="/auchandirect-scrapi-an-unofficial-api-ruby-gem/">I just released</a> <a href="https://github.com/philou/auchandirect-scrAPI">auchandirect-scrAPI</a>, and that it relies on scrapping, I needed a daily build.</p>

<p>The <a href="https://travis-ci.org">Travis</a> team <a href="https://github.com/travis-ci/travis-ci/issues/582">is already working</a> on this, and I found a small utility app called <a href="http://traviscron.pythonanywhere.com/">TravisCron</a> where anyone can register his repo for an automatic build.</p>

<p>Unfortunately, the feature is not yet ready in Travis, and the TravisCron guys did not yet activate my repo. After having a look at the <a href="https://github.com/FiloSottile/travis-cron">TravisCron source code</a> and the <a href="https://github.com/travis-ci/travis.rb">Travis API</a>, I found out that it is really simple to do the same thing on my own.</p>

<p>That&rsquo;s how I created <a href="https://github.com/philou/daily-travis">daily-travis</a>. It&rsquo;s a tiny Rake task, ready to be pushed and automaticaly scheduled on heroku that will restart the latest build when run.</p>

<p>Details are in the <a href="https://github.com/philou/daily-travis/blob/master/README.md">README</a></p>

<p>@Travis : Thanks again for your service.</p>

<p><img class="center" src="/imgs/2014-03-24-automatic-travis-daily-build-with-heroku-scheduler/travis-ci.jpeg" title="I love Travis logo" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to copy a database from an heroku app to another]]></title>
    <link href="http://philippe.bourgau.net/how-to-copy-a-database-from-an-heroku-app-to/"/>
    <updated>2013-01-11T00:00:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-copy-a-database-from-an-heroku-app-to</id>
    <content type="html"><![CDATA[<p>For <a href="http://www.mes-courses.fr">mes-courses.fr</a>, I am using another heroku app as "integration" app, where I can do late verifications before deploying to my production app. If you don't already do this, I recommend you to start now !</p>


<p>One thing that I needed was to copy data from my production app to my integration app. It turns out that <a href="https://devcenter.heroku.com/articles/heroku-postgres-import-export">heroku</a> makes this very easy :</p>


<p><code>sh
heroku pgbackups:restore DATABASE `heroku pgbackups:url --app my-app-prod` --app my-app-integ --confirm my-app-integ
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I set up a trustico rapid ssl certificate on heroku ssl endpoint]]></title>
    <link href="http://philippe.bourgau.net/how-i-set-up-a-trustico-rapid-ssl-certificate/"/>
    <updated>2012-12-13T00:00:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-i-set-up-a-trustico-rapid-ssl-certificate</id>
    <content type="html"><![CDATA[<p>This can be quite time consuming if it is the first time you set up an ssl endpoint. Here is how I did it :</p>


<ol><li>Purchase a rapidssl certificate for my domain on <a href="http://www.trustico.com" target="_blank">www.trustico.com</a>. Make sure to use the insurrance option so that you can download the private key later. I had to setup an email account at <a href="mailto:admin@mes-courses.fr" target="_blank">admin@mes-courses.fr</a> so that I could receive their confirmation link email.</li> <li>Once you have bought your certificate, login in to you trustico account and download your certificate, the intermediate certificate, and the private key.</li><li>Concatenate the final and intermediate certificates to a single file (let&#39;s call it server.crt).</li> <li>Add the ssl endpoint add on to your heroku application
```sh
heroku addons:add ssl:endpoint
```
</li><li>Upload your certificate
```sh
heroku certs:add server.crt private.key
```
</li><li>Run the following and verify that you have an ssl endpoint with an explicit trusted &quot;True&quot; value
```sh
heroku certs
```
</li><li>Note the ssl-endpoint full domain from the previous command line, and add a DNS CNAME record from your domain to this endpoint</li>
<li>Check that there are no A DNS records pointing to heroku ips on your dns configuration (It used to be the case with older versions of heroku)</li>
<li>Wait until dns are updated to check that it is working.</li>
</ol>


<p> You can check how your dns settings are spreading with <a href="http://www.whatsmydns.net/" target="_blank">www.whatsmydns.net</a> and <a href="http://www.reverse-dns.fr/">http://www.reverse-dns.fr/</a>. The <a href="https://devcenter.heroku.com/articles/ssl-endpoint">heroku ssl-endpoint help page</a> was a real brain saver<a href="https://devcenter.heroku.com/articles/ssl-endpoint">.</a></p>


<p>EDIT 10/10/2013</p>

<p>Any certificate will eventually expire, and need to be renewed. The process for this (at Trustico at least) is to generate a completly new certificate. To install this new certificate on heroku, start by combining the new certificate files as you did the first time, and then use</p>

<p><code>
heroku certs:update server.crt private.key
</code></p>

<p>instead of heroku certs:add. This should be enough, there is no need to update any dns entry.</p>

<p>To make sure the new certificate is used, visit the heroku ssl endpoint directly (get it by running heroku certs) and then visit your ssl site to check the certificate infos from your browser.</p>
]]></content>
  </entry>
  
</feed>
