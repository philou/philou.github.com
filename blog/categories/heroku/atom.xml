<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2016-08-10T03:58:44+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to setup Rails, Docker, PostgreSQL (and Heroku) for local development ?]]></title>
    <link href="http://philippe.bourgau.net/how-to-setup-rails-docker-postgresql-and-heroku-for-local-development/"/>
    <updated>2016-07-20T06:12:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-setup-rails-docker-postgresql-and-heroku-for-local-development</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/philou/planning_poker">My current side project</a> is an online tool to do remote planning pokers. I followed my <a href="/how-to-boot-a-new-rails-project-with-docker-and-heroku/">previous tutorial</a> to setup Rails, Docker and Heroku.</p>

<p>Naturally, as a BDD proponent, I tried to install <a href="https://cucumber.io">cucumber</a> to write my first scenario.</p>

<p>Here is the result of my first cucumber run :</p>

<p><code>bash
$ docker-compose run shell bundle exec cucumber
rails aborted!
PG::ConnectionBad: could not translate host name "postgres://postgres:@herokuPostgresql:5432/postgres" to address: Name or service not known
...
</code></p>

<p>It turned out that I had taken instructions from a <a href="https://blog.codeship.com/deploying-docker-rails-app/">blog article on codeship</a> that mistakenly used <code>host:</code> instead of <code>url:</code> in their <code>config/database.yml</code></p>

<p>After fixing that in my database.yml file, things where only slightly working better :</p>

<p><code>bash
$ docker-compose run shell bundle exec cucumber
rails aborted!
ActiveRecord::StatementInvalid: PG::ObjectInUse: ERROR:  cannot drop the currently open database
: DROP DATABASE IF EXISTS "postgres"
</code></p>

<p>The thing is the config was still using the same database for all environments. That&rsquo;s not exactly what I wanted. I updated my <code>config/database.yml</code> :</p>

<p>```yaml
default: &amp;default
  adapter: postgresql
  encoding: unicode
  pool: 5
  timeout: 5000
  username: postgres
  port: 5432
  host: herokuPostgresql</p>

<p>development:
  &lt;&lt;: *default
  database: planning_poker_development</p>

<p>test: &amp;test
  &lt;&lt;: *default
  database: planning_poker_test</p>

<p>production:
  &lt;&lt;: *default
  url: &lt;%= ENV[&lsquo;DATABASE_URL&rsquo;] %>
```</p>

<p>Victory ! Cucumber is running</p>

<p>```bash
$ docker-compose run shell bundle exec cucumber
Using the default profile&hellip;
0 scenarios
0 steps
0m0.000s
Run options: &mdash;seed 45959</p>

<h1>Running:</h1>

<p>Finished in 0.002395s, 0.0000 runs/s, 0.0000 assertions/s.</p>

<p>0 runs, 0 assertions, 0 failures, 0 errors, 0 skips
```</p>

<h2>Fixing rake db:create</h2>

<p>By searching through the web, I found that people were having similar issues with rake db:create. I tried to run it and here is what I got :</p>

<p><code>bash
$ docker-compose run shell bundle exec rake db:create
Database 'postgres' already exists
Database 'planning_poker_test' already exists
</code></p>

<p>Why is it trying to create the postgres database ? It turns out that the DATABASE_URL takes precedence over what is defined in my <code>config/database.yml</code>. I need to unset this variable locally. I already have the <code>docker-compose.override.yml</code> for that :</p>

<p>```yaml
web:
  environment:</p>

<pre><code>DATABASE_URL:
</code></pre>

<p>  &hellip;</p>

<p>shell:
  environment:</p>

<pre><code>DATABASE_URL:
</code></pre>

<p>  &hellip;
```</p>

<p>Rake db:create works just fine now :</p>

<p><code>bash
$ docker-compose run shell bundle exec rake db:create
Database 'planning_poker_development' already exists
Database 'planning_poker_test' already exists
</code></p>

<h2>Starting a psql session</h2>

<p>During all my trouble-shootings, I tried to connect to the Postgresql server to make sure that the databases where created and ready. Here is how I managed to do that :</p>

<h3>1. Install psql client</h3>

<p>On my Ubuntu machine, that was a simple <code>sudo apt-get install postgresql-client-9.4</code>.</p>

<h3>2. Finding the server port</h3>

<p>The port can be found through <code>config/database.yml</code> or through <code>docker ps</code>. Let&rsquo;s use the later, as we&rsquo;ll need it to find the server IP as well.</p>

<p><code>bash
$ docker ps
CONTAINER ID        IMAGE            COMMAND                  CREATED             STATUS              PORTS           NAMES
b58ce42d2b2b        postgres         "/docker-entrypoint.s"   46 hours ago        Up 46 hours         5432/tcp        planningpoker_herokuPostgresql_1
</code></p>

<p>Here the port is clearly 5432.</p>

<h3>3. Finding the server IP</h3>

<p>Using the container id we got on previous <code>docker ps</code> command, we can use <code>docker inspect</code> to get further details :</p>

<p>```bash
$ docker inspect b58ce42d2b2b | grep IPAddress</p>

<pre><code>        "SecondaryIPAddresses": null,
        "IPAddress": "172.17.0.2",
                "IPAddress": "172.17.0.2",
</code></pre>

<p>```</p>

<h3>4. Connecting to the database</h3>

<p>Connecting is now just a matter of filling the command line.</p>

<p>```sql
$ psql -U postgres -p 5432 -d planning_poker_development -h 172.17.0.2
planning_poker_development=# select * from schema_migrations;</p>

<h2> version</h2>

<p>(0 rows)
```</p>

<h3>5. Installing psql client directly in the shell</h3>

<p>It should be possible to install the psql client in the shell container automatically, but I must admit I did not try this yet. It should just a matter of adding this to the <code>Dockerfile</code></p>

<p><code>
RUN apt-get install postgresql-client-&lt;version&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to boot a new Rails project with Docker and Heroku]]></title>
    <link href="http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku/"/>
    <updated>2016-07-13T04:55:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku</id>
    <content type="html"><![CDATA[<p>A few years ago, I used <a href="http://www.heroku.com">Heroku</a> to deploy my <a href="https://github.com/philou/mes-courses">side-project</a>. It provides great service, but I remember that updates to the Heroku Stack was a nightmare &hellip; Versions of the OS (and nearly everything) changed. The migration was a matter of days, and while doing a side-project, this was difficult. At the time, I remember thinking that using branches and VMs would have been the solution.</p>

<p>Now that I started to use Heroku again, I decided to use <a href="http://www.docker.com">Docker</a> from the beginning. More specifically, I am expecting :</p>

<ul>
<li>to have a minimal setup on my host machine</li>
<li>to use the same infrastructure in dev than in production</li>
<li>to simplify switching to a new machine</li>
<li>to simplify the migration to the next Heroku stack</li>
</ul>


<p>As an added benefit, if ever someone else joins me in my side-project, it will be a matter of minutes before we can all work on the same infrastructure !</p>

<p>Heroku provides a <a href="https://devcenter.heroku.com/articles/local-development-with-docker">tutorial</a> about how to deploy an existing <a href="http://rubyonrails.org/">Rails</a> app to heroku using containers. Unfortunately, I did yet have an existing rails app &hellip; So the first challenge I faced, was how to create a Rails app without actually installing Rails on my machine. The trick is to bootstrap rails in docker itself before packaging all this for Heroku.</p>

<p>{% img center /imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/logos.jpg The 3 logos of Rails, Docker and Heroku %}</p>

<h2>1. Install the required software</h2>

<p>I installed only 4 things on my host machine
&ndash; Docker <a href="https://docs.docker.com/engine/installation/">instructions</a>
&ndash; Docker Compose <a href="https://docs.docker.com/compose/install/">instructions</a>
&ndash; Heroku Toolbelt <a href="https://toolbelt.heroku.com/">instructions</a>
&ndash; Heroku container plugin <code>heroku plugins:install heroku-container-tools</code></p>

<p>That&rsquo;s all I changed to my host machine.</p>

<h2>2. Setup docker</h2>

<p>First, let&rsquo;s create a new dir and step into it. Run :
<code>bash
mkdir docker-rails-heroku
cd docker-rails-heroku
</code>
To prepare the Heroku setup, create a <code>Procfile</code>
<code>
web: bundle exec puma -C config/puma.rb
</code>
and <code>app.json</code>
```json
{
  &ldquo;name&rdquo;: &ldquo;Docker Rails Heroku&rdquo;,
  &ldquo;description&rdquo;: &ldquo;An example app.json for container-deploy&rdquo;,
  &ldquo;image&rdquo;: &ldquo;heroku/ruby&rdquo;,
  &ldquo;addons&rdquo;: [</p>

<pre><code>"heroku-postgresql"
</code></pre>

<p>  ]
}
<code>
To generate docker files for Heroku, run :
</code>bash
heroku container:init
```
You want to run Rails in dev mode locally, so we need to override Heroku&rsquo;s default env (<a href="/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode/">Check my previous post for details</a>)</p>

<p>Create an <code>.env</code> file
<code>
RAILS_ENV=development
</code>
and <code>docker-compose.override.yml</code>
```yaml
web:
  volumes:</p>

<pre><code>- '.:/app/user'
</code></pre>

<p>  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>shell:
  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>```</p>

<h2>3. Create the Rails app</h2>

<p>It&rsquo;s now time to follow <a href="https://docs.docker.com/compose/rails/">the official docker-compose rails tutorial</a> to bootstrap the rails app and directories :</p>

<p>Change <code>Dockerfile</code> to
```</p>

<h1>FROM heroku/ruby</h1>

<p>FROM ruby:2.2.0
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs
RUN mkdir /myapp
WORKDIR /myapp
ADD Gemfile /myapp/Gemfile
ADD Gemfile.lock /myapp/Gemfile.lock
RUN bundle install
ADD . /myapp
```</p>

<p>Create a bootstrap <code>Gemfile</code> with the content
<code>ruby
source 'https://rubygems.org'
gem 'rails', '4.2.0'
</code>
Bundle install within the container requires a existing <code>Gemfile.lock</code>
```bash</p>

<h1>Create an empty Gemfile.lock</h1>

<p>touch Gemfile.lock
```</p>

<p>It&rsquo;s now time to build your docker container to be able to run rails and generate your source files. Run the following :
```bash</p>

<h1>Build your containers</h1>

<p>docker-compose build</p>

<h1>Run rails within the shell container and generate rails files</h1>

<p>docker-compose run shell bundle exec rails new . &mdash;force &mdash;database=postgresql &mdash;skip-bundle
```</p>

<p>Unfortunately, rails is ran as root inside the container. We can change ownership and rights with this command :
```bash</p>

<h1>Change ownership</h1>

<p>sudo chown -R $USER:$USER .</p>

<h1>Change rights</h1>

<p>sudo chmod -R ug+rw .
```</p>

<h2>4. Make it Heroku ready</h2>

<p>Now that the rails files are generated, It&rsquo;s time to replace the bootstrap settings with real Heroku Dockerfile</p>

<p>Revert <code>Dockerfile</code> to simply :
<code>
FROM heroku/ruby
</code></p>

<p>Heroku uses <a href="http://puma.io/">Puma</a> so we need to add it to our <code>Gemfile</code>
```ruby</p>

<h1>Use Puma as the app server</h1>

<p>gem &lsquo;puma&rsquo;, &lsquo;~> 3.0&rsquo;
<code>
We also need to add a config file for Puma. Create</code>config/puma.rb<code>with this content (you can check [heroku doc](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#adding-puma-to-your-application) for details)
</code>ruby
workers Integer(ENV[&lsquo;WEB_CONCURRENCY&rsquo;] || 2)
threads_count = Integer(ENV[&lsquo;RAILS_MAX_THREADS&rsquo;] || 5)
threads threads_count, threads_count</p>

<p>preload_app!</p>

<p>rackup      DefaultRackup
port        ENV[&lsquo;PORT&rsquo;]     || 3000
environment ENV[&lsquo;RACK_ENV&rsquo;] || &lsquo;development&rsquo;</p>

<p>on_worker_boot do
  # Worker specific setup for Rails 4.1+
  # See: <a href="https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot</a>
  ActiveRecord::Base.establish_connection
end
```</p>

<p>It should now be possible to rebuild the container, and run the app :
```bash</p>

<h1>Rebuild the containers</h1>

<p>docker-compose build</p>

<h1>Start the rails app using the web container</h1>

<p>docker-compose up web
```
The app should be accessible at <a href="http://0.0.0.0:8080">http://0.0.0.0:8080</a></p>

<p>{% img center /imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/rails-homepage.jpg The default homepage for a new Rails application %}</p>

<h2>5. Deploying to heroku</h2>

<p>We&rsquo;re almost ready to deploy to heroku.</p>

<p>First, we need to exclude development files from our image. For this, we need to create a <code>.dockerignore</code> file with the content
<code>
.git*
db/*.sqlite3
db/*.sqlite3-journal
log/*
tmp/*
Dockerfile
.env
docker-compose.yml
docker-compose.override.yml
README.rdoc
</code>
It&rsquo;s then classic Heroku deploy commands :</p>

<p>```bash</p>

<h1>create an Heroku app</h1>

<p>heroku apps:create &lt;your-app-name></p>

<h1>And deploy to it</h1>

<p>heroku container:release &mdash;app &lt;your-app-name>
```</p>

<p>Your app should be accessible on line at <a href="https://">https://</a>&lt;your-app-name>.herokuapp.com/</p>

<p>{% img center /imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/deployed-to-heroku.jpg The typical error message when you deploy a new Rails app to heroku %}</p>

<p>Rails does not provide a default homepage in production. But you can check the logs with</p>

<p><code>bash
heroku logs --app &lt;your-app-name&gt;
</code></p>

<h2>6. Running commands</h2>

<p>When in development mode, you might want to run rails or other commands on your source code again. The shell container exists just for that, run <code>docker-compose run shell ...</code>.
```bash</p>

<h1>For example, to update your bundle</h1>

<p>docker-compose run shell bundle update
```</p>

<h3>EDIT 2016-07-20</h3>

<p>For the moment, there&rsquo;s a catch with bundle install or update commands, as the gems are installed outside the shared volume, only Gemfile.lock will be updated, which required to run docker-compose build again &hellip; I&rsquo;ll have a look into this later and see if I can fix that.</p>

<p><code>bash
docker-compose run shell bundle update
docker-compose build
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Compose trick : How to have an overridable environment variable in development mode ?]]></title>
    <link href="http://philippe.bourgau.net/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode/"/>
    <updated>2016-07-04T03:55:00+00:00</updated>
    <id>http://philippe.bourgau.net/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode</id>
    <content type="html"><![CDATA[<p>I have recently been playing with <a href="https://www.docker.com/">Docker</a> and <a href="https://docs.docker.com/compose/">Docker Compose</a> while starting <a href="https://github.com/philou/planning-poker">my new side project</a>. I&rsquo;ve fallen into a situation where my production container uses a value for an environment variable, but while developing, I&rsquo;ll need both a different default and the ability to override this value.</p>

<p>I&rsquo;m using <a href="http://rubyonrails.org/">Rails</a> and found various references about how to deploy Rails app using Docker, but in the end, I decided to use <a href="http://www.heroku.com">Heroku</a> which handles a lot of ops for me. Rails uses the RAILS_ENV environment variable to know if it&rsquo;s going to run in development, test or production mode. The <a href="https://hub.docker.com/r/heroku/ruby/">heroku/ruby</a> image sets <code>RAILS_ENV=production</code>, but we usually want to use <code>RAILS_ENV=development</code> locally. I could have overridden RAILS_ENV in a docker-compose.override.yml file, but that would prevent me from running my app in production locally.</p>

<h2>The trick</h2>

<p>I eventually fixed my issue with combination of 2 files.</p>

<h3>docker-compose.override.yml</h3>

<p>```yaml
web:
  &hellip;
  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>&hellip;
```</p>

<h3>.env</h3>

<p><code>bash
RAILS_ENV=development
</code></p>

<h3>The logs</h3>

<p>My app starts in development mode by default :</p>

<p><code>bash
philou@philou-UX31E:~/code/planning-poker$ docker-compose up web
Starting planningpoker_herokuPostgresql_1
Recreating planningpoker_web_1
Attaching to planningpoker_web_1
web_1               | Puma starting in single mode...
web_1               | * Version 3.4.0 (ruby 2.2.3-p173), codename: Owl Bowl Brawl
web_1               | * Min threads: 5, max threads: 5
web_1               | * Environment: development
web_1               | * Listening on tcp://0.0.0.0:8080
web_1               | Use Ctrl-C to stop
</code></p>

<p>But I can still override RAILS_ENV to test for example :</p>

<p><code>bash
philou@philou-UX31E:~/code/planning-poker$ RAILS_ENV=test docker-compose up web
planningpoker_herokuPostgresql_1 is up-to-date
Recreating planningpoker_web_1
Attaching to planningpoker_web_1
web_1               | Puma starting in single mode...
web_1               | * Version 3.4.0 (ruby 2.2.3-p173), codename: Owl Bowl Brawl
web_1               | * Min threads: 5, max threads: 5
web_1               | * Environment: test
web_1               | * Listening on tcp://0.0.0.0:8080
web_1               | Use Ctrl-C to stop
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automatic Travis daily build with Heroku scheduler]]></title>
    <link href="http://philippe.bourgau.net/automatic-travis-daily-build-with-heroku-scheduler/"/>
    <updated>2014-03-24T06:31:00+00:00</updated>
    <id>http://philippe.bourgau.net/automatic-travis-daily-build-with-heroku-scheduler</id>
    <content type="html"><![CDATA[<p>As <a href="/auchandirect-scrapi-an-unofficial-api-ruby-gem/">I just released</a> <a href="https://github.com/philou/auchandirect-scrAPI">auchandirect-scrAPI</a>, and that it relies on scrapping, I needed a daily build.</p>

<p>The <a href="https://travis-ci.org">Travis</a> team <a href="https://github.com/travis-ci/travis-ci/issues/582">is already working</a> on this, and I found a small utility app called <a href="http://traviscron.pythonanywhere.com/">TravisCron</a> where anyone can register his repo for an automatic build.</p>

<p>Unfortunately, the feature is not yet ready in Travis, and the TravisCron guys did not yet activate my repo. After having a look at the <a href="https://github.com/FiloSottile/travis-cron">TravisCron source code</a> and the <a href="https://github.com/travis-ci/travis.rb">Travis API</a>, I found out that it is really simple to do the same thing on my own.</p>

<p>That&rsquo;s how I created <a href="https://github.com/philou/daily-travis">daily-travis</a>. It&rsquo;s a tiny Rake task, ready to be pushed and automaticaly scheduled on heroku that will restart the latest build when run.</p>

<p>Details are in the <a href="https://github.com/philou/daily-travis/blob/master/README.md">README</a></p>

<p>@Travis : Thanks again for your service.</p>

<p>{% img center /imgs/2014-03-24-automatic-travis-daily-build-with-heroku-scheduler/travis-ci.jpeg I love Travis logo %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to copy a database from an heroku app to another]]></title>
    <link href="http://philippe.bourgau.net/how-to-copy-a-database-from-an-heroku-app-to/"/>
    <updated>2013-01-11T00:00:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-copy-a-database-from-an-heroku-app-to</id>
    <content type="html"><![CDATA[<p>For <a href="http://www.mes-courses.fr">mes-courses.fr</a>, I am using another heroku app as "integration" app, where I can do late verifications before deploying to my production app. If you don't already do this, I recommend you to start now !</p>


<p>One thing that I needed was to copy data from my production app to my integration app. It turns out that <a href="https://devcenter.heroku.com/articles/heroku-postgres-import-export">heroku</a> makes this very easy :</p>


<p><code>sh
heroku pgbackups:restore DATABASE `heroku pgbackups:url --app my-app-prod` --app my-app-integ --confirm my-app-integ
</code></p>
]]></content>
  </entry>
  
</feed>
