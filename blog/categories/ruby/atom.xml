<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2016-05-02T04:16:33+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Most Common Ways To Speed up an algorithm]]></title>
    <link href="http://philippe.bourgau.net/most-common-ways-to-speed-up-an-algorithm/"/>
    <updated>2016-01-20T05:14:00+00:00</updated>
    <id>http://philippe.bourgau.net/most-common-ways-to-speed-up-an-algorithm</id>
    <content type="html"><![CDATA[<p>Algorithms are <em>hard</em>, and making them fast is even harder &hellip; But there are shortcuts that work quite often !</p>

<p><img class="center" src="/imgs/2016-01-20-most-common-ways-to-speed-up-an-algorithm/shortcut-road.jpg" title="A street panel called Short Cut Road" ></p>

<h2>The Challenge</h2>

<p>Imagine you just arrived to your new job, and you are asked to make a part of the system faster. After a bit of investigation, you discover that most of the time is spent in some weird in-house algorithm that seems to take forever. How can you optimize this without deep knowledge neither in algorithm science nor in the code itself ?</p>

<p>Here are 4 tricks to reduce the complexity of algorithms (I&rsquo;m using fairly basic examples for the sake of understandably. Most of these exact examples could be done better using standard libraries, but I hope it will be easy to adapt to other situations) :</p>

<h3>Replace a nested loop by first building a hash and then looping</h3>

<p>```ruby</p>

<h1>before</h1>

<p>orders.each do |order|
  client = list_of_clients.find {|client| client.id = order.client_id }
  handle_order(order, client)
end</p>

<h1>after</h1>

<p>clients_by_id = {}
list_of_clients.each do |client|
  clients_by_id[client.id] = client
end
orders.each do |order|
  handle_order(order, clients_by_id[order.client_id])
end
```
This reduces the complexity from O(2) to O(1). This is tremendous. On large lists O(2) algorithms are terrible.</p>

<h3>Remove unnecessary accumulations</h3>

<p>The most classic example is the use of a string buffer :</p>

<p>```ruby
// Before
report = &ldquo;&rdquo;
line_items.each do |line_item|
  report += line_item.to_s + &ldquo;\n&rdquo;
end</p>

<p>// After
report = []
line_items.each do |line_item|
  report &lt;&lt; line_item.to_s
  report &lt;&lt; &ldquo;\n&rdquo;
end
report.join
```
Again, this reduces the complexity from O(2) to O(1). Every language has variants of Java&rsquo;s StringBuilders. This does not only apply for strings, it works any time you are repeatedly accumulating results inside a loop but where you could do it only once at the end.</p>

<h3>Cache intermediate or previous results</h3>

<p>This is called <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>. Some algorithms (especially recursive algorithms) repeatedly compute the same thing again and again. Spotting this pattern is an opportunity to move an algorithm out of exponential complexity. For example, <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijsktra&rsquo;s algorithm</a> for finding the shortest path in a graph uses this technique to go from O(e<sup>n</sup>) to O(n<sup>2</sup>) complexity. If you suspect this could be helpful, your best friend is logging to trace actual parameters and results.</p>

<p><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#/media/File:Dijkstras_progress_animation.gif"><img class="center" src="/imgs/2016-01-20-most-common-ways-to-speed-up-an-algorithm/Dijkstras_progress_animation.gif" title="Dijsktra&rsquo;s path finding algorithm animated (from Wikipedia)" ></a></p>

<p>A word of caution : using memoization with mutable inputs or outputs will harm your mental health.</p>

<h3><a href="https://en.wikipedia.org/wiki/Merge_algorithm#Merging_two_lists">Zip merge</a></h3>

<p>There are 2 ways to merge sorted lists into a unique sorted list : the fast, and the slow &hellip;</p>

<p>```ruby</p>

<h1>The slow</h1>

<p>(list_1 + list_2).sort</p>

<h1>The fast</h1>

<p>i_1 = 0
i_2 = 0
result = []</p>

<p>while i_1 &lt; list_1.size and i_2 &lt; list_2.size
  if list_1[i_1] &lt;= list_2[i_2]</p>

<pre><code>result &lt;&lt; list_1[i_1]
i_1 += 1
</code></pre>

<p>  elsif list_2[i_2] &lt;= list_1[i_1]</p>

<pre><code>result &lt;&lt; list_2[i_2]
i_2 += 1
</code></pre>

<p>  end
end</p>

<p>while i_1 &lt; list_1.size
  result &lt;&lt; list_1[i_1]
  i_1 += 1
end</p>

<p>while i_2 &lt; list_2.size
  result &lt;&lt; list_2[i_2]
  i_2 += 1
end
```</p>

<p>Obviously, the slow version is a lot easier to read than the fast one. And the fast one could benefit from a bit of refactoring also &hellip; Nevertheless, the slow version is at best in O(n.ln(n)) whereas the fast on is in O(n). On large data, that can make a big difference.</p>

<h2>Is that all ?</h2>

<p>Obviously not, there can be a lot of other things going on slowly in algorithms, but from my experience, a software engineer can have a good career without knowing more about algorithms theory than that.</p>

<p>In the end, you manage to optimize this in-house algorithm, you become the company&rsquo;s hero, you need your job and get a pay raise !</p>

<h2>End word</h2>

<p>The fact is, in 15 years of writing software, I did not write a lot of algorithmic code. I can categories my working with algorithms in 3 :</p>

<ol>
<li>Write a simple algorithm for a non performance critical feature</li>
<li>Optimize an existing somewhat algorithmic part of code</li>
<li>Write a complex algorithm for a performance critical part of the system</li>
</ol>


<p>Case 1. is not really an issue since however the code will be written, it will run fast enough. If you&rsquo;re in case 3, there&rsquo;s no shortcut, you&rsquo;ll have to dig deep into algorithms and optimization, this happens rather rarely though. This leaves us with case 2, which I just wrote about.</p>

<p>Interestingly, <a href="http://www.murex.com">my current job</a> is deep into case 3 ! We&rsquo;re building a risk engine for corporate markets and are borrowing a lot of techniques from database science &hellip; which is, you can guess, rather algorithmic !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mining GitHub For New Hires]]></title>
    <link href="http://philippe.bourgau.net/mining-github-for-new-hires/"/>
    <updated>2015-08-19T05:30:00+00:00</updated>
    <id>http://philippe.bourgau.net/mining-github-for-new-hires</id>
    <content type="html"><![CDATA[<h2>In search of an experienced software engineer</h2>

<p>We have been trying to hire such a profile for the last year &hellip; The position is hopefully filled now. During that year, we have tried to mine <a href="https://github.com/">github</a> for candidates. Here is how we did it.</p>

<p><img class="center" src="/imgs/2015-08-19-mining-github-for-new-hires/github.png" title="Github&rsquo;s banner" ></p>

<p>Software engineers, especially experienced, are known to be hard to find. Over the past months, we had steadily been improving our hiring process :</p>

<ul>
<li>By regularly rewriting and optimizing our job post</li>
<li>By posting it on Twitter</li>
<li>By defining a precise interview template</li>
</ul>


<p>We went from very few applications to :</p>

<ul>
<li>More applications</li>
<li>More experienced candidates</li>
<li>Regular interviews</li>
<li>Effective interviews</li>
</ul>


<p>Unfortunately, we were still not interviewing candidates as skilled as we would have liked to. We were convinced that we were offering a great job : the project is very interesting, and the team is a dream to work in.</p>

<h2>How could we reach more great devs ?</h2>

<p>Someday, I played with <a href="https://github.com/">github</a>&rsquo;s Rest Api and I managed to write a short ruby script that finds the contributors to a given project that are living near Paris (France).</p>

<p>```ruby
require &lsquo;rubygems&rsquo;
require &lsquo;rest_client&rsquo;
require &lsquo;json&rsquo;</p>

<p>RestClient.proxy = &ldquo;<a href="http://proxy:3128">http://proxy:3128</a>&rdquo;</p>

<p>def github_get(resource)
  JSON.parse(RestClient.get(&ldquo;<a href="https://api.github.com#">https://api.github.com#</a>{resource}&rdquo;, params: {</p>

<pre><code>                          access_token: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
                          per_page: 200}))
</code></pre>

<p>end</p>

<p>repo = ARGV[0]</p>

<p>puts &ldquo;searching for #{repo} contributors in France&rdquo;</p>

<p>contributors = github_get(&ldquo;/repos/#{repo}/contributors&rdquo;)
logins_locations = contributors.map do |user|
  begin</p>

<pre><code>login = user['login']
location = github_get("/users/#{login}")['location']
{login: login, location: location}
</code></pre>

<p>  rescue Exception => e</p>

<pre><code>puts "could not see details of #{login} #{e}"
{login: login }
</code></pre>

<p>  end
end</p>

<p>puts &ldquo;Here are all the contributors&rdquo;
puts logins_locations
french_contributors = logins_locations.select do |login_location|
  location = login_location[:location]
  location != nil and</p>

<pre><code>(location.downcase.include?('france') or
 location.downcase.include?('paris'))
</code></pre>

<p>end</p>

<p>puts &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;
puts &ldquo;Here are all the frenchcontributors&rdquo;
puts french_contributors
```</p>

<h2>What&rsquo;s next ?</h2>

<p>We eventually filled the position before following our github experiment. We might continue some day though ! Here is a list of improvements I thought of :</p>

<ul>
<li>Gather a list of projects that overlap with what we are building</li>
<li>Search for repositories using some keyword or regular expression</li>
<li>List github users that contributed to such projects, that live near us and that know java</li>
<li>Use more complex algorithms to find best candidates (<a href="http://www.hackdiary.com/2010/02/10/algorithmic-recruitment-with-github/">Algorithmic Recruitment With GitHub</a>)</li>
<li>Spend more time socializing on GitHub (<a href="http://www.sourcecon.com/news/2014/01/21/the-complete-guide-to-recruiting-and-sourcing-candidates-on-github/">The Complete Guide To Recruiting And Sourcing Candidates On GitHub</a>)</li>
</ul>


<p>It really looks like if software is eating recruitment &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up Octopress with Vagrant and rbenv]]></title>
    <link href="http://philippe.bourgau.net/setting-up-octopress-with-vagrant-and-rbenv/"/>
    <updated>2015-03-20T05:33:00+00:00</updated>
    <id>http://philippe.bourgau.net/setting-up-octopress-with-vagrant-and-rbenv</id>
    <content type="html"><![CDATA[<p>I recently got hands on an abandonned laptop that was better than the one I was currently using for my personnal hackings, so I decided to switch to this one. I felt this was the time to learn Vagrant and save me some time later on. I settled on creating a <a href="https://www.vagrantup.com/">Vagrant</a> environment for this <a href="http://octopress.org/">Octopress</a> blogging. That proved a lot longer than I thought it would.</p>

<p><img class="center" src="/imgs/2015-03-20-setting-up-octopress-with-vagrant-and-rbenv/vagrant-octopress.png" title="Vagrant logo + Octopress logo" ></p>

<p>If you want to jump to the solution, just have a look at this <a href="https://github.com/philou/philou.github.com/commit/67b17f7702c213ff40313fc7bd0cbfa8a6e8e29b">git change</a>. Here is the slightly longer version.</p>

<ul>
<li><p>Add a Vagrantfile and setup a VM. There are explainations about how to do this all over the web, that was easy.</p></li>
<li><p>Provision your VM. That proved a lot more complex. There are a lot of examples using variants of <a href="https://www.chef.io/">Chef</a>, but the steep learning curve for Chef seemed unneccessarily complex compared to what I wanted to do. Eventually, I figured it out using simple shell provisioning.</p></li>
</ul>


<p>```ruby
  config.vm.provision &ldquo;shell&rdquo;, inline: &lt;&lt;-SHELL</p>

<pre><code>echo "Updating package definitions"
sudo apt-get update

echo "Installing git and build tools"
sudo apt-get -y install git autoconf bison build-essential libssl-dev libyaml-dev libreadline6-dev zlib1g-dev libncurses5-dev libffi-dev libgdbm3 libgdbm-dev
</code></pre>

<p>  SHELL</p>

<p>  config.vm.provision &ldquo;shell&rdquo;, privileged: false, inline: &lt;&lt;-SHELL</p>

<pre><code>git config --global user.name "john.doe"
git config --global user.email "john.doe@mail.com"

if [ ! -d "$HOME/.rbenv" ]; then
  echo "Installing rbenv and ruby-build"

  git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
  git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build

  echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bashrc
  echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bashrc

else
  echo "Updating rbenv and ruby-build"

  cd ~/.rbenv
  git pull

  cd ~/.rbenv/plugins/ruby-build
  git pull
fi

export PATH="$HOME/.rbenv/bin:$PATH"
eval "$(rbenv init -)"

if [ ! -d "$HOME/.rbenv/versions/2.2.0" ]; then
  echo "Installing ruby"

  rbenv install 2.2.0
  rbenv global 2.2.0

  gem update --system
  gem update

  gem install bundler
  bundle config path vendor/bundle

  rbenv rehash
fi

cd /vagrant
bundle install

if [ ! -d "/vagrant/_deploy" ]; then
  bundle exec rake setup_github_pages["git@github.com:philou/philou.github.com"]
  git checkout . # Revert github deploy url to my domain
  cd _deploy
  git pull origin master # pull to avoid non fast forward push
  cd ..
fi
</code></pre>

<p>  SHELL
```</p>

<ul>
<li><p>Setup port forwarding. That should have been simple &hellip; after forwarding port 4000 to 4000, I could still not manage to access my blog preview from the host machine. After searching throughout the web for a long time, I eventually fixed it with by adding <code>--host 0.0.0.0</code> to the rackup command line in <a href="https://github.com/philou/philou.github.com/commit/67b17f7702c213ff40313fc7bd0cbfa8a6e8e29b/Rakefile">Octopress Rackfile</a></p></li>
<li><p>Setup ssh forwarding. In order to be able to deploy to github pages with my local ssh keys, I added the following to my Vagrantfile.</p></li>
</ul>


<p>```ruby
  # The path to the private key to use to SSH into the guest machine. By
  # default this is the insecure private key that ships with Vagrant, since
  # that is what public boxes use. If you make your own custom box with a
  # custom SSH key, this should point to that private key.
  # You can also specify multiple private keys by setting this to be an array.
  # This is useful, for example, if you use the default private key to
  # bootstrap the machine, but replace it with perhaps a more secure key later.
  config.ssh.private_key_path = &ldquo;~/.ssh/id_rsa&rdquo;</p>

<p>  #  If true, agent forwarding over SSH connections is enabled. Defaults to false.
  config.ssh.forward_agent = true
```</p>

<ul>
<li>Fix virtual box synced folder. When I tried to pimp my favicon up, changing the png in the host machine did not update it on the guest ! I lost almost 3 hours figuring this out &hellip; searching google, I eventually found that <a href="http://docs.vagrantup.com/v2/synced-folders/virtualbox.html">Virtual Box synced folders can have issues</a>, and that <a href="http://stackoverflow.com/questions/18933547/vagrant-virtualbox-shared-folder-out-of-sync-when-there-are-many-file-related">installing the guest additions is recommended</a>. For this, just enter the following in the command line from your project&rsquo;s working dir :</li>
</ul>


<p><code>
vagrant plugin install vagrant-vbguest
vagrant reload
</code></p>

<p>I&rsquo;ll tell you if this does not do the trick.</p>

<p>I admit it was a lot longer than I expected it to be, but at least now it&rsquo;s repeatable !</p>

<p><a href="http://docker.io"><img class="center" src="/imgs/2015-03-20-setting-up-octopress-with-vagrant-and-rbenv/docker.png" title="The Docker logo" ></a></p>

<p>Next steps will be to use <a href="http://docker.io">Docker</a> providers and Dockerfile to factorize provisioning and speedup up VM startup.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cucumber_tricks gem : my favorite Gherkin and Cucumber tricks]]></title>
    <link href="http://philippe.bourgau.net/cucumber-tricks-gem-my-favorite-gherkin-and-cucumber-tricks/"/>
    <updated>2014-06-12T06:28:00+00:00</updated>
    <id>http://philippe.bourgau.net/cucumber-tricks-gem-my-favorite-gherkin-and-cucumber-tricks</id>
    <content type="html"><![CDATA[<p>I just compiled my Gherkin and Cucumber goodies into a gem. It&rsquo;s called <a href="https://rubygems.org/gems/cucumber_tricks">cucumber_tricks</a> and the source code can be found on <a href="https://github.com/philou/cucumber_tricks">github</a>. It&rsquo;s also tested on <a href="https://travis-ci.org/philou/cucumber_tricks">travis</a> and documented in details on <a href="https://www.relishapp.com/philou/cucumber-tricks/docs">relish</a>.</p>

<p>The goal of all these tricks is to be able to write more natural english scenarios. Here is an extract from the readme of the gem, which explains what it can do :</p>

<h3>Use pronouns to reference previously introduced items</h3>

<p>foo.feature</p>

<p><code>gherkin
Given the tool 'screwdriver'
When this tool is used
</code></p>

<p>steps.rb</p>

<p>```ruby
A_TOOL = NameOrPronounTransform(&lsquo;tool&rsquo;, &lsquo;hammer&rsquo;)</p>

<p>Given /^(#{A_TOOL})$/ do |tool|
  &hellip;
end
```</p>

<h3>Use the same step implementation to handle an inline arg as a 1-cell table</h3>

<p>steps.rb</p>

<p>```ruby
GivenEither /^the dog named &ldquo;(.*)&rdquo;$)$/,</p>

<pre><code>        /^the following dogs$/ do |dogs_table|
</code></pre>

<p>  &hellip;
end
```</p>

<p>foo.feature</p>

<p><code>gherkin
Given the dog "Rolphy"
...
Given the following dogs
  | Rex  |
  | King |
  | Volt |
</code></p>

<h3>Add default values to the hashes of a table</h3>

<p>foo.feature</p>

<p><code>gherkin
Given the following dogs
  | names | color |
  | Rex   | white |
  | King  | Sand  |
</code></p>

<p>steps.rb</p>

<p>```ruby
Given /^the following dogs$$/ do |dogs|
  hashes = dogs.hashes_with_defaults(&lsquo;names&rsquo;, &lsquo;tail&rsquo; => &lsquo;wagging&rsquo;, &lsquo;smell&rsquo; => &lsquo;not nice&rsquo;)</p>

<h1>hashes.each do |hash|</h1>

<h1>expect(hash[&lsquo;smell&rsquo;]).to eq(&lsquo;not nice&rsquo;)</h1>

<h1>end</h1>

<p>  &hellip;
end
```</p>

<h3>Define named lists from a table</h3>

<p>foo.feature</p>

<p><code>gherkin
Given the following dishes
  | Spaghetti Bolognaise | =&gt; | Spaghetti | Bolognaise sauce |       |         |
  | Burger               | =&gt; | Bread     | Meat             | Salad | Ketchup |
</code></p>

<p>steps.rb</p>

<p>```ruby
Given /^the following dishes$$/ do |dishes|
  name_2_dishes = dishes.hash_2_lists</p>

<h1>expect(name_2_dishes[&lsquo;Burger&rsquo;]).to eq([&lsquo;Bread&rsquo;,&lsquo;Meat&rsquo;,&lsquo;Salad&rsquo;,&lsquo;Ketchup&rsquo;])</h1>

<p>  &hellip;
end
```</p>

<p>Visit <a href="https://www.relishapp.com/philou/cucumber-tricks/docs">relish</a> for more detailed documentation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My new gem for creating rspec proxies]]></title>
    <link href="http://philippe.bourgau.net/my-new-gem-for-creating-rspec-proxies/"/>
    <updated>2014-05-23T06:20:00+00:00</updated>
    <id>http://philippe.bourgau.net/my-new-gem-for-creating-rspec-proxies</id>
    <content type="html"><![CDATA[<p>I already wrote a lot about test proxies (<a href="/how-to-stub-around-a-call-to-the-original-method-with-rspec/">here</a>, <a href="/hitting-the-middle-ground-between-classicist-and-mockist-tdd/">here</a> and <a href="/my-humble-advices-about-how-to-write-maintainable-tests/">here</a>).</p>

<p>I just took the time to transform my previous gist in a full fledged ruby gem. It&rsquo;s called &ldquo;rspecproxies&rdquo; and it can be found <a href="https://github.com/philou/rspecproxies">on github</a>. It&rsquo;s fully tested, documented and there&rsquo;s a usage section in the readme to help anyone get started.</p>

<p>Here are the pain points proxies try to fix :</p>

<ul>
<li>Without mocks, it is sometimes just awfully painfull to write the test (do you really want to start a background task just to get a completion ratio ?)</li>
<li>With classic stubs, you sometimes have to stub things you are not interested in in your test, you end up with unmaintainable extra long stub setup</li>
</ul>


<p>Let&rsquo;s have a look at a few examples of tests with proxies :</p>

<ul>
<li>Verify actual load count without interfering in any behaviour</li>
</ul>


<p>```ruby
it &lsquo;caches users&rsquo; do
  users = User.capture_results_from(:load)</p>

<p>  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)
  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)</p>

<p>  expect(users).to have_exactly(1).items
end
```</p>

<ul>
<li>Use proxies to stub an object that does not yet exist</li>
</ul>


<p>```ruby
it &lsquo;rounds the completion ratio&rsquo; do
   RenderingTask.proxy_chain(:load, :completion_ratio) {|s| s.and_return(0.2523) }</p>

<p>   renderingController.show</p>

<p>   expect(response).to include(&lsquo;25%&rsquo;)
end
```</p>

<p>I&rsquo;d really love to see more code tested with proxies, it makes the whole testing so much more natural. As with any testing techniques, we get more thorough testing from the ease of writing the test.</p>
]]></content>
  </entry>
  
</feed>
