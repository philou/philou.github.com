<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-04-19T06:08:22+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5 minutes hack to speed up RSpec in Rails 5 using in-memory SQLite]]></title>
    <link href="http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite/"/>
    <updated>2017-01-25T07:53:00+01:00</updated>
    <id>http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite</id>
    <content type="html"><![CDATA[<p>Here is the story : you have a <a href="http://rubyonrails.org/">Rails 5</a> app that uses <a href="http://rspec.info/">RSpec</a>, but your RSpec suite is getting slower and slower to run. You&rsquo;ve already considered some solutions :</p>

<ul>
<li>Use <a href="https://sqlite.org/">SQLite</a> in memory for your test env.</li>
</ul>


<p><code>yaml
test:
  adapter: sqlite3
  database: ":memory:"
</code></p>

<p>That&rsquo;s the most straightforward thing to do, but unfortunately, if you are sharing your test env with <a href="https://cucumber.io/">Cucumber</a>, you might want to use a production like DB with Cucumber (<a href="https://www.postgresql.org/">PostgreSQL</a> or whatever). So unless you are ready to setup a new env for cucumber (which I tried and don&rsquo;t recommend) you&rsquo;re stuck.</p>

<ul>
<li>Use mocks. That&rsquo;s surely going to work, it&rsquo;s going to make your test hell of a lot faster ! It will also make your tests a lot more fragile and more expensive to maintain &hellip; If you want to read more about why I think mocks are a bad idea, just have a look at <a href="/blog/categories/mocking/">these posts</a>.</li>
</ul>


<h2>The hack</h2>

<p>Here is a third alternative, I&rsquo;ve <a href="/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db/">already written about it</a>, but here it comes updated and tested for Rails 5 :</p>

<ol>
<li>Don&rsquo;t change anything to your <code>config/database.yml</code></li>
<li>Obviously, you&rsquo;ll need to add <code>sqlite3</code> to your <code>Gemfile</code></li>
<li>At the beginning of your <code>spec/rails_helper.rb</code>, replace</li>
</ol>


<p>``` ruby</p>

<h1>Checks for pending migration and applies them before tests are run.</h1>

<h1>If you are not using ActiveRecord, you can remove this line.</h1>

<p>ActiveRecord::Migration.maintain_test_schema!
```</p>

<p>with</p>

<p>``` ruby</p>

<h1>In order to keep the same RAILS_ENV for rspec and cucumber, and to make rspec</h1>

<h1>faster, patch the connection to use sqlite in memory when running rspec</h1>

<p>ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)
ActiveRecord::Schema.verbose = false
load &ldquo;#{Rails.root.to_s}/db/schema.rb&rdquo;
```</p>

<p>That&rsquo;s it ! Run your specs &hellip; not bad for a 5 minutes investment !</p>

<h4>Rails 5.1 (2017-03-29 Edit)</h4>

<p>My fresh hack started to fail on Rails 5.1 ! If <code>schema.rb</code> is generated with the Postgres adapter, it is now incompatible with this injected Sqlite adapter. Here is a patch that removes the glitches :</p>

<p>```ruby</p>

<h1>In order to keep the same RAILS_ENV for rspec and cucumber, and to make rspec</h1>

<h1>faster, patch the connection to use sqlite in memory when running rspec</h1>

<p>ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)
ActiveRecord::Schema.verbose = false</p>

<h1>load db agnostic schema by default. Needed to remove the &ldquo;, id: :serial&rdquo; from</h1>

<h1>the table definitions to make it load on sqlite</h1>

<p>eval(<code>cat #{Rails.root.to_s}/db/schema.rb | sed 's/,[^:]*: :serial\//g'</code>)
```</p>

<p>I admit this is getting a bit crappy, and I don&rsquo;t know how long it is going to work &hellip;</p>

<h2>One more thing &hellip;</h2>

<p>If you need even more speed, you can now run your specs in parallel in different processes ! Each in-memory SQLite DB is bound to its process, so unlike a real PostgreSQL dev DB, you won&rsquo;t get any conflicts between your tests ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verify the Big O Complexity of Ruby Code in RSpec]]></title>
    <link href="http://philippe.bourgau.net/verify-the-big-o-complexity-of-ruby-code-in-rspec/"/>
    <updated>2017-01-04T17:48:00+01:00</updated>
    <id>http://philippe.bourgau.net/verify-the-big-o-complexity-of-ruby-code-in-rspec</id>
    <content type="html"><![CDATA[<p>It might be possible to discover performance regressions before running your long and large scale benchmarks !</p>

<p><a href="https://github.com/philou/complexity-assert">complexity_assert</a> is an <a href="http://rspec.info/">RSpec</a> library that determines and checks the <a href="http://bigocheatsheet.com/">big O complexity</a> of a piece of code. Once you&rsquo;ve determined the performance critical sections of your system, you can use it to verify that they perform with the complexity you expect.</p>

<h2>How does it work ?</h2>

<p>The gem itself is the result of an experiment to learn machine learning in 20 hours (you can read more about that experiment in <a href="/how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours/">my previous post</a> if you want).</p>

<p>Suppose you have some a method, let&rsquo;s call it <code>match_products_with_orders(products, orders)</code> which is called in in one of your processes with very large arguments. Badly written, this method could be quadratic (O(n²)), which would lead to catastrophic performances in production. When coding it, you&rsquo;ve taken particular care to make it perform in linear time. Unfortunately, it could easily slip back to a slower implementation with a bad refactoring &hellip; Using complexity_assert, you can make sure that this does not happen :</p>

<p>``` ruby</p>

<h1>An adapter class to fit the code to measure in complexity assert</h1>

<p>class ProductsOrdersMatching</p>

<pre><code># Generate some arguments of a particular size
def generate_args(size)
    # Let's assume we have 10 times less products than orders
    [ Array.new(size / 10) { build_a_product() }, Array.new(size) { build_an_order() } ]
end

# Run the code on which we want to assert performance
def run(products, orders)
    match_products_with_orders(products, orders)
end
</code></pre>

<p>end</p>

<p>describe &ldquo;Products and Orders Matching&rdquo; do</p>

<pre><code>it "performs linearly" do
    # Verify that the code runs in time proportional to the size of its arguments
    expect(ProductOrdersMatching.new).to be_linear()
end
</code></pre>

<p>end
```</p>

<p>That&rsquo;s it ! If ever someone changes the code of <code>match_products_with_orders</code> and makes it perform worse than linearly, the assertion will fail ! There are similar assertions to check for constant and quadratic execution times.</p>

<p>Internally, the code will be called a number of times with different (smallish) sizes of arguments and the execution times will be logged. When this is over, by doing different flavors of linear regressions, it should determine whether the algorithm performs in O(1), O(n) or O(n²). Depending on your code, this can take time to run, but should still be faster than running large scale benchmarks.</p>

<p>Just check the <a href="https://github.com/philou/complexity-assert/blob/master/README.md">README</a> for more details.</p>

<h2>Did you say experiment ?</h2>

<p>It all started like an experiment. So the gem itself, is still experimental ! It&rsquo;s all fresh, and it could receive a lot of enhancements like :</p>

<ul>
<li>Allow the assertion to specify the sizes</li>
<li>Allow the assertion to specify the warm-up and run rounds</li>
<li>Robustness against garbage collection : use GC intensive ruby methods, and see how the regression behaves</li>
<li>Find ways to make the whole thing faster</li>
<li>O(lnx) : pre-treat with exp()</li>
<li>O(?lnx) : use exp, then a search for the coefficient (aka polynomial)</li>
<li>O(xlnx) : there is no well known inverse for that, we can compute it numerically though</li>
<li>Estimate how much the assert is deterministic</li>
<li>&hellip;</li>
</ul>


<p>As you see, there&rsquo;s a lot of room for ideas and improvements.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How NOT to use mocks, my talk at Paris.rb]]></title>
    <link href="http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb/"/>
    <updated>2016-09-13T04:03:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb</id>
    <content type="html"><![CDATA[<p>As I already <a href="/blog/categories/mocking/">wrote about</a>, mocks can be trecherous &hellip; I gave a talk about how to avoid them last tuesday at <a href="http://www.meetup.com/fr-FR/parisrb/">Paris.rb meetup</a>. Here are the <a href="https://docs.google.com/presentation/d/1OH3eBgjyMcpupUnGWsHXm7kQjkckFpnJStYYYqBL6Yk/edit?usp=sharing">slides</a>.</p>

<p>It talks about testing, mocking, but also <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a> and <a href="https://wincent.com/blog/proxies-with-rr">test proxies à la RR</a> (but for rspec).</p>

<iframe src="https://docs.google.com/presentation/d/1OH3eBgjyMcpupUnGWsHXm7kQjkckFpnJStYYYqBL6Yk/embed?start=false&loop=false&delayms=3000" frameborder="0" width="790" height="470" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>




<p><p/>
Check the speaker&rsquo;s comments for all the details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpecProxies now supports .to receive(xxx)... syntax]]></title>
    <link href="http://philippe.bourgau.net/rspecproxies-now-supports-to-receive-xxx-dot-dot-dot-syntax/"/>
    <updated>2016-08-23T04:47:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspecproxies-now-supports-to-receive-xxx-dot-dot-dot-syntax</id>
    <content type="html"><![CDATA[<p><img class="center" src="/imgs/2016-08-23-rspecproxies-now-supports-to-receive-xxx-dot-dot-dot-syntax/test_probes.jpg" title="Hardware test probes" ></p>

<p>Pure mocks are dangerous. They let defect go through, give a false sense of security and are difficult to maintain.</p>

<p>I&rsquo;ve already talked about it <a href="/hitting-the-middle-ground-between-classicist-and-mockist-tdd/">before</a> but since then, <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">DHH announced that he was quitting TDD</a>, the <a href="http://martinfowler.com/articles/is-tdd-dead/">Is TDD Dead ?</a> debate took place, and the conclusion is that <a href="https://www.thoughtworks.com/insights/blog/mockists-are-dead-long-live-classicists">mockist are dead</a>.</p>

<p>They are still times when mocks feel much simpler than any other things. For example, imagine your process leaks and crashes after 10 hours, the fix is to pass an option to a thirdparty, how would you test this in a fast test ? That&rsquo;s exactly the kind of situation where using test proxies saves you from mocks. A test proxy defers everything to the real object but also features unintrusive hooks and probes that you can use in your test. If you want a code example, check <a href="https://github.com/philou/mes-courses/commit/2c9fce17f9b59d0b3828f309015c07b17cceddf4?diff=split">this commit</a>, where I refactored a rails controller test from mocks to a RSpecProxies (v0.1).</p>

<p>I created RSpecProxies <a href="/my-new-gem-for-creating-rspec-proxies/">a while ago</a>, a while ago, and it&rsquo;s syntax made it alien to the RSpec work, it needed an update. <a href="http://rspec.info">RSpec</a> now supports basic proxying with partial stubs, spies, the <code>and_call_original</code> and the <code>and_wrap_original</code> methods. <a href="https://github.com/philou/rspecproxies">RSpecProxies 1.0</a> is a collection of hooks built on top of these to make proxying easier, with a syntax that will be familiar to RSpec users.</p>

<h2>Before original hook</h2>

<p>This hook is triggered before a call a method. Suppose you want to simulate a bad connection :</p>

<p>```ruby
it &lsquo;can simulate unreliable connection&rsquo; do
  i = 0
  allow(Resource).to receive(:get).and_before_calling_original { |*args|</p>

<pre><code>i += 1
raise RuntimeError.new if i % 3 == 0
</code></pre>

<p>  }</p>

<p>  resources = Resource.get_at_least(10)</p>

<p>  expect(resources.size).to eq(10)
end
```</p>

<h2>After original hooks</h2>

<p>RSpecProxies provides the same kind of hook after the call :</p>

<p>``` ruby
it &lsquo;can check that the correct data is used (using and_after_calling_original&rsquo; do
  user = nil
  allow(User).to receive(:load).and_after_calling_original { |result| user = result }</p>

<p>  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)</p>

<p>  expect(response).to include(user.created_at.to_s)
end
```</p>

<p>Here we are capturing the return value to use it later in the test. For this special purpose, RSpecProxies also provides 2 other helpers :</p>

<p>``` ruby</p>

<h1>Store the latest result in @user of self</h1>

<p>allow(User).to receive(:load).and_capture_result_into(self, :user)</p>

<h1>Collect all results in the users array</h1>

<p>users = []
allow(User).to receive(:load).and_collect_results_into(users)
```</p>

<h2>Proxy chains</h2>

<p>RSpec mocks provides the <code>message_chain</code> feature to do build chains of stubs. RSpecProxy provides a very similar proxy chain concept. The main difference is that it creates proxies along the way, and not pure stubs. Pure stubs assume that you are mocking everything, but as our goal is to mock as little as possible, using proxies makes more sense.</p>

<p>When using a mockist approach, the message chain is a bad smell because it makes your tests very brittle by depending on a lot of implementation. In contrast, proxy chains are meant to be used where they are the simplest way to inject what you need, without creating havoc.</p>

<p>For example, suppose you want to display the progress of a very slow background task. You could mock a lot of your objects to have a fast test, of if you wanted to avoid all the bad side effects of mocking, you could run the background task in your test, and have a slow test &hellip; Or, you could use a chain of proxies :</p>

<p>``` ruby
it &lsquo;can override a deep getter&rsquo; do
  allow(RenderingTask).to proxy_message_chain(&ldquo;load.completion_ratio&rdquo;) { |e| e.and_return(0.2523) }</p>

<p>  controller.show</p>

<p>  expect(response).to include(&lsquo;25%&rsquo;)
end
```</p>

<p>Here the simplest thing to do is just to override a small getter, because from a functionnal point of view, that&rsquo;s exactly what we want to test.</p>

<h2>Last word</h2>

<p>The code is on <a href="https://github.com/philou/rspecproxies">github</a>, v1.0.0 is on <a href="https://rubygems.org/gems/rspecproxies/versions/0.1.0">rubygems</a>, it requires Ruby v2.2.5 and RSpec v3.5, the license is MIT, help in any form are welcome !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to prepare a new Ruby env in 3 minutes using Docker]]></title>
    <link href="http://philippe.bourgau.net/how-to-prepare-a-new-ruby-env-in-3-minutes-using-docker/"/>
    <updated>2016-08-17T05:21:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-prepare-a-new-ruby-env-in-3-minutes-using-docker</id>
    <content type="html"><![CDATA[<p>One or two weeks ago, I registered to the <a href="http://www.meetup.com/fr-FR/Paris-Ruby-Workshop/">Paris Ruby Workshop Meetup</a> and needed a Ruby env. I have been using <a href="https://www.vagrantup.com/">Vagrant</a> quite a lot to isolate my different dev envs from each other and from my main machine. As I&rsquo;ve been digging more into <a href="http://www.docker.com">Docker</a> lately, I thought I&rsquo;d simply use Docker and Docker Compose instead.</p>

<p>I turned out to be dead simple. All that is needed is a <code>docker-compose.yml</code> file to define the container, record the shared volume and set a bundle path inside it :</p>

<p>```yaml
rubybox:
  image: ruby:2.3
  command: bash
  working_dir: /usr/src/app
  environment:</p>

<pre><code>BUNDLE_PATH: 'vendor/bundle'
</code></pre>

<p>  volumes:</p>

<pre><code>- '.:/usr/src/app'
</code></pre>

<p>```</p>

<p>Without the custom bundle path, bundled gems would be installed elsewhere in the container, and lost at every restart.</p>

<p>To use the Rubybox, just type <code>docker-compose run rubybox</code> and you&rsquo;ll get a shell from within your ruby machine, where you can do everything you want.</p>

<p>In fact, I found the thing so useful, that I created the <a href="https://github.com/philou/rubybox">Rubybox</a> git repo to simplify cloning and reusing. I&rsquo;ve already cloned it at least 3 times since then !</p>

<p><code>bash
git clone git@github.com:philou/rubybox.git
cd rubybox
docker-compose run rubybox
</code></p>
]]></content>
  </entry>
  
</feed>
