<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-05-17T06:07:34+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Custom Assertion Matchers will keep mocks away]]></title>
    <link href="http://philippe.bourgau.net/how-custom-assertion-matchers-will-keep-mocks-away/"/>
    <updated>2018-05-17T06:47:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-custom-assertion-matchers-will-keep-mocks-away</id>
    <content type="html"><![CDATA[<p>I cannot write a <a href="/blog/categories/how-to-avoid-mocks-series/">series about avoiding mocks</a> without mentioning Custom Assertion Matchers. If you don&rsquo;t know what custom assertions are, here is pseudo code that uses a custom assertion :</p>

<p><code>
assert.that(actual, VerifiesMyCustomAssertion(withCustomProperties))
</code></p>

<p>For more details, have a look at these examples for your preferred language : <a href="http://joel-costigliola.github.io/assertj/assertj-core-custom-assertions.html">Java</a>, <a href="https://relishapp.com/rspec/rspec-expectations/docs/custom-matchers">Ruby</a> or <a href="http://tonylukasavage.com/blog/2014/05/29/custom-assertions-in-should-dot-js/">Javascript</a>.</p>

<p><img src="../imgs/2018-05-15-how-custom-assertion-matchers-will-keep-mocks-away/matchers.jpg" alt="A drawing of a box of matches, branded 'Matchers' on top" /></p>

<p>That custom assertion matchers have an effect on mock usage might seem puzzling at first. Let me explain. Us, mere human developers, get lured into mocking when tests become too complicated. By keeping the tests simpler, Custom Assertion Matchers help use to avoid mocks. It&rsquo;s a bit like why test data builders keep mocks at bay.</p>

<blockquote><p>üí° We get lured into mocking when tests become too complicated</p></blockquote>

<p>I already blogged about <a href="/speed-up-the-tdd-feedback-loop-with-better-assertion-messages/">the benefits of Custom Assertion Matchers</a>. Here I&rsquo;m going to dive in their advantages against mocking.</p>

<p>This is the fifth post in a <a href="/blog/categories/how-to-avoid-mocks-series/">series about how to avoid mocks</a>. If you haven&rsquo;t yet, I recommend you to start from <a href="/careless-mocking-considered-harmful/">the beginning</a>.</p>

<h2>Why would we end up with mocks when we don&rsquo;t have matchers ?</h2>

<p>Let&rsquo;s walkthrough a small story. Suppose we are building an e-commerce website. When someone passes an order, we want to notify the analytics service. Here is some very simple code for that.</p>

<p>```ruby
class AnalyticsService</p>

<p>¬†def initialize<br/>
¬†¬†¬†@items = []<br/>
¬†end</p>

<p>¬†attr_reader :items</p>

<p>¬†def order_passed(customer, cart)<br/>
¬†¬†¬†cart.each do |item|<br/>
¬†¬†¬†¬†¬†@items.push(customer: customer, item: item)<br/>
¬†¬†¬†end<br/>
¬†end<br/>
end</p>

<p>class Order<br/>
¬†def initialize(customer, cart, analytics)<br/>
¬†¬†¬†@customer = customer<br/>
¬†¬†¬†@cart = cart<br/>
¬†¬†¬†@analytics = analytics<br/>
¬†end</p>

<p>¬†def pass<br/>
¬†¬†¬†# launch order processing and expedition</p>

<p>¬†¬†¬†@analytics.order_passed(@customer, @cart)<br/>
¬†end</p>

<p>end</p>

<p>describe &lsquo;Order&rsquo; do</p>

<p>¬†it &ldquo;notifies analytics service about passed orders&rdquo; do<br/>
¬†¬†¬†cart = [&ldquo;Pasta&rdquo;,&ldquo;Tomatoes&rdquo;]<br/>
¬†¬†¬†analytics = AnalyticsService.new<br/>
¬†¬†¬†order = Order.new(&ldquo;Philippe&rdquo;, cart, analytics)</p>

<p>¬†¬†¬†order.pass</p>

<p>¬†¬†¬†expect(analytics.items).to include(customer: &ldquo;Philippe&rdquo;, item: &ldquo;Pasta&rdquo;)<br/>
¬†¬†¬†expect(analytics.items).to include(customer: &ldquo;Philippe&rdquo;, item: &ldquo;Tomatoes&rdquo;)<br/>
¬†end<br/>
end
```</p>

<p>Let&rsquo;s focus on the tests a bit. We first notice that the verification section is large and difficult to understand. ¬†Looking in more details, it knows too much about the internals of AnalyticsService. We had to make the items accessor public just for the sake of testing. The test even knows how the items are stored in a list of hashes. If we were to refactor this representation, we would have to change the tests as well.</p>

<p>We could argue that responsibility-wise, our test should only focus on Order. It makes sense for the test to use a mock to verify that the Order calls AnalyticsService as expected. Let&rsquo;s see what this would look like.</p>

<p>```ruby
it &ldquo;notifies analytics service about passed orders&rdquo; do<br/>
¬†cart = [&ldquo;Pasta&rdquo;,&ldquo;Tomatoes&rdquo;]<br/>
¬†analytics = AnalyticsService.new<br/>
¬†order = Order.new(&ldquo;Philippe&rdquo;, cart, analytics)</p>

<p>¬†expect(analytics).to receive(:order_passed).with(&ldquo;Philippe&rdquo;, cart)</p>

<p>¬†order.pass<br/>
end
```</p>

<p>Sure, the test code is simpler. It&rsquo;s also better according to good design principles. The only glitch is that we now have a mock in place with all the problems I described <a href="/careless-mocking-considered-harmful/">before</a>.</p>

<p>This might not (yet) be a problem in our example but, for example, the mock &lsquo;cuts&rsquo; the execution of the program. Suppose that someday, the Order starts expecting something from the AnalyticsService. We&rsquo;d then need to &lsquo;simulate&rsquo; the real behavior in our mock. This would make the test very hard to maintain.</p>

<h2>Matchers to the rescue</h2>

<p>Let&rsquo;s see how a matcher could help us here. The idea is to improve on the first &lsquo;state checking&rsquo; solution to make it better than the mock one. We&rsquo;ll extract and isolate all the state checking code in a custom matcher. By factorizing the code in a single matcher, we&rsquo;ll reduce duplication. The matcher remains too intimate with the object, but as it is now unique and well named, it&rsquo;s less of a problem. Plus, as always with matchers, we improved readability.</p>

<p>```ruby
RSpec::Matchers.define :have_been_notified_of_order do |customer, cart|<br/>
¬†match do |analytics|<br/>
¬†¬†¬†cart.each do |item|<br/>
¬†¬†¬†¬†¬†return false unless analytics.items.include?(customer: customer, item: item)<br/>
¬†¬†¬†end<br/>
¬†¬†¬†true<br/>
¬†end<br/>
end</p>

<p>describe &lsquo;Order&rsquo; do<br/>
¬†it &ldquo;notifies analytics service about passed orders&rdquo; do<br/>
¬†¬†¬†cart = [&ldquo;Pasta&rdquo;,&ldquo;Tomatoes&rdquo;]<br/>
¬†¬†¬†analytics = AnalyticsService.new<br/>
¬†¬†¬†order = Order.new(&ldquo;Philippe&rdquo;, cart, analytics)</p>

<p>¬†¬†¬†order.pass</p>

<p>¬†¬†¬†expect(analytics).to have_been_notified_of_order(&ldquo;Philippe&rdquo;, cart)<br/>
¬†end<br/>
end
```</p>

<p>Here is how we could summarize the pros and cons of each approach :</p>

<table>
<thead>
<tr>
<th></th>
<th> Assert state          </th>
<th> Mocks                              </th>
<th> Matchers </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> üëé duplicated code    </td>
<td>üëé duplicates the program behavior</td>
<td>‚ù§Ô∏è customizable error messages|</td>
</tr>
<tr>
<td></td>
<td>üëé breaks encapsulation</td>
<td>                                   </td>
<td>‚ù§Ô∏è more readable|</td>
</tr>
<tr>
<td></td>
<td>                       </td>
<td>                                    </td>
<td>üëé intimacy with the asserted object|</td>
</tr>
<tr>
<td></td>
<td>                       </td>
<td>                                    </td>
<td>‚ù§Ô∏è factorizes the assertion code|</td>
</tr>
</tbody>
</table>


<h2>Design improvements</h2>

<p>Depending on your situation, you might find further design improvements. In our example, a publish-subscribe pattern might do. A better design is likely to fix the encapsulation problem of the matcher. Here again, the custom assertion matchers will help. In most cases, it will be enough to change the implementation of the matchers only.</p>

<blockquote><p>üí° Custom assertion matchers make refactoring easier by factorizing test assertions.</p></blockquote>

<h2>Summary of small-scale techniques</h2>

<p>I&rsquo;m done with small scale mock avoiding techniques. To summarize, the first thing to do is to push for more and more <a href="/how-immutable-value-objects-fight-mocks/">immutable value objects</a>. Not only does it help us to avoid mocks, but it will also provides many benefits for production code. Practices like <a href="/how-to-use-test-data-builders-to-avoid-mocks-and-keep-your-tests-clear/">Test Data Builders</a> and Custom Assertion Matchers simplify dealing with Immutable Value Objects in tests. They also help to keep tests small and clean, which is also a great thing against mocks.</p>

<h2>Next post</h2>

<p>In the following posts, I&rsquo;ll look into architecture scale techniques to avoid mocks. I&rsquo;ll start with Hexagonal architecture.</p>

<p><a href="https://feedburner.google.com/fb/a/mailverify?uri=PhilippeBourgau&amp;loc=en_US">Stay tuned</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to use Test Data Builders to avoid mocks and keep your tests clear]]></title>
    <link href="http://philippe.bourgau.net/how-to-use-test-data-builders-to-avoid-mocks-and-keep-your-tests-clear/"/>
    <updated>2018-05-10T09:56:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-use-test-data-builders-to-avoid-mocks-and-keep-your-tests-clear</id>
    <content type="html"><![CDATA[<p>We are sometimes tempted to use mocks to shortcut test data initialization. Unfortunately, excessive mocking makes tests difficult to maintain. As <a href="https://blog.cleancoder.com/uncle-bob/2017/05/05/TestDefinitions.html">Uncle Bob explained</a>, it&rsquo;s a road that leads to giving up on tests.</p>

<p>Hopefully, <a href="http://www.natpryce.com/articles/000714.html">Test Data Builders</a> both shortcut test data setup and avoid mocks.</p>

<p><img src="../imgs/2018-05-01-how-to-use-test-data-builders-to-avoid-mocks-and-keep-your-tests-clear/crate.jpg" alt="Drawing of a crate" /></p>

<p>This is the fourth post <a href="/blog/categories/how-to-avoid-mocks-series/">of a series about how to avoid mocks</a> in automated tests. If you haven&rsquo;t yet, I recommend you to start from <a href="/careless-mocking-considered-harmful/">the beginning</a>.</p>

<h2>The problem with test data initialization</h2>

<p>Setting up the correct state for automated tests can be pretty verbose. This is especially true for software in complex domains or code with a lot of side effects.</p>

<p>The situation gets worse as tests need to setup similar but not exactly identical data. What I often see in code bases is a lot of test data setup duplication. For example, here are tests for a basic ticketing system.</p>

<p>```ruby
require &lsquo;rspec&rsquo;
require &lsquo;date&rsquo;</p>

<p>describe &lsquo;Ticket Tracking&rsquo; do
  context &ldquo;with test setup duplication&rdquo; do</p>

<pre><code>it 'latest change date is the creation date when nothing changed' do
  creation_time = DateTime.new(2018,4,26,13,9,0)

  ticket = Ticket.new("Widget broken", "The widget is not loading when ...", "Philippe", creation_time)

  expect(ticket.latest_change).to be(creation_time)
end

it 'latest change date is the comment date when a comment is written' do
  ticket = Ticket.new("Widget broken", "The widget is not loading when ...", "Philippe", DateTime.new(2018, 4, 26, 13, 9, 0))
  comment_time = DateTime.new(2018, 4, 26, 13, 16, 0)

  ticket.add_comment(Comment.new("Should work now", "Dan", comment_time))

  expect(ticket.latest_change).to be(comment_time)
end

it 'latest change date is the comment date of the latest comment' do
  ticket = Ticket.new("Widget broken", "The widget is not loading when ...", "Philippe", DateTime.new(2018, 4, 26, 13, 9, 0))
  ticket.add_comment(Comment.new("Should work now", "Dan", DateTime.new(2018, 4, 26, 13, 16, 0)))
  comment_time = DateTime.new(2018, 4, 26, 18, 36, 0)

  ticket.add_comment(Comment.new("Should work now", "Dan", comment_time))

  expect(ticket.latest_change).to be(comment_time)
  end

it 'latest change date is time of latest change if after comment' do
  creation_time = DateTime.new(2018, 4, 26, 13, 9, 0)
  ticket = Ticket.new("Widget broken", "The widget is not loading when ...", "Philippe", creation_time)
  ticket.add_comment(Comment.new("Should work now", "Dan", DateTime.new(2017, 4, 26, 13, 16, 0)))

  expect(ticket.latest_change).to be(creation_time)
end
</code></pre>

<p>  end
end</p>

<h2>The code under test</h2>

<h1>#</h1>

<p>class Ticket</p>

<p>  def initialize(title, description, reporter, creation_time)</p>

<pre><code>@updated_at = creation_time
@comments = []
</code></pre>

<p>  end</p>

<p>  def latest_change</p>

<pre><code>([@updated_at] + @comments.map(&amp;:created_at)).max
</code></pre>

<p>  end</p>

<p>  def add_comment(comment)</p>

<pre><code>@comments.push(comment)
</code></pre>

<p>  end
end</p>

<p>class Comment
  attr_reader :created_at
  def initialize(message, author, time)</p>

<pre><code>@created_at = time
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>It&rsquo;s clear that there&rsquo;s a huge amount of duplication in the tests data setups.</p>

<p>The straightforward fix against that is method extraction. This is the <a href="https://martinfowler.com/bliki/ObjectMother.html">Object Mother pattern</a>.¬†Unfortunately, Object Mother breaks down under the number of variations. Every time you need a new change, you&rsquo;ll add a parameter to the Object Mother method. Long story short, you&rsquo;ll end up with code like that :</p>

<p>```ruby
describe &lsquo;Ticket Tracking&rsquo; do
  context &ldquo;with object mother&rdquo; do</p>

<pre><code>it 'latest change date is the creation date when nothing changed' do
  creation_time = DateTime.new(2018, 4, 26, 13, 5, 0)
  ticket = create_ticket(creation_time, [])

  expect(ticket.latest_change).to be(creation_time)
end

it 'latest change date is the comment date when a comment is written' do
  comment_time = DateTime.new(2018, 4, 26, 13, 16, 0)
  ticket = create_ticket(DateTime.new(2018, 4, 26, 13, 9, 0), [comment_time])

  expect(ticket.latest_change).to be(comment_time)
end

it 'latest change date is the comment date of the latest comment' do
  comment_time = DateTime.new(2018, 4, 26, 18, 36, 0)
  ticket = create_ticket(DateTime.new(2018, 4, 26, 13, 9, 0),
                         [DateTime.new(2018, 4, 26, 13, 16, 0), comment_time])

  expect(ticket.latest_change).to be(comment_time)
end

it 'latest change date is time of latest change if after comment' do
  creation_time = DateTime.new(2018, 4, 26, 13, 9, 0)
  ticket = create_ticket(creation_time,[DateTime.new(2017, 4, 26, 13, 16, 0)])

  expect(ticket.latest_change).to be(creation_time)
end

def create_ticket(creation_time, comment_times)
  ticket = Ticket.new("Widget broken", "The widget is not loading when ...", "Philippe", creation_time)
  comment_times.each do |comment_time|
    ticket.add_comment(Comment.new("Should work now", "Dan", comment_time))
  end
  return ticket
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>As you can see, we have less duplication, but the tests got both unreadable and intricate &hellip; Following <a href="/how-immutable-value-objects-fight-mocks/">my advices</a> and using more <a href="https://martinfowler.com/bliki/ValueObject.html">Immutable Value Objects</a> makes the situation worse ! When data is mutable, we can customize it after the call to the Object Mother method. If data is immutable, it all has to be setup at initialization &hellip;</p>

<p>That&rsquo;s when the mock temptation strikes. Sometimes it&rsquo;s so much easier to mock a method rather than to initialize your data properly. It can be 1 line of mock instead of dealing with all this mess.</p>

<blockquote><p>üí° If you are not careful, messy test initialization code will trick you into using mocks.</p></blockquote>

<p>Suppose we now want to make sure we can&rsquo;t add comments that were written before the ticket was created. We&rsquo;ll add the following</p>

<p>```ruby
describe &lsquo;Ticket Tracking&rsquo; do
  # &hellip;
  it &ldquo;is not possible to insert a comment before creation data&rdquo; do</p>

<pre><code>ticket = create_ticket(DateTime.new(2018, 4, 26, 13, 9, 0), [])
expect do
  ticket.add_comment(Comment.new("Should work now", "Dan", DateTime.new(2017, 4, 26, 13, 9, 0)))
end.to raise_error(ArgumentError)
</code></pre>

<p>  end
end</p>

<h1>&hellip;</h1>

<p>class Ticket
  # &hellip;
  def add_comment(comment)</p>

<pre><code>raise ArgumentError unless @updated_at &lt; comment.created_at

@comments.push(comment)
</code></pre>

<p>  end
  # &hellip;
end</p>

<p>```</p>

<p>Unfortunately, one test (<code>latest change date is time of latest change if after comment</code>) where we were doing just this, will now fail. The fix would be to find a real situation for this test. Here this could be that the ticket is modified after the latest comment. If the tests are too messy though, a mock can be a quick and dirty fix the setup and make the test pass :</p>

<p>```ruby
it &lsquo;latest change date is time of latest change if after comment&rsquo; do
  creation_time = DateTime.new(2018, 4, 26, 13, 9, 0)
  ticket = create_ticket(creation_time, [])
  comment = Comment.new(&ldquo;Should work now&rdquo;, &ldquo;Dan&rdquo;, DateTime.new(2018, 4, 26, 13, 16, 0))
  ticket.add_comment(comment)
  allow(comment).to receive(:created_at).and_return(DateTime.new(2017, 4, 26, 13, 16, 0))</p>

<p>  expect(ticket.latest_change).to be(creation_time)
end
```</p>

<p>There is a third way : Test Data Builders</p>

<h2>What are test data builders</h2>

<p>As often, when design is not satisfying, adding an indirection solves the issue. Here the indirection takes shape of the Builder pattern.</p>

<blockquote><p><em>Builder Pattern [</em><a href="https://en.wikipedia.org/wiki/Builder_pattern"><em>Wikipedia</em></a><em>] :</em></p>

<p>The intent of the Builder design pattern is to separate the construction of a complex object from its representation. By doing so the same construction process can create different representations.</p></blockquote>

<p>The idea is to use the builder pattern to build the test data. <a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;qid=1525160355&amp;sr=8-1&amp;keywords=growing+object-oriented+software+guided+by+tests">Growing Object Oriented Software Guided by Tests</a> covers this technique in great length.</p>

<p><a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;qid=1525160355&amp;sr=8-1&amp;keywords=growing+object-oriented+software+guided+by+tests"><img src="../imgs/2018-05-01-how-to-use-test-data-builders-to-avoid-mocks-and-keep-your-tests-clear/growing.jpg" alt="Cover of the book Growing Object Oriented Software Guided By Tests" /></a></p>

<p>Here is the previous code re-written using the test data builder pattern.</p>

<p>```ruby
require &lsquo;rspec&rsquo;
require &lsquo;date&rsquo;</p>

<p>describe &lsquo;Ticket Tracking&rsquo; do
  context &ldquo;with test data builders&rdquo; do</p>

<pre><code>before :each do
  @t = date_times.build
end

it 'latest change date is the creation date when nothing changed' do
  ticket = a_ticket.at(@t[0]).build

  expect(ticket.latest_change).to be(@t[0])
end

it 'latest change date is the comment date when a comment is written' do
  ticket = a_ticket
               .at(@t[0])
               .with_comment(a_comment.at(@t[1]))
               .build

  expect(ticket.latest_change).to be(@t[1])
end

it 'latest change date is the comment date of the latest comment' do
  ticket = a_ticket
               .at(@t[0])
               .with_comment(a_comment.at(@t[1]))
               .with_comment(a_comment.at(@t[2]))
               .build

  expect(ticket.latest_change).to be(@t[2])
end

it 'latest change date is time of latest change if after comment' do
  ticket = a_ticket.at(@t[0])
               .with_comment(a_comment.at(@t[1]))
               .build

  ticket.update_description("The widget is not loading when logged in as anonymous", @t[2])

  expect(ticket.latest_change).to be(@t[2])
end

it "is not possible to insert a comment before creation data" do
  ticket = a_ticket.at(@t[1]).build

  expect do
    ticket.add_comment(a_comment.at(@t[0]).build)
  end.to raise_error(ArgumentError)
end
</code></pre>

<p>  end
end</p>

<h2>Test Data Builders</h2>

<h1>#</h1>

<p>class DateTimeBuilder
  def build</p>

<pre><code>seed = DateTime.now
(0..10).map {|i| seed + i}
</code></pre>

<p>  end
end
def date_times()
  DateTimeBuilder.new
end</p>

<p>class CommentBuilder
  def initialize</p>

<pre><code>@at = DateTime.now
</code></pre>

<p>  end
  def at(time)</p>

<pre><code>@at = time
self
</code></pre>

<p>  end
  def build</p>

<pre><code>Comment.new("Should work now", "Dan", @at)
</code></pre>

<p>  end
end
def a_comment()
  CommentBuilder.new
end</p>

<p>class TicketBuilder
  def initialize</p>

<pre><code>@at = DateTime.now
@comments = []
</code></pre>

<p>  end
  def at(time)</p>

<pre><code>@at = time
self
</code></pre>

<p>  end
  def with_comment(comment_builder)</p>

<pre><code>@comments.push(comment_builder.build)
self
</code></pre>

<p>  end
  def build</p>

<pre><code>ticket = Ticket.new("Widget broken", "The widget is not loading when ...", "Philippe", @at)
@comments.each do |comment|
  ticket.add_comment(comment)
end
ticket
</code></pre>

<p>  end
end
def a_ticket()
  TicketBuilder.new
end</p>

<h2>The code under test</h2>

<h1>#</h1>

<p>class Ticket</p>

<p>  def initialize(title, description, reporter, creation_time)</p>

<pre><code>@updated_at = creation_time
@comments = []
</code></pre>

<p>  end</p>

<p>  def latest_change</p>

<pre><code>([@updated_at] + @comments.map(&amp;:created_at)).max
</code></pre>

<p>  end</p>

<p>  def add_comment(comment)</p>

<pre><code>raise ArgumentError unless @updated_at &lt; comment.created_at

@comments.push(comment)
</code></pre>

<p>  end</p>

<p>  def update_description(description, update_time)</p>

<pre><code>@updated_at = update_time
</code></pre>

<p>  end
end</p>

<p>class Comment
  attr_reader :created_at</p>

<p>  def initialize(message, author, time)</p>

<pre><code>@created_at = time
</code></pre>

<p>  end
end
```</p>

<p>As you can see, it provides default test values, and we only need to provide the custom values we care about. This makes the test code both readable and intention revealing. Making the tests more understandable helps a lot to find ways to avoid mocks. Here, we replaced the mock on the comment time by an update to the ticket after the last comment.</p>

<p>The pattern applies in many languages, even if implementations will be different. In Ruby, libraries like <a href="https://github.com/thoughtbot/factory_bot">factory_bot</a> avoid a lot of boilerplate code. Have a look at <a href="http://www.natpryce.com/articles/000769.html">this article</a> for examples in Java.</p>

<h2>Other advantages</h2>

<p>Test data builders have another second effect benefit. When setting up the data is complicated, we are likely to add more that one assertion in a test. Unit tests can end up looking like a mini scenario to avoid duplicating this test setup.</p>

<p>It&rsquo;s easy to create a specific tests for every assertion with Test Data Builders. By doing so we get smaller and more focused tests, which bring :</p>

<ul>
<li>Better names for tests</li>
<li>More readable tests</li>
<li>Faster diagnostic of the problem when a particular test fails</li>
<li>üéÅ Better coverage ! In a large test, all assertions work on the same input values. When we have many small tests, we can use a different value in each.</li>
</ul>


<blockquote><p>üí° By simplifying the creation of new tests with different data, Test Data Builders increase code coverage in the long term!</p></blockquote>

<h2>Next week</h2>

<p>This is the fourth post of <a href="/blog/categories/how-to-avoid-mocks-series/">a series about how to avoid mocks</a> in automated tests. Next week I&rsquo;ll dig into Custom Assertion Matchers and how they avoid mock expectations.</p>

<p><a href="https://feedburner.google.com/fb/a/mailverify?uri=PhilippeBourgau&amp;loc=en_US">Stay tuned !</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Immutable Value Objects vs Mocks : Fizz Buzz]]></title>
    <link href="http://philippe.bourgau.net/immutable-value-objects-vs-mocks-fizz-buzz/"/>
    <updated>2018-05-03T19:28:00+02:00</updated>
    <id>http://philippe.bourgau.net/immutable-value-objects-vs-mocks-fizz-buzz</id>
    <content type="html"><![CDATA[<p>In my <a href="/how-immutable-value-objects-fight-mocks/">previous post</a> I explained how <a href="https://martinfowler.com/bliki/ValueObject.html">Immutable Value Objects</a> help us to avoid mocks. In this post, I&rsquo;ll illustrate this in practice with real code.</p>

<p>This is the third post on a <a href="/blog/categories/how-to-avoid-mocks-series/">series about how to avoid mocks</a>. If you haven&rsquo;t, you can start reading the full story <a href="/careless-mocking-considered-harmful/">here</a>.</p>

<p><img src="../imgs/2018-04-17-immutable-value-objects-vs-mocks-fizz-buzz/immutable-fizz-buzz.jpg" alt="A drawing &quot;FIZZ BUZZ&quot; rock fallen and sealed in the ground" /></p>

<h2>Fizz Buzz Example</h2>

<p>As a simple example, I&rsquo;ll go through the classic <a href="http://codingdojo.org/kata/FizzBuzz/">Fizz Buzz</a>. I&rsquo;ve implemented and tested it with and without immutable value objects. Please keep in mind that this is a toy example, where problems are obvious and easily fixed. I try to highlight at small scale the same problems that get hidden by the complexity of a large scale program.</p>

<p>Let&rsquo;s start with a typical FizzBuzz implementation.</p>

<p>```ruby
1.upto(100) do |i|
  if (i%3 == 0 and i%5 == 0)</p>

<pre><code>STDOUT.puts("FizzBuzz\n")
</code></pre>

<p>  elsif (i%3 == 0)</p>

<pre><code>STDOUT.puts("Fizz\n")
</code></pre>

<p>  elsif (i%5 == 0)</p>

<pre><code>STDOUT.puts("Buzz\n")
</code></pre>

<p>  else</p>

<pre><code>STDOUT.puts("#{i}\n")
</code></pre>

<p>  end
end
```</p>

<p>Suppose you need to add some tests around the code. The most straightforward way is to mock <code>STDOUT</code> :</p>

<p>```ruby
require &lsquo;rspec&rsquo;</p>

<p>def fizzBuzz(max, out)
  1.upto(max) do |i|</p>

<pre><code>if (i%3 == 0 and i%5 == 0)
  out.puts("FizzBuzz\n")
elsif (i%3 == 0)
  out.puts("Fizz\n")
elsif (i%5 == 0)
  out.puts("Buzz\n")
else
  out.puts("#{i}\n")
end
</code></pre>

<p>  end
end</p>

<h1>main</h1>

<p>fizzBuzz(100,STDOUT)</p>

<p>describe &lsquo;Mockist Fizz Buzz&rsquo; do</p>

<p>  it &lsquo;should print numbers, fizz and buzz&rsquo; do</p>

<pre><code>out = double("out")
expect(out).to receive(:puts).with("1\n").ordered
expect(out).to receive(:puts).with("2\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("4\n").ordered
expect(out).to receive(:puts).with("Buzz\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("7\n").ordered
expect(out).to receive(:puts).with("8\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("Buzz\n").ordered
expect(out).to receive(:puts).with("11\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("13\n").ordered
expect(out).to receive(:puts).with("14\n").ordered
expect(out).to receive(:puts).with("FizzBuzz\n").ordered

fizzBuzz(15, out)
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Unfortunately, there are a few problems with this code :</p>

<ul>
<li>With nested logic and complicated mock setup, both code and tests aren&rsquo;t very readable</li>
<li>They both seem to violate the single responsibility principle as well</li>
<li>It&rsquo;s depending on a mutable output. Within a larger program, something could be messing around with this output stream. That would break FizzBuzz.</li>
</ul>


<p>Let&rsquo;s now try to use as many immutable values objects as possible, and see what happens to the mocks.</p>

<p>```ruby
require &lsquo;rspec&rsquo;</p>

<h1>We extracted a function to do the fizz buzz on a single number</h1>

<p>def fizzBuzzN(i)
  if (i%3 == 0 and i%5 == 0)</p>

<pre><code>"FizzBuzz"
</code></pre>

<p>  elsif (i%3 == 0)</p>

<pre><code>"Fizz"
</code></pre>

<p>  elsif (i%5 == 0)</p>

<pre><code>"Buzz"
</code></pre>

<p>  else</p>

<pre><code>i.to_s
</code></pre>

<p>  end
end</p>

<h1>We replaced the many calls to STDOUT.puts by building a single</h1>

<h1>large (and immutable) string</h1>

<p>def fizzBuzz(max)
  ((1..max).map {|i| fizzBuzzN(i)}).join(&ldquo;\n&rdquo;)
end</p>

<h1>main, with a single call to STDOUT.puts</h1>

<p>STDOUT.puts fizzBuzz(100)</p>

<p>describe &lsquo;Statist Fizz Buzz&rsquo; do</p>

<p>  it &lsquo;should print numbers not multiples of 3 or 5&rsquo; do</p>

<pre><code>expect(fizzBuzzN(1)).to eq("1")
expect(fizzBuzzN(2)).to eq("2")
expect(fizzBuzzN(4)).to eq("4")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print Fizz for multiples of 3&rsquo; do</p>

<pre><code>expect(fizzBuzzN(3)).to eq("Fizz")
expect(fizzBuzzN(6)).to eq("Fizz")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print Buzz for multiples of 5&rsquo; do</p>

<pre><code>expect(fizzBuzzN(5)).to eq("Buzz")
expect(fizzBuzzN(10)).to eq("Buzz")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print FizzBuzz for multiples of 3 and 5&rsquo; do</p>

<pre><code>expect(fizzBuzzN(15)).to eq("FizzBuzz")
expect(fizzBuzzN(30)).to eq("FizzBuzz")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print numbers, fizz and buzz&rsquo; do</p>

<pre><code>expect(fizzBuzz(15)).to start_with("1\n2\nFizz").and(end_with("14\nFizzBuzz"))
</code></pre>

<p>  end
end
```</p>

<p>As we can see, using immutable value objects got us rid of the mocks. Obviously, this new code will not be as efficient as the original version, but most of the time, this does not matter. As a bonus though we get finer grain and more readable tests.</p>

<h3>Other testing advantages</h3>

<p>Appart from preventing mocks, Immutable Value Objects have other advantages related to testing.</p>

<ul>
<li>We can directly assert their equality, without having to dig into their guts</li>
<li>We can call methods as many times as we want, without the risk of changing anything and breaking the tests</li>
<li>Immutable Value Objects are a lot less likely to contain invalid state. This removes the need for a whole range of validity tests.</li>
</ul>


<blockquote><p>üí° Immutable Value Objects simplify testing in many ways.</p></blockquote>

<h3>Convincing your teammates</h3>

<p>We&rsquo;ve seen that Immutable Value Objects have a ton of advantages when testing. People have found that they also have many other benefits :</p>

<ul>
<li><a href="https://www.linkedin.com/pulse/20140528113353-16837833-6-benefits-of-programming-with-immutable-objects-in-java/">6 Benefits of Programming with Immutable Objects in Java</a></li>
<li><a href="https://hackernoon.com/5-benefits-of-immutable-objects-worth-considering-for-your-next-project-f98e7e85b6ac">5 Benefits of Immutable Objects Worth Considering for Your Next¬†Project</a></li>
</ul>


<p>Surprisingly though, it&rsquo;s difficult to persuade programmers to use more immutability. It&rsquo;s tricky to explain why returning a modified copy is simpler than just adding a setter.</p>

<blockquote><p>üí° Why is it so hard to persuade other developers to use immutable data structures ?</p></blockquote>

<p>I had the most success by far when encountering a bug resulting of share mutable state. When this happens, the long term benefits and safety of the immutable design wins people over. The good thing is that as you convince more people in the team, immutability will spread like a virus !</p>

<p>Outside of this situation, you might try some of the following arguments to move people :</p>

<ul>
<li>Immutable values prevent bugs caused by different parts of the system changing the same mutable state</li>
<li>They make it easier to deal with the program in smaller parts and to reason about the system in general</li>
<li>Immutable values don&rsquo;t need any synchronization and make multithreaded programming easier</li>
<li>When tempted to add a simple setter instead of keeping a class immutable, highlight the stressful debugging time to come</li>
<li>If you&rsquo;re dealing with a Design By Contract adept, explain how <a href="/almost-15-years-of-using-design-by-contract/">immutability has it built-in</a></li>
<li>Admit that mainstream languages have bad support for Immutable Value. Point to patterns like <a href="https://dzone.com/articles/immutability-with-builder-design-pattern">Data Builders</a> that work around these limitation</li>
</ul>


<h2>Next post</h2>

<p>I&rsquo;m done with immutable value objects. It was a far longer post than I thought, but there was a lot to say. This was the third post in a <a href="/blog/categories/how-to-avoid-mocks-series/">series about avoiding mocks</a>. In <a href="/how-to-use-test-data-builders-to-avoid-mocks-and-keep-your-tests-clear/">next post</a>, I&rsquo;ll dig into another small scale mock fighting pattern : <a href="http://www.natpryce.com/articles/000714.html">Test Data Builders</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 minutes hack to speed up RSpec in Rails 5 using in-memory SQLite]]></title>
    <link href="http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite/"/>
    <updated>2017-01-25T07:53:00+01:00</updated>
    <id>http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite</id>
    <content type="html"><![CDATA[<p>Here is the story : you have a <a href="http://rubyonrails.org/">Rails 5</a> app that uses <a href="http://rspec.info/">RSpec</a>, but your RSpec suite is getting slower and slower to run. You&rsquo;ve already considered some solutions :</p>

<ul>
<li>Use <a href="https://sqlite.org/">SQLite</a> in memory for your test env.</li>
</ul>


<p><code>yaml
test:
  adapter: sqlite3
  database: ":memory:"
</code></p>

<p>That&rsquo;s the most straightforward thing to do, but unfortunately, if you are sharing your test env with <a href="https://cucumber.io/">Cucumber</a>, you might want to use a production like DB with Cucumber (<a href="https://www.postgresql.org/">PostgreSQL</a> or whatever). So unless you are ready to setup a new env for cucumber (which I tried and don&rsquo;t recommend) you&rsquo;re stuck.</p>

<ul>
<li>Use mocks. That&rsquo;s surely going to work, it&rsquo;s going to make your test hell of a lot faster ! It will also make your tests a lot more fragile and more expensive to maintain &hellip; If you want to read more about why I think mocks are a bad idea, just have a look at <a href="/blog/categories/mocking/">these posts</a>.</li>
</ul>


<h2>The hack</h2>

<p>Here is a third alternative, I&rsquo;ve <a href="/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db/">already written about it</a>, but here it comes updated and tested for Rails 5 :</p>

<ol>
<li>Don&rsquo;t change anything to your <code>config/database.yml</code></li>
<li>Obviously, you&rsquo;ll need to add <code>sqlite3</code> to your <code>Gemfile</code></li>
<li>At the beginning of your <code>spec/rails_helper.rb</code>, replace</li>
</ol>


<p>``` ruby</p>

<h1>Checks for pending migration and applies them before tests are run.</h1>

<h1>If you are not using ActiveRecord, you can remove this line.</h1>

<p>ActiveRecord::Migration.maintain_test_schema!
```</p>

<p>with</p>

<p>``` ruby</p>

<h1>In order to keep the same RAILS_ENV for rspec and cucumber, and to make rspec</h1>

<h1>faster, patch the connection to use sqlite in memory when running rspec</h1>

<p>ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)
ActiveRecord::Schema.verbose = false
load &ldquo;#{Rails.root.to_s}/db/schema.rb&rdquo;
```</p>

<p>That&rsquo;s it ! Run your specs &hellip; not bad for a 5 minutes investment !</p>

<h4>Rails 5.1 (2017-03-29 Edit)</h4>

<p>My fresh hack started to fail on Rails 5.1 ! If <code>schema.rb</code> is generated with the Postgres adapter, it is now incompatible with this injected Sqlite adapter. Here is a patch that removes the glitches :</p>

<p>```ruby</p>

<h1>In order to keep the same RAILS_ENV for rspec and cucumber, and to make rspec</h1>

<h1>faster, patch the connection to use sqlite in memory when running rspec</h1>

<p>ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)
ActiveRecord::Schema.verbose = false</p>

<h1>load db agnostic schema by default. Needed to remove the &ldquo;, id: :serial&rdquo; from</h1>

<h1>the table definitions to make it load on sqlite</h1>

<p>eval(<code>cat #{Rails.root.to_s}/db/schema.rb | sed 's/,[^:]*: :serial\//g'</code>)
```</p>

<p>I admit this is getting a bit crappy, and I don&rsquo;t know how long it is going to work &hellip;</p>

<h2>One more thing &hellip;</h2>

<p>If you need even more speed, you can now run your specs in parallel in different processes ! Each in-memory SQLite DB is bound to its process, so unlike a real PostgreSQL dev DB, you won&rsquo;t get any conflicts between your tests ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Verify the Big O Complexity of Ruby Code in RSpec]]></title>
    <link href="http://philippe.bourgau.net/verify-the-big-o-complexity-of-ruby-code-in-rspec/"/>
    <updated>2017-01-04T17:48:00+01:00</updated>
    <id>http://philippe.bourgau.net/verify-the-big-o-complexity-of-ruby-code-in-rspec</id>
    <content type="html"><![CDATA[<p>It might be possible to discover performance regressions before running your long and large scale benchmarks !</p>

<p><a href="https://github.com/philou/complexity-assert">complexity_assert</a> is an <a href="http://rspec.info/">RSpec</a> library that determines and checks the <a href="http://bigocheatsheet.com/">big O complexity</a> of a piece of code. Once you&rsquo;ve determined the performance critical sections of your system, you can use it to verify that they perform with the complexity you expect.</p>

<h2>How does it work ?</h2>

<p>The gem itself is the result of an experiment to learn machine learning in 20 hours (you can read more about that experiment in <a href="/how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours/">my previous post</a> if you want).</p>

<p>Suppose you have some a method, let&rsquo;s call it <code>match_products_with_orders(products, orders)</code> which is called in in one of your processes with very large arguments. Badly written, this method could be quadratic (O(n¬≤)), which would lead to catastrophic performances in production. When coding it, you&rsquo;ve taken particular care to make it perform in linear time. Unfortunately, it could easily slip back to a slower implementation with a bad refactoring &hellip; Using complexity_assert, you can make sure that this does not happen :</p>

<p>``` ruby</p>

<h1>An adapter class to fit the code to measure in complexity assert</h1>

<p>class ProductsOrdersMatching</p>

<pre><code># Generate some arguments of a particular size
def generate_args(size)
    # Let's assume we have 10 times less products than orders
    [ Array.new(size / 10) { build_a_product() }, Array.new(size) { build_an_order() } ]
end

# Run the code on which we want to assert performance
def run(products, orders)
    match_products_with_orders(products, orders)
end
</code></pre>

<p>end</p>

<p>describe &ldquo;Products and Orders Matching&rdquo; do</p>

<pre><code>it "performs linearly" do
    # Verify that the code runs in time proportional to the size of its arguments
    expect(ProductOrdersMatching.new).to be_linear()
end
</code></pre>

<p>end
```</p>

<p>That&rsquo;s it ! If ever someone changes the code of <code>match_products_with_orders</code> and makes it perform worse than linearly, the assertion will fail ! There are similar assertions to check for constant and quadratic execution times.</p>

<p>Internally, the code will be called a number of times with different (smallish) sizes of arguments and the execution times will be logged. When this is over, by doing different flavors of linear regressions, it should determine whether the algorithm performs in O(1), O(n) or O(n¬≤). Depending on your code, this can take time to run, but should still be faster than running large scale benchmarks.</p>

<p>Just check the <a href="https://github.com/philou/complexity-assert/blob/master/README.md">README</a> for more details.</p>

<h2>Did you say experiment ?</h2>

<p>It all started like an experiment. So the gem itself, is still experimental ! It&rsquo;s all fresh, and it could receive a lot of enhancements like :</p>

<ul>
<li>Allow the assertion to specify the sizes</li>
<li>Allow the assertion to specify the warm-up and run rounds</li>
<li>Robustness against garbage collection : use GC intensive ruby methods, and see how the regression behaves</li>
<li>Find ways to make the whole thing faster</li>
<li>O(lnx) : pre-treat with exp()</li>
<li>O(?lnx) : use exp, then a search for the coefficient (aka polynomial)</li>
<li>O(xlnx) : there is no well known inverse for that, we can compute it numerically though</li>
<li>Estimate how much the assert is deterministic</li>
<li>&hellip;</li>
</ul>


<p>As you see, there&rsquo;s a lot of room for ideas and improvements.</p>
]]></content>
  </entry>
  
</feed>
