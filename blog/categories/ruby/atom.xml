<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2014-05-18T21:49:46+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Better error messages when testing html views]]></title>
    <link href="http://philippe.bourgau.net/better-error-messages-when-testing-html-views/"/>
    <updated>2014-05-18T21:14:00+02:00</updated>
    <id>http://philippe.bourgau.net/better-error-messages-when-testing-html-views</id>
    <content type="html"><![CDATA[<p>When testing html views, either from <a href="http://rspec.info/">RSpec</a> or from <a href="http://rspec.info/">Cucumber</a>, <a href="http://fr.wikipedia.org/wiki/XPath">XPath</a> can be really helpful to quickly find expected elements.</p>

<p>Unfortunately, a bit like regular expressions, when you start to use xpath to solve a problem, you often end up with 2 problems &hellip; Part of the reason is that xpaths tend to be cryptic. In the case of testing, error messages coming from unmatched xpath are even more crytic !</p>

<p>That&rsquo;s why I had the idea for <a href="https://github.com/philou/xpath-specs">xpath-specs</a> : a small gem that allows to associate a description with an xpath, to nest xpaths together, all this to simplify tests and assertion failure reporting.</p>

<p>For example, with an assertion like this :</p>

<p><code>ruby
expect(html).to contain_a(dish_with_name("Grilled Lobster")
</code></p>

<p>Here is the kind of failure message one can get :</p>

<p>```
expected the page to contain a dish that is named Grilled Lobster (//table[@id=&lsquo;dish-panel&rsquo;]//tr[td[contains(.,&lsquo;#{name}&rsquo;)]])</p>

<pre><code>   it found a dish (//table[@id='dish-panel']//tr) :
      &lt;tr&gt;&lt;td&gt;Pizza&lt;/td&gt;...&lt;/tr&gt;
   but not a dish that is named Grilled Lobster (//table[@id='dish-panel']//tr[td[contains(.,'#{name}')]])
</code></pre>

<p>```</p>

<p>And here is the required setup :</p>

<p>```ruby</p>

<h1>spec/support/knows_page_parts.rb</h1>

<p>module KnowsPageParts
  def dish</p>

<pre><code>Xpath::Specs::PagePart.new("a dish", "//table[@id='dish-panel']//tr")
</code></pre>

<p>  end</p>

<p>  def dish_with_name(name)</p>

<pre><code>dish.that("is named #{name}", "[td[contains(.,'#{name}')]]")
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Have a look at the <a href="https://github.com/philou/xpath-specs">readme</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auchandirect-ScrAPI : an unofficial API Ruby Gem]]></title>
    <link href="http://philippe.bourgau.net/auchandirect-scrapi-an-unofficial-api-ruby-gem/"/>
    <updated>2014-03-21T06:31:00+01:00</updated>
    <id>http://philippe.bourgau.net/auchandirect-scrapi-an-unofficial-api-ruby-gem</id>
    <content type="html"><![CDATA[<p><a href="http://mashable.com/2011/01/04/brand-open-api-developers/">Every brands should provide an API for developpers</a> &hellip; unfortunately, it far from the truth right now. A few years ago, when I started my mes-courses.fr side project, I would have loved to find a french online grocery providing an open API. I had to resort to scrapping <em>(that&rsquo;s how I learnt that heavily relying on scrapping for a 15hr/week side project is not a good fit &hellip; but that&rsquo;s another story)</em>.</p>

<p>As I am taking mes-courses.fr down, I have extracted the whole unofficial API I had built around <a href="http://www.auchandirect.fr">http://www.auchandirect.fr</a> (I&rsquo;m talking to you french hackers !) into an open source Ruby Gem. Briefly :</p>

<ul>
<li>It walks the whole store, from categories to items</li>
<li>Given valid credentials, it can fill and save a cart</li>
<li>It&rsquo;s <a href="http://choosealicense.com/licenses/lgpl-v3/">LGPL</a> : anyone can use it as long as they give back any improvement to the community</li>
<li>It&rsquo;s using <a href="https://github.com/philou/storexplore">Storexplore</a>, another of my mes-courses.fr rip-off open source Ruby Gem</li>
<li>It&rsquo;s tested on <a href="https://travis-ci.org/philou/auchandirect-scrAPI">Travis</a> and I&rsquo;m currently trying to make it daily tested with <a href="http://traviscron.pythonanywhere.com/">Traviscron</a></li>
</ul>


<p>There&rsquo;s mainly one thing it <em>cannot</em> do :</p>

<ul>
<li>It cannot procede to any payment or ordering</li>
</ul>


<p>It&rsquo;s available on <a href="https://github.com/philou/auchandirect-scrAPI">Github</a></p>

<p>Happy scrapping !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Online store scrapping DSL gem]]></title>
    <link href="http://philippe.bourgau.net/online-store-scrapping-dsl-gem/"/>
    <updated>2014-01-21T06:50:00+01:00</updated>
    <id>http://philippe.bourgau.net/online-store-scrapping-dsl-gem</id>
    <content type="html"><![CDATA[<p>Since I decided to stop <a href="http://www.mes-courses.com">Mes Courses</a> to focus on <a href="http://www.agileavatars.com">AgileAvatars</a>, I have been extracting open source gems from the code base. The last one is <a href="https://github.com/philou/storexplore">Storexplore</a> : a declarative scrapping DSL that lets one define directory like apis to an online store.</p>

<p>As explained in the Readme, it allows one to declare a store this way :</p>

<p>```ruby
Storexplore::define_api &lsquo;dummy-store.com&rsquo; do</p>

<p>  categories &lsquo;a.category&rsquo; do</p>

<pre><code>attributes do
  { :name =&gt; page.get_one("h1").content }
end

categories 'a.category' do
  attributes do
    { :name =&gt; page.get_one("h1").content }
  end

  items 'a.item' do
    attributes do
      {
        :name =&gt; page.get_one('h1').content,
        :brand =&gt; page.get_one('#brand').content,
        :price =&gt; page.get_one('#price').content.to_f,
        :image =&gt; page.get_one('#image').content,
        :remote_id =&gt; page.get_one('#remote_id').content
      }
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>And to use it like that :</p>

<p>```ruby
Api.browse(&lsquo;<a href="http://www.dummy-store.com">http://www.dummy-store.com</a>&rsquo;).categories.each do |category|</p>

<p>  puts &ldquo;category: #{category.title}&rdquo;
  puts &ldquo;attributes: #{category.attributes}&rdquo;</p>

<p>  category.categories.each do |sub_category|</p>

<pre><code>puts "  category: #{sub_category.title}"
puts "  attributes: #{sub_category.attributes}"

sub_category.items.each do |item|

  puts "    item: #{item.title}"
  puts "    attributes: #{item.attributes}"

end
</code></pre>

<p>  end
end
```</p>

<p>I tried my best to make this library high quality :</p>

<ul>
<li>The code evolved from a simple procedural script to a dsl through constant refactorings</li>
<li>Real world features like constant memory usage have been added to fix production bugs</li>
<li>Documented with samples and rdoc</li>
<li>Extensive automated testing</li>
</ul>


<p>Let&rsquo;s hope it will be usefull for some.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Matchers Combinators 2 : spec_combos gem]]></title>
    <link href="http://philippe.bourgau.net/rspec-matchers-combinators-2-spec-combos-gem/"/>
    <updated>2013-09-25T21:29:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-matchers-combinators-2-spec-combos-gem</id>
    <content type="html"><![CDATA[<p>I already wrote about my <a href="/rspec-matchers-combinators/">RSpec Matchers Combinators</a>, I decided to extract them into the <a href="https://github.com/philou/spec_combos">spec_combos</a> gem.</p>

<p>To use it, just add the following to your Gemfile :</p>

<p><code>ruby
gem 'spec_combos', :group =&gt; 'test'
</code></p>

<p>Compared to the first version of the matchers, I added better error messages. For example, consider the following complex nested assertion :</p>

<p><code>ruby
expect([1,2,3]).to all_{and_(be_odd, be_instance_of(Fixnum))}
</code></p>

<p>It outputs the following error :</p>

<p>```text
Failure/Error: expect([1,2,3]).to all<em>{and</em>(be_odd, be_instance_of(Fixnum))}
  expected [1, 2, 3] to all be odd and be an instance of Fixnum, but the following were not:</p>

<pre><code>[1] (2): expected 2 to be odd and be an instance of Fixnum, but:
  expected odd? to return true, got false
</code></pre>

<p>```</p>

<p>I hope this might help !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec matchers combinators]]></title>
    <link href="http://philippe.bourgau.net/rspec-matchers-combinators/"/>
    <updated>2013-09-11T12:23:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-matchers-combinators</id>
    <content type="html"><![CDATA[<p><a href="http://rubydoc.info/gems/rspec-expectations">Rspec matchers</a> are a lot like predicates. Predicates that can talk &hellip; The good thing about predicates, as anybody who has done a bit of functional programming will tell you, is that they are easy to combine together into bigger predicates. I was really suprised to see that rspec does not come with such simple combinators as &lsquo;and&rsquo; or &lsquo;or&rsquo;.</p>

<p>Here is a gist where I define simple combinators :</p>

<script src="https://gist.github.com/philou/6521797.js"></script>


<p>With this and the <a href="https://github.com/bmabey/email-spec">email_spec</a> matchers, it is possible to write something like this to find if an email was sent by rails :</p>

<p>```ruby
expect(all_emails).to have_any_that(and_(deliver_to(receiver),</p>

<pre><code>                                     have_subject(subject),
                                     have_body_text(body)))
</code></pre>

<p>```</p>

<p>It enables expressive test code and high reusability.</p>

<p>Using the &lsquo;all&rsquo; combinator it is possible to write things like that :</p>

<p><code>ruby
expect(sample_items_attributes).to all_ have_key(:price)
</code></p>

<p>I had to prepend &lsquo;all&rsquo; and &lsquo;and&rsquo; with an underscore because I would otherwise get conflicts&hellip; I&rsquo;m not overly satisfied with this, but it will do for the moment.</p>

<p>I was happily supprised by the readability of error messages when the mach fails. Rspec does a very good job about this. I think it would be possible to get even better error messages by explicity using the sub matchers messages though. If anyone is interested, help yourself !</p>
]]></content>
  </entry>
  
</feed>
