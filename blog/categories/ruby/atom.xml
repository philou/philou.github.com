<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2014-03-26T06:41:16+01:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Auchandirect-ScrAPI : an unofficial API Ruby Gem]]></title>
    <link href="http://philippe.bourgau.net/auchandirect-scrapi-an-unofficial-api-ruby-gem/"/>
    <updated>2014-03-21T06:31:00+01:00</updated>
    <id>http://philippe.bourgau.net/auchandirect-scrapi-an-unofficial-api-ruby-gem</id>
    <content type="html"><![CDATA[<p><a href="http://mashable.com/2011/01/04/brand-open-api-developers/">Every brands should provide an API for developpers</a> &hellip; unfortunately, it far from the truth right now. A few years ago, when I started my mes-courses.fr side project, I would have loved to find a french online grocery providing an open API. I had to resort to scrapping <em>(that&rsquo;s how I learnt that heavily relying on scrapping for a 15hr/week side project is not a good fit &hellip; but that&rsquo;s another story)</em>.</p>

<p>As I am taking mes-courses.fr down, I have extracted the whole unofficial API I had built around <a href="http://www.auchandirect.fr">http://www.auchandirect.fr</a> (I&rsquo;m talking to you french hackers !) into an open source Ruby Gem. Briefly :</p>

<ul>
<li>It walks the whole store, from categories to items</li>
<li>Given valid credentials, it can fill and save a cart</li>
<li>It&rsquo;s <a href="http://choosealicense.com/licenses/lgpl-v3/">LGPL</a> : anyone can use it as long as they give back any improvement to the community</li>
<li>It&rsquo;s using <a href="https://github.com/philou/storexplore">Storexplore</a>, another of my mes-courses.fr rip-off open source Ruby Gem</li>
<li>It&rsquo;s tested on <a href="https://travis-ci.org/philou/auchandirect-scrAPI">Travis</a> and I&rsquo;m currently trying to make it daily tested with <a href="http://traviscron.pythonanywhere.com/">Traviscron</a></li>
</ul>


<p>There&rsquo;s mainly one thing it <em>cannot</em> do :</p>

<ul>
<li>It cannot procede to any payment or ordering</li>
</ul>


<p>It&rsquo;s available on <a href="https://github.com/philou/auchandirect-scrAPI">Github</a></p>

<p>Happy scrapping !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Online store scrapping DSL gem]]></title>
    <link href="http://philippe.bourgau.net/online-store-scrapping-dsl-gem/"/>
    <updated>2014-01-21T06:50:00+01:00</updated>
    <id>http://philippe.bourgau.net/online-store-scrapping-dsl-gem</id>
    <content type="html"><![CDATA[<p>Since I decided to stop <a href="http://www.mes-courses.com">Mes Courses</a> to focus on <a href="http://www.agileavatars.com">AgileAvatars</a>, I have been extracting open source gems from the code base. The last one is <a href="https://github.com/philou/storexplore">Storexplore</a> : a declarative scrapping DSL that lets one define directory like apis to an online store.</p>

<p>As explained in the Readme, it allows one to declare a store this way :</p>

<p>```ruby
Storexplore::define_api &lsquo;dummy-store.com&rsquo; do</p>

<p>  categories &lsquo;a.category&rsquo; do</p>

<pre><code>attributes do
  { :name =&gt; page.get_one("h1").content }
end

categories 'a.category' do
  attributes do
    { :name =&gt; page.get_one("h1").content }
  end

  items 'a.item' do
    attributes do
      {
        :name =&gt; page.get_one('h1').content,
        :brand =&gt; page.get_one('#brand').content,
        :price =&gt; page.get_one('#price').content.to_f,
        :image =&gt; page.get_one('#image').content,
        :remote_id =&gt; page.get_one('#remote_id').content
      }
    end
  end
end
</code></pre>

<p>  end
end
```</p>

<p>And to use it like that :</p>

<p>```ruby
Api.browse(&lsquo;<a href="http://www.dummy-store.com">http://www.dummy-store.com</a>&rsquo;).categories.each do |category|</p>

<p>  puts &ldquo;category: #{category.title}&rdquo;
  puts &ldquo;attributes: #{category.attributes}&rdquo;</p>

<p>  category.categories.each do |sub_category|</p>

<pre><code>puts "  category: #{sub_category.title}"
puts "  attributes: #{sub_category.attributes}"

sub_category.items.each do |item|

  puts "    item: #{item.title}"
  puts "    attributes: #{item.attributes}"

end
</code></pre>

<p>  end
end
```</p>

<p>I tried my best to make this library high quality :</p>

<ul>
<li>The code evolved from a simple procedural script to a dsl through constant refactorings</li>
<li>Real world features like constant memory usage have been added to fix production bugs</li>
<li>Documented with samples and rdoc</li>
<li>Extensive automated testing</li>
</ul>


<p>Let&rsquo;s hope it will be usefull for some.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Matchers Combinators 2 : spec_combos gem]]></title>
    <link href="http://philippe.bourgau.net/rspec-matchers-combinators-2-spec-combos-gem/"/>
    <updated>2013-09-25T21:29:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-matchers-combinators-2-spec-combos-gem</id>
    <content type="html"><![CDATA[<p>I already wrote about my <a href="/rspec-matchers-combinators/">RSpec Matchers Combinators</a>, I decided to extract them into the <a href="https://github.com/philou/spec_combos">spec_combos</a> gem.</p>

<p>To use it, just add the following to your Gemfile :</p>

<p><code>ruby
gem 'spec_combos', :group =&gt; 'test'
</code></p>

<p>Compared to the first version of the matchers, I added better error messages. For example, consider the following complex nested assertion :</p>

<p><code>ruby
expect([1,2,3]).to all_{and_(be_odd, be_instance_of(Fixnum))}
</code></p>

<p>It outputs the following error :</p>

<p>```text
Failure/Error: expect([1,2,3]).to all<em>{and</em>(be_odd, be_instance_of(Fixnum))}
  expected [1, 2, 3] to all be odd and be an instance of Fixnum, but the following were not:</p>

<pre><code>[1] (2): expected 2 to be odd and be an instance of Fixnum, but:
  expected odd? to return true, got false
</code></pre>

<p>```</p>

<p>I hope this might help !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec matchers combinators]]></title>
    <link href="http://philippe.bourgau.net/rspec-matchers-combinators/"/>
    <updated>2013-09-11T12:23:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-matchers-combinators</id>
    <content type="html"><![CDATA[<p><a href="http://rubydoc.info/gems/rspec-expectations">Rspec matchers</a> are a lot like predicates. Predicates that can talk &hellip; The good thing about predicates, as anybody who has done a bit of functional programming will tell you, is that they are easy to combine together into bigger predicates. I was really suprised to see that rspec does not come with such simple combinators as &lsquo;and&rsquo; or &lsquo;or&rsquo;.</p>

<p>Here is a gist where I define simple combinators :</p>

<script src="https://gist.github.com/philou/6521797.js"></script>


<p>With this and the <a href="https://github.com/bmabey/email-spec">email_spec</a> matchers, it is possible to write something like this to find if an email was sent by rails :</p>

<p>```ruby
expect(all_emails).to have_any_that(and_(deliver_to(receiver),</p>

<pre><code>                                     have_subject(subject),
                                     have_body_text(body)))
</code></pre>

<p>```</p>

<p>It enables expressive test code and high reusability.</p>

<p>Using the &lsquo;all&rsquo; combinator it is possible to write things like that :</p>

<p><code>ruby
expect(sample_items_attributes).to all_ have_key(:price)
</code></p>

<p>I had to prepend &lsquo;all&rsquo; and &lsquo;and&rsquo; with an underscore because I would otherwise get conflicts&hellip; I&rsquo;m not overly satisfied with this, but it will do for the moment.</p>

<p>I was happily supprised by the readability of error messages when the mach fails. Rspec does a very good job about this. I think it would be possible to get even better error messages by explicity using the sub matchers messages though. If anyone is interested, help yourself !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby regex captures oneliner]]></title>
    <link href="http://philippe.bourgau.net/ruby-regex-captures-oneliner/"/>
    <updated>2013-09-11T09:02:00+02:00</updated>
    <id>http://philippe.bourgau.net/ruby-regex-captures-oneliner</id>
    <content type="html"><![CDATA[<p>Surely this post is nothing new for experienced ruby developpers, but I found it so handy, that I thought it deserved a post of its own though. The problem is :</p>

<blockquote><p>How do I match and assign captures from a regex in a single line of code ?</p></blockquote>

<p>Here is the idea :</p>

<p>```ruby</p>

<blockquote><p>brand, item = /([^,]<em>), (.</em>)/.match(&ldquo;APPLE, ipad&rdquo;).captures
=> [&ldquo;APPLE&rdquo;, &ldquo;ipad&rdquo;]
brand
=> &ldquo;APPLE&rdquo;
item
=> &ldquo;ipad&rdquo;
```</p></blockquote>

<p>There are a few variations around this, like grouping some catpures in an array :</p>

<p>```ruby</p>

<blockquote><p>brand, <em>details = /([^,]</em>), ([^:]<em>): (.</em>)/.match(&ldquo;APPLE, ipad: iOs&rdquo;).captures
=> [&ldquo;APPLE&rdquo;, &ldquo;ipad&rdquo;, &ldquo;iOs&rdquo;]
brand
=> &ldquo;APPLE&rdquo;
details
=> [&ldquo;ipad&rdquo;, &ldquo;iOs&rdquo;]
```</p></blockquote>

<p>Or to ignore some capture, we could shorten skip some captures :</p>

<p>```ruby</p>

<blockquote><p>item, details = /([^,]<em>), ([^:]</em>): (.*)/.match(&ldquo;APPLE, ipad: iOs&rdquo;)[2..-1]
=> [&ldquo;ipad&rdquo;, &ldquo;iOs&rdquo;]
item
=> &ldquo;ipad&rdquo;
details
=> &ldquo;iOs&rdquo;
```</p></blockquote>

<p>But this only works for first or last captures, when this is not the case, one can also use the functional programming &lsquo;_&rsquo; sink convention :</p>

<p>```ruby</p>

<blockquote><p>brand, _, details = /([^,]<em>), ([^:]</em>): (.*)/.match(&ldquo;APPLE, ipad: iOs&rdquo;).captures
=> [&ldquo;APPLE&rdquo;, &ldquo;ipad&rdquo;, &ldquo;iOs&rdquo;]
brand
=> &ldquo;APPLE&rdquo;
details
=> &ldquo;iOs&rdquo;
```</p></blockquote>

<p>One can even use &lsquo;_&rsquo; multiple times on the same match</p>

<p>```ruby</p>

<blockquote><p><em>, </em>, details = /([^,]<em>), ([^:]</em>): (.*)/.match(&ldquo;APPLE, ipad: iOs&rdquo;).captures
=> [&ldquo;APPLE&rdquo;, &ldquo;ipad&rdquo;, &ldquo;iOs&rdquo;]
details
=> &ldquo;iOs&rdquo;
```</p></blockquote>

<p>I hope this helps.</p>
]]></content>
  </entry>
  
</feed>
