<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactoring | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/refactoring/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2017-08-18T09:45:16+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[10 things to know that will make you great at refactoring legacy code]]></title>
    <link href="http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/"/>
    <updated>2017-07-28T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>We write tons of <a href="https://en.wikipedia.org/wiki/Legacy_code">legacy code</a> everyday. Experienced developers understand that legacy code is not something special. Legacy code is our daily bread and butter.</p>

<p>Should we abandon all hope as we enter legacy code ? Would that be professional ? In the end, code is only a bunch of bytes, somewhere on a drive. We are the software professionals. We need to deal with that.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/keep-calm-and-take-the-power-back-4.jpg" alt="Keep Calm and Take The Power Back" /></p>

<h2>1. Master non legacy refactoring first</h2>

<p>Please calm down before this &ldquo;Bring &lsquo;em out&rdquo; energy goes to your head.</p>

<p>I did not say that refactoring legacy code is easy. Legacy code can bite &hellip; bad. I&rsquo;ve been in teams which literally spent nights fixing a bad refactoring gone to production &hellip;</p>

<p>Before you can refactor legacy code, you need to be good at refactoring new code. We all learned to swim in the shallow pool, it&rsquo;s the same with refactoring. Mastering green code refactoring will help you when tackling legacy code.</p>

<p>First, you&rsquo;ll know the ideal you&rsquo;d like to get to. Knowing how productive a fast feedback loop is will motivate you to keep on refactoring.</p>

<p>Second, you&rsquo;ll have a better idea of the baby steps to take you through a tricky refactoring.</p>

<p>If you are not yet at ease with greenfield refactoring, have a look at <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">my previous post</a>.</p>

<h2>2. Understand that refactoring legacy code is different</h2>

<p>The next thing to remember is that refactoring legacy code is different. Let&rsquo;s assume <a href="https://stackoverflow.com/questions/4174867/what-is-the-definition-of-legacy-code">Michael Feather&rsquo;s definition of legacy code</a> : &ldquo;Code without tests&rdquo;. Getting rid of legacy code means adding automated tests.</p>

<p>Unfortunately, trying to force push unit tests in legacy code usually results in a mess. It introduces lot&rsquo;s of artificial mocks in a meaningless design. It also creates brittle and unmaintainable tests. More harm than good. This might be an intermediate step, but it is usually not the quickest way to master your legacy code beast.</p>

<p>Here are alternatives I prefer.</p>

<h2>3. Divide and conquer</h2>

<p>This is the most straightforward way to deal with legacy code. It&rsquo;s an iterative process to repeat until you get things under control. Here is how it goes :</p>

<p>(1) Rely on the tests you have, (2) to refactor enough, (3) to test sub-parts in isolation. (4) Repeat until you are happy with the speed of the feedback loop.</p>

<p>Depending on the initial state of your tests, this might take more or less time. Your first tests might even be manual. This is the bulldozer of refactoring. Very effective, but slow.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/bulldozer.jpg" alt="Bulldozer" /></p>

<h2>4. Pair or mob program</h2>

<blockquote><p>Given enough eyeballs, all bugs are shallow.</p>

<p><a href="https://en.wikipedia.org/wiki/Linus%27s_Law">Linus&rsquo;s Law</a></p></blockquote>

<p>Changing legacy code is a lot easier when you team up. First, it creates a motivating &ldquo;we&rsquo;re all in this together&rdquo; mindset. Second, it guards us against silly mistakes.</p>

<p><a href="https://en.wikipedia.org/wiki/Mob_programming">Mob programming</a>, might seem very expensive, so let me explain why it is not. Suppose you want to introduce some tests in a tricky section of code.</p>

<p>With mob programming, all the team gathers for half a day to work on this change. Together, they find and avoid most of the pitfalls. They commit a high quality change, which creates only one bug down the road.</p>

<p>Let&rsquo;s see the alternative.</p>

<p>Using solo programming, a poor programmer tries to tackle the change all by himself. He spends a few days to understand and double check all the traps he can think of. Finally, he commits his change, which results in many bugs later on. Every time a bug pops up, it interrupts someone to fix it ASAP.</p>

<p>The savings in interruptions are greater than up front cost of mob or pair programming. </p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/p_pvslS4gEI" frameborder="0" allowfullscreen></iframe>


<h2>5. Seams</h2>

<blockquote><p>A software seam is <em>a place where you can alter behavior in your program without editing in that place.</em></p>

<p><a href="http://wiki.c2.com/?SoftwareSeam">Michael Feathers</a></p></blockquote>

<p>This is one of the many interesting things I learned from Michael&rsquo;s book about legacy code.</p>

<p><a href="https://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=edaadc6370c2c8c9e943348d9fbdafb9"><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/legacy-code.jpg" alt="Cover of Working Effectively with Legacy Code" /></a></p>

<p>Object polymorphism is only one kind of seam. Depending on your language, many other types of seams can be available. </p>

<ul>
<li>Type seam for generic languages</li>
<li>Static link seam for static libraries</li>
<li>Dynamic link seam for dynamic libraries</li>
<li>&hellip;</li>
</ul>


<p>Finding seams in your program is something opportunistic. Keep in mind though that testing through seams is not the end goal. It is only a step to bootstrap the test-refactor loop and start your refactoring journey.</p>

<h2>6. Mikado Method</h2>

<p>How do you get to your end then ? How to you refactor only what&rsquo;s useful for your features ? How do you do large refactorings in baby steps ?</p>

<p>Over time, I found that the mikado method is a good answer to all these issues. The goal of the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> is to build a graph of dependent refactoring. It can then use it to perform all these refactorings one by one. Here is the mikado method by the book.</p>

<p>Before anything else, you&rsquo;ll need a large sheet of paper to draw the graph. Then repeat the following :</p>

<ol>
<li>try to do the change you want</li>
<li>If it builds and the tests pass, great, commit and you&rsquo;re done</li>
<li>Otherwise, add a node for the change you wanted to do in your mikado graph</li>
<li>Write down the compilation and test errors </li>
<li>Revert your change</li>
<li>Recurse from 1 for every compilation or test error</li>
<li>Draw a dependency arrow from the nodes of errors to the node of your initial change</li>
</ol>


<p>Once you built the full graph, tackle the refactorings from the leaves. As leafs have no dependencies, it should be easy to do and commit them.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado.jpg" alt="A Sample Mikado Graph" /></p>

<p>When I first read about the mikado method, it seemed very simple and powerful. Things got more complex when I tried to apply it. For example, the fact that some changes don&rsquo;t compile hide future test failures. That means that very often, the &ldquo;Build the graph&rdquo; and &ldquo;Walk the graph&rdquo; phases overlap. In real life, the graph evolves and changes over time. </p>

<p>My advice about the Mikado Method is not to take it to the letter. It&rsquo;s a fantastic communication tool. It helps not to get lost and to avoid a refactoring tunnel. It also helps to tackle refactoring as a team.</p>

<p>It is not a strict algorithm though. Build and tests are not the only way to build the graph. Very often, a bit of thinking and expert knowledge are the best tools at hand.</p>

<p><a href="https://www.amazon.com/gp/product/1617291218/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617291218&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=f7405cd74335b3cbb8b263f1a5c37c1d"><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado-book.jpg" alt="Cover of The Mikado Method book" /></a></p>

<h2>7. Bubble Context</h2>

<p>Refactoring needs to be opportunistic. Sometimes there are shortcuts in your refactoring path.</p>

<p>If you have access to a domain expert, the <a href="http://dddcommunity.org/library/evans_2011_2/2">Bubble Context</a> will cut the amount of refactoring to do. It&rsquo;s also an occasion to get rid of all the features that are in your software but that are not required anymore. </p>

<p>The Bubble Context originated from the <a href="http://dddcommunity.org/library/evans_2011_2/">DDD community</a>, as a way to grow a domain in an existing code base. It goes like that :</p>

<ol>
<li>Find a domain expert</li>
<li>(Re)write clean code for a very tiny sub domain</li>
<li>Protect it from the outside with an <a href="https://softwareengineering.stackexchange.com/questions/184464/what-is-an-anti-corruption-layer-and-how-is-it-used">anticorruption layer</a></li>
<li>Grow it little by little</li>
</ol>


<p>I have friends who are fans of the bubble context. It is super effective provided you have a domain expert. It is a method of choice in complex domain software.</p>

<h2>8. Strangler</h2>

<p>Bubble Context works great when refactoring domain specific code, what about the rest ? I had good results with the <a href="https://www.martinfowler.com/bliki/StranglerApplication.html">Strangler pattern</a>.</p>

<p>For example, we had to refactor a rather complex parser for an internal DSL. It was very difficult to incrementally change the old parser, so we started to build a new one aside. It would try to parse, but delegate to the old one when it failed. Little by little, the new parser was handling more and more of the grammar. When it supported all the inputs, we removed the old one.</p>

<p>The strangler is particularly well suited for refactoring technical components. They have more stable interfaces and can be very difficult to change incrementally.</p>

<h2>9. Parallel Run</h2>

<p>This is more of a trick than a long term strategy. The idea is to use the initial (legacy) version of the code as a reference for your refactoring. Run both and check that they are doing the same thing.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/railroad.jpg" alt="Parallel Railroads" /></p>

<p>Here are some variations around this idea.</p>

<p>If the code you want to refactor is side effect free, it should be easy to duplicate it before refactoring. This enables running both to check that they compute the same thing.</p>

<p>Put this in a unit test to bootstrap a test-refactor loop. You can also run both in production and log any difference. You&rsquo;ll need access to production logs &hellip; Devops teams have a refactoring advantage !</p>

<p>Here is another use of your logs. If the code writes a lot of logs, we can use them as a reference. Capture the logs of the old version, and unit test that the refactored version prints the same logs out. That&rsquo;s an unmaintainable test, but good enough to bootstrap the test-refactor loop.</p>

<p>The <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose kata</a> is a good exercise to practice this last technique.</p>

<h2>10. Dead code is better off dead</h2>

<p>You don&rsquo;t need to refactor dead code ! Again, access to production logs is a great advantage for refactoring.</p>

<p>Add logs to learn how the real code runs. If it&rsquo;s never called, then delete it. If it&rsquo;s only called with some set of values, simplify it.</p>

<h2>No silver bullet</h2>

<p>That was a whirlwind tour of the legacy code refactoring techniques I know. It&rsquo;s no promise that refactoring will become easy or fast. I hope it is a good starting point to set up and walk a refactoring plan.</p>

<p>This was the last post of a series of 3 about how to learn refactoring techniques. If you didn&rsquo;t already, check part 1 <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a> and part 2 <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">How to Start Learning the Tao of Incremental Code Refactoring Today</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to start learning the tao of incremental code refactoring today]]></title>
    <link href="http://philippe.bourgau.net/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/"/>
    <updated>2017-07-21T08:05:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-start-learning-the-tao-of-incremental-code-refactoring-today</id>
    <content type="html"><![CDATA[<p>In my <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">last post</a>, I explained why incremental refactoring techniques will make you both more productive and relaxed.</p>

<p>As anything worth its salt, the path to full mastery is long and requires dedication. The good news is that you&rsquo;ll start to feel the benefits long before you are a master.</p>

<h2>Dedicated Practice</h2>

<p>The quickest thing that will get you up to speed is dedicated practice. Take some time to do some exercices outside of any &lsquo;production&rsquo; code.</p>

<h3>TDD Coding Katas</h3>

<p>The most famous practice to learn TDD also works very well to learn refactoring. That shouldn&rsquo;t be a surprise as incremental refactoring is an integral part of TDD.</p>

<p>There are many ways to do your first coding kata. You could find a coding dojo near you (ask <a href="https://www.meetup.com/">meetup.com</a>). Or you could find motivated colleagues to start one at your company &hellip; I wrote in more details about how to attend a coding dojo in <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">this post</a>.</p>

<p><a href="https://www.amazon.com/gp/product/919811803X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=919811803X&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=340ea938a5e4f00178676804ac6c2278"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/coding-dojo.jpg" alt="Emily Bache's Coding Dojo book cover" /></a></p>

<p>You can also practice katas on your own. My friend <a href="https://twitter.com/tpierrain">Thomas Pierrain</a> rehearses the same katas to discover deeper insights.</p>

<h3>Refactoring Golf</h3>

<p>The goal of incremental refactoring is to keep the code production ready all the time. Smaller commits is one happy consequence of that.</p>

<p>You can stretch your refactoring muscles by doing coding katas and keeping the code compiling all the time. You&rsquo;ll need to master your IDE and its automated refactoring. Most of all, it will shift your attention from the goal to the path !</p>

<p>I learned at <a href="https://www.spaconference.org/spa2017/">SPA conference</a> that we call this &lsquo;Refactoring golf&rsquo;. The name comes from Golf contests, <a href="http://wiki.c2.com/?PerlGolf">popular in the Perl community</a>. Their goal is to write the shortest program possible to do a specific goal. The goal of a Refactoring Golf is to go from code A to code B in the fewest transformations possible.</p>

<p>They are a few <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=refactoring+golf&amp;type=">refactoring golf repos on Github</a>, I tried one and found it fun ! Give it a try too !</p>

<h2>Study some theory</h2>

<p>Real mastery does not come by practice alone. Studying theory alongside practice yields deeper insights. Theory enables to put your practice into perspective and to find ways to improve it. It saves you from getting stuck in bad habits. It also saves you from having to rediscover everything by yourself.</p>

<h3>Develop your design taste</h3>

<p>In <a href="http://www.paulgraham.com/taste.html">Taste for Makers</a> Paul Graham explains why taste for is fundamental to programming. Taste is what allows you to judge if code is nice or bad in a few seconds. Taste is subjective, intuitive and fast, unlike rules which are objective but slower. Expert designers use taste to pinpoint issues and good points in code on the spot.</p>

<p>Within the fast TDD &ndash; Refactoring loop, taste is the tool of choice to drive the design. Guess what : we can all improve our design taste !</p>

<p><a href="https://blog.codinghorror.com/code-smells/">Code smells</a> are the first things to read about to improve your design taste. Once you know them well enough, it will be possible to spot things that might need refactoring as you code.</p>

<p>Spotting problems is nice, but finding solutions is better ! <a href="https://en.wikipedia.org/wiki/Software_design_pattern">Design Patterns</a> are just that &hellip; There has been a lot of controversy around Design Patterns. If overusing them leads to bloated code, using them to fix strong smells makes a lot of sense. There is even a book about the subject :</p>

<p><a href="https://www.amazon.com/gp/product/0321213351/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321213351&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=d79d093008fb9e77f75ea2089d6cbdae"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/refactoring-to-patterns.jpg" alt="Joshua Kerievsky's Refactoring To Patterns book cover" /></a></p>

<p>Finally, there&rsquo;s a third and most common way to improve our design taste. It&rsquo;s to read code ! The more code we read, the better our brain becomes at picking small clues about what nice and what is not. It&rsquo;s important to read clean code but also bad code. To read code in different languages. Code built on different frameworks. </p>

<p>So, read code at work, read code in books, read code in open source libraries, good code, legacy code &hellip;</p>

<h3>Learn your refactorings</h3>

<p>As with most topics in programming there is a reference book about refactoring. It&rsquo;s Martin Fowlers&rsquo;s <a href="https://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=73fc09a5a451402a7036509ae62e8c66">Refactoring, improving the design of existing code</a>. Everything is in there, smells, unit testing and a repository of refactoring walkthroughs.</p>

<p><a href="https://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=73fc09a5a451402a7036509ae62e8c66"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/refactoring.jpg" alt="Martin Fowler's refactoring book cover" /></a></p>

<p>The book is said to be a difficult read, but the content is worth gold. If you have the grit, give it a try ! At the end, you should understand how your IDE does automated refactoring. You should also be able to perform all the refactorings that your IDE does not provide by hand ! This will enlarge your refactoring toolbox, and help you to drive larger refactorings from A to B.</p>

<h2>Develop a refactoring attitude</h2>

<p>Practice makes perfect. Whatever our refactoring skill, there is something to learn by practicing more.</p>

<h3>Make it a challenge</h3>

<p>As you are coding, whenever you find a refactoring to do to your code, make it a challenge to perform it in baby steps. Try to keep the code compiling and the tests green as much as possible.</p>

<p>When things go wrong, revert instead of pushing forward. Stop and think, try to find a different path.</p>

<p>If you are pairing, challenge your pair to find a safer track.</p>

<p>This might delay you a bit at first, but you&rsquo;ll also be able to submit many times per day. You&rsquo;ll see that your refactoring muscles will grow fast. You should see clear progress in only 1 or 2 weeks.</p>

<h3>Team up against long refactorings</h3>

<p>If your team prioritizes a user story that will need some re-design, try to agree on a refactoring plan. The idea is to find a coarse grain path that will allow you to commit and deliver many times. This plan might also help you to share the work on the story.</p>

<p>Having to question and explain your assumptions will speed up your learning. </p>

<h2>Legacy code</h2>

<p>Refactoring is most useful with bad legacy code. Unfortunately, it also where it is the most difficult. Next week&rsquo;s blog post will be about what we can do to learn how to refactor legacy code.</p>

<p>That was my second post in this mini-series about refactoring. First one was <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a>. The third and last is <a href="/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/">10 things to know that will make you great at refactoring legacy code</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7 reasons why learning refactoring techniques will improve your life as a software engineer]]></title>
    <link href="http://philippe.bourgau.net/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/"/>
    <updated>2017-07-10T09:10:00+02:00</updated>
    <id>http://philippe.bourgau.net/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer</id>
    <content type="html"><![CDATA[<p>This post is a bold promise. Mastering incremental refactoring techniques makes our lives as software engineers more enjoyable.</p>

<p>I have already made the <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">same statement about TDD before</a>. As <a href="http://www.extremeprogramming.org/rules/refactor.html">refactoring</a> is a part of TDD, one could think I am repeating myself. At the same time, a <a href="https://blogs.msdn.microsoft.com/ericgu/2017/06/22/notdd/">recent Microsoft blog post</a> argued that refactoring is more important than TDD. Even though I&rsquo;m a TDD fan, that&rsquo;s an interesting point.</p>

<p>Incremental refactoring is key to make releases non-events ! As early as 2006, using <a href="https://en.wikipedia.org/wiki/Extreme_programming">XP</a>, we were releasing mission critical software without bugs ! We would deliver a new version of our software to a horde of angry traders and go to the movies without a sweat !</p>

<p>What&rsquo;s so special about incremental refactoring ?</p>

<h2>Avoid the tunnel effect</h2>

<p><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/tunnel.jpg" alt="A long tunnel" /></p>

<p>Mastering incremental refactoring techniques allows to break a feature down to baby steps. Not only smaller commits, but also smaller releases ! You can deploy and validate every step in production before we move to the next !</p>

<p>Small releases are also a lot easier to fix than big bang deployments. That alone is a good enough reason to deploy in baby steps.</p>

<p>There are a lot of other advantages to small deployments. Merges become straightforward. Someone can take over your work if you get sick. Finally, it&rsquo;s also easier to switch to another urgent task if you need to.</p>

<h2>Deliver early</h2>

<p>When you know that you will be able to improve your work later on, it becomes possible to stick to what&rsquo;s needed <em>now</em>. After spending some time working on a feature, it might turn out that you delivered enough value. Between enhancing this feature and starting another one, pick the most valuable. Don&rsquo;t be able to switch. Incremental refactoring, makes it easy to resume later on if it makes sense.</p>

<p>Real productivity is not measured through code, but through feature value. This explains why incremental refactoring is more productive than up-front / big-bang development.</p>

<h2>Know where you stand</h2>

<p>As you&rsquo;ll work through your feature, you&rsquo;ll have to keep track of the done and remaining steps. As you go through this todo list and deliver every successive step, you get a pretty clear idea of where you stand. You&rsquo;ll know that you&rsquo;ve done 3 out of 7 steps for example. It helps everyone to know what&rsquo;s the remaining work and when you&rsquo;ll be able to work on something else.</p>

<p><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/wool-tangled.jpg" alt="Tangled wool" /></p>

<p>A few times, I fell in the trap of features that should have taken a few hours and that lingered for days. I remember how stupid I was feeling every morning, explaining to my colleagues that it was more complex than I had thought, but that it should be finished before tomorrow &hellip; Learning incremental refactoring techniques saved me from these situations.</p>

<h2>Deliver unexpected feature</h2>

<p>Incremental refactoring techniques improves the code. As a systematic team wide effort, it keeps the code healthy and evolutive. When someone requests an unexpected feature late, you&rsquo;ll be able to deliver it.</p>

<p>This should improve your relation with product people. They will be very happy when you build their latest idea without a full redesign.</p>

<h2>Avoids rewrites</h2>

<p>Joel Spolsky wrote a long time ago that rewriting a large piece of software is the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">number 1 thing not to do</a> ! All my experiences in rewriting systems have been painful and stressful.</p>

<p>It always starts very rosy. Everyone is feeling very productive with the latest tools and technologies. Unfortunately, it takes a lot of features to replace the existing system. As always with software, the time estimates for the rewrite are completely wrong. As a result, everyone starts grumbling about why this rewrite is taking so long. The fact that the legacy system is still evolving does not help either. Long story short, the greenfield project ends up cutting corners and taking technical debt pretty fast &hellip; fueling the infamous vicious circle again.</p>

<p>Incremental refactoring techniques offer an alternative. It enables to change and improve the architecture of the legacy system. It <em>looks</em> longer, but it&rsquo;s always less risky. And looking back, it&rsquo;s almost always faster as well !</p>

<h2>Ease pair programming</h2>

<p>eXtreme Programming contains a set of practices that reinforce each other. As I wrote at the beginning, refactoring goes hand in hand with TDD. <a href="/blog/categories/pair-programming/">Pair programming</a> is another practice of XP.</p>

<p><a href="http://www.extremeprogramming.org/map/code.html"><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/xp-practices.GIF" alt="Tangled wool" /></a><div class="image-credits">From <a href="http://www.extremeprogramming.org/">www.extremeprogramming.org/</a></div></p>

<p>TDD and Refactoring simplify pair programming. When a pair is doing incremental refactoring, they only need to discuss and agree on the design at hand. They know that however the design needs to evolve in the long term, they&rsquo;ll be able to refactor it. It&rsquo;s a lot easier to pair program if you don&rsquo;t have to agree on all the details of the long term design &hellip;</p>

<p>In turn, pair programming fosters <a href="http://www.extremeprogramming.org/rules/collective.html">collective code ownership</a>. Collective code ownership increases the <a href="https://en.wikipedia.org/wiki/Bus_factor">truck factor</a>. Which reduces the project risks and makes the team&rsquo;s productivity more stable. In the long run, this makes the work experience more sustainable and less stressful.</p>

<h2>Simplify remote work</h2>

<p>Refactoring will also save you from the commutes and allow you to work closer to the ones you love !</p>

<p>Refactoring techniques enable small commits. Small commits simplify code reviews, which are key to remote or distributed work. Even if you are doing <a href="/rexp-remote-extreme-programming/">remote pair programming</a>, small commits help to switch the control between buddies more often.</p>

<p><a href="https://www.amazon.com/gp/product/B00I800FFY/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00I800FFY&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=9873e69d645cba27701f4b3744acab0e"><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/remote-pairing.jpg" alt="Tangled wool" /></a></p>

<h2>To be continued</h2>

<p>I hope that by now I persuaded you to learn incremental refactoring techniques. My <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">next post</a> will dig into the details about how to do that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 SPA Conference takeaways that could make us better software professionals]]></title>
    <link href="http://philippe.bourgau.net/5-spa-conference-takeaways-that-could-make-us-better-software-professionals/"/>
    <updated>2017-07-06T22:17:00+02:00</updated>
    <id>http://philippe.bourgau.net/5-spa-conference-takeaways-that-could-make-us-better-software-professionals</id>
    <content type="html"><![CDATA[<p>Last week, my colleague <a href="https://ahmadatwi.me/">Ahmad Atwi</a> and I went to the London <a href="https://www.spaconference.org/spa2017/">SPA Conference</a> to give our <a href="https://www.youtube.com/watch?v=oJsukJhxt7E">Remote eXtreme Practice</a> talk.</p>

<p>The London <a href="http://www.extremeprogramming.org/">eXtreme Programming</a> is one of the most active in the world. You could feel an XP atmosphere at the conference. For example, people like <a href="http://www.natpryce.com/">Nat Pryce</a> and <a href="https://twitter.com/sf105">Steve Freeman</a>, authors of <a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=fcdd83a07a3cfb190f2c8e7e8b9f72c3">GOOSGT</a> book were speakers.</p>

<p><a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=fcdd83a07a3cfb190f2c8e7e8b9f72c3"><img src="../imgs/2017-07-06-5-spa-conference-takeaways-that-could-make-us-better-software-professionals/growing.jpg" alt="The cover of Growing Object-Oriented Software, Guided By Tests" /></a></p>

<p>To summarize, we had the chance to attend a lot of very interesting sessions during the 3 days of the conference. Here are 5 pearls of wisdom I took back with me.</p>

<h2>What connascences are</h2>

<p>Identifying code <a href="http://connascence.io/">connascences</a> helps to rank refactorings and keep the system maintainable.</p>

<p><a href="http://www.extremeprogramming.org/rules/refactor.html">Continuous refactoring</a> is one of the core practices of XP. For me, knowing what to refactor next has been a matter of <a href="https://martinfowler.com/bliki/CodeSmell.html">code smells</a>, discussing with my pair and gut feeling.</p>

<p>A connascence is a coupling between parts of the system. Two parts of your code are connascent if changing one implies changing the other. For example, a function call is connascent by name with the function definition. If you change one, you need to change the other.</p>

<p>Connascences are more formal than code smells. We can detect and rank them to pick the most important refactoring to do. People have listed 9 types of connascences. Some are visible in the source code, others are dynamic and difficult to spot before runtime.</p>

<p>The lowest form of connascence is <a href="http://connascence.io/name.html">&lsquo;of name&rsquo;,</a> like in the function call example above. The worst form is <a href="http://connascence.io/identity.html">&lsquo;of Identity&rsquo;</a>, when different parts of the system must reference the same object.</p>

<iframe src="http://philippe.bourgau.net//www.slideshare.net/slideshow/embed_code/key/jPvF4gxm5z6cGN?startSlide=14" width="510" height="420" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p>The higher the connascence, the more difficult it is to evolve the parts involved. Instead of relying on intuition, you can use a connascence based refactoring algorithm :</p>

<ol>
<li>Detect the highest connascence</li>
<li>Reduce or remove it</li>
<li>Repeat.</li>
</ol>


<p>Thanks <a href="https://twitter.com/xpsurgery">Kevin Rutherford</a> and <a href="https://twitter.com/mowat27">Adrian Mowat</a> for your <a href="http://xpsurgery.com/resources/connascence-hunt-slides/">Red Green then what ?</a> session about connascence.</p>

<h2>Tips for pairing with junior developers</h2>

<p><a href="https://twitter.com/irinatsyganok">Irina Tsyganok</a> and <a href="http://www.natpryce.com/">Nat Pryce</a> gave a very fun session about this topic. A lot of valuable points discussed, from which I saved a few pearls of wisdom.</p>

<blockquote class="twitter-tweet" data-lang="fr"><p lang="en" dir="ltr">Cat eating session from <a href="https://twitter.com/natpryce">@natpryce</a> at <a href="https://twitter.com/hashtag/spaconf17?src=hash">#spaconf17</a> (unless <a href="https://twitter.com/irinatsyganok">@irinatsyganok</a> stops him) <a href="https://t.co/XSiaPDp9kJ">pic.twitter.com/XSiaPDp9kJ</a></p>&mdash; Andy Longshaw (@andylongshaw) <a href="https://twitter.com/andylongshaw/status/879714743963054080">27 juin 2017</a></blockquote>


<script async src="http://philippe.bourgau.net//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>It was reassuring to hear Nat saying that &ldquo;As we gain experience, we are not expected to know everything&rdquo;. Pairing with developers out of college is an occasion to &ldquo;exchange&rdquo; skills. Hard learned design skills versus updates on the latest technologies.</p>

<p>I also learned about the <a href="http://actingcoachscotland.co.uk/blog/expert-induced-amnesia/">Expert&rsquo;s Amnesia</a> and why experts often have a hard time teaching. Expert level knowledge is by nature instinctive. At this level of skill, it becomes very difficult to detail the logic of things that seem obvious.</p>

<h2>We engineers are more mentors than coaches</h2>

<p>In the <a href="https://www.amazon.com/gp/product/0201616416/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201616416&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=dc2f9dc4f5ca106842921bfded07b405">first XP book</a>, there were only 3 roles in the team : team members, on site customer and XP coach. The XP coach should be a developer who can help the team to learn the practices and principles of XP.</p>

<p>About the same time, the personal or professional coach jobs appeared. The Scrum Master, is to Scrum what the XP coach is to XP, without the developer part. Remember the joke &ldquo;Scrum is like XP, without everything that makes it work&rdquo; (<a href="https://martinfowler.com/bliki/FlaccidScrum.html">Flaccid Scrum</a>).</p>

<p>It looks like the Agile Coach job title appeared out of all this. The problem is no one exactly knows what this is. Should he be an experienced developer like the XP coach ? A great people person ? Or someone good at introducing change ? or a mix of these ?</p>

<p><a href="http://www.selfishprogramming.com/about/">Portia Tung</a> and <a href="https://uk.linkedin.com/in/helenlisowski">Helen Lisowski</a> &rsquo;s  talk &ldquo;The power of coaching&rdquo; clarified that.</p>

<p>There is no knowledge transfer from the coach to the coachees ! On the other side, a mentor does transfer knowledge to his mentees. The coach helps his coachee take a step back and take decisions in full consciousness. The goal of the mentor is to inspire and train to new techniques.</p>

<p>I&rsquo;m fine being a mentor and not a coach ;&ndash;)</p>

<h2>Servant leaders need to be tough at times</h2>

<p>We hear a lot about servant leadership nowadays. Scrum Master should be servant leaders, as well as managers in agile organizations.</p>

<p><a href="https://fr.linkedin.com/company/bellebeck-limited">Angie Main</a> gave a very interesting session about servant leadership. She made an interesting point I had not heard about before. We all know that servant leaders should trust the team to get the work done most of the time. In spite of that, servant leaders must also be ready to step in and remove people who don&rsquo;t fit in and endanger the team !</p>

<p>This reminded me of what Jim Collins says in <a href="http://www.wikisummaries.org/wiki/Built_to_Last#Chapter_6_.E2.80.93_Cult-like_Cultures">Built to last</a> : &ldquo;People who don&rsquo;t fit are expelled like viruses !&rdquo;</p>

<p><a href="https://www.amazon.com/gp/product/0060516402/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0060516402&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=e83ad8e3dcf7bdb7f875d5b22e8eb4c6"><img src="../imgs/2017-07-06-5-spa-conference-takeaways-that-could-make-us-better-software-professionals/built-to-last.jpg" alt="The cover of Built to Last" /></a></p>

<h2>1/3000 ideas succeeds</h2>

<p>Thanks to <a href="https://twitter.com/ozzieyuce">Ozlem Yuce</a>&rsquo;s session, I learned about the &ldquo;Job To Be Done&rdquo; technique to understand the customer&rsquo;s real needs.</p>

<p>Studies measured that only 1 idea out of 3000 ends up as a successful product ! <a href="https://www.researchgate.net/file.PostFileLoader.html?id=56217976614325233f8b4567&amp;assetKey=AS%3A285916150157312%401445179130594">Here</a> seems to be the original research.</p>

<p>I&rsquo;ll remember this fact next time I&rsquo;m ask for a funky feature !</p>

<h2>To conclude</h2>

<p>At the end, we had a very good time at SPAconference. The talks were insightful, we had interesting discussions, the premises were comfortable and on top of that, food was great !</p>

<p>I&rsquo;m already eager to go to SPA conference 2018 !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[When the Boy Scout Rule Fails]]></title>
    <link href="http://philippe.bourgau.net/when-the-boy-scout-rule-fails/"/>
    <updated>2016-08-02T05:38:00+02:00</updated>
    <id>http://philippe.bourgau.net/when-the-boy-scout-rule-fails</id>
    <content type="html"><![CDATA[<p><img src="../imgs/2016-08-02-when-the-boy-scout-rule-fails/boy-scout-rule.jpg" alt="An illustration of the boy scout rule" /><div class="image-credits"><a href="http://bit.ly/2osQoyg">Original Tweet</a> by Marteen van Leeuwen</div></p>

<p>Here goes the <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule">boy scout rule</a> :</p>

<blockquote><p>Always check a module in cleaner than when you checked it out.</p></blockquote>

<p>Unfortunately, this alone does not guarantee to keep the technical debt under control. What can we do then ?</p>

<h2>Why the boy scout rule is not enough</h2>

<p>I can easily think of a few issues that are not covered by the boy scout rule.</p>

<h3>It only deals with local problems</h3>

<p>In it&rsquo;s statement, the boy scout rule is local and does not address large scale design or architecture issues. Applying the boy scout rule keeps files well written, using with clear and understandable code. From a larger perspective though, it does very little or slow improvement to the overall design.</p>

<p>These large scale refactorings are very difficult to deal with using the boy scout rule alone. It could be done but would require to share the refactoring goal with all the team, and then track its progress, while at the same time dealing with all the other subjects of the project. That&rsquo;s starting to sound like multitasking to me.</p>

<h3>It&rsquo;s skill dependent</h3>

<p>Another point about the boy scout rule (and to be fair, about any refactoring technique) is that programmers will be able to clean the code only as much as their skills allow them to !</p>

<p>Imagine what would happen when a new master developer arrives in a team of juniors, he&rsquo;d spot a lot of technical debt and would suggest improvements and ways to clean the code. Code that was thought of as very clean would suddenly be downgraded to junk !</p>

<p>The point here is that the boy scout rule cannot guarantee that you have no technical debt, because you don&rsquo;t know how much you have !</p>

<p>That&rsquo;s where the debt metaphor reaches its limits and flips to some productivity investment. By investing time to perform some newly discovered refactoring, you could get a productivity boost !</p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470200818&amp;sr=8-1&amp;keywords=domain+driven+design"><img class="center" src="/imgs/2016-08-02-when-the-boy-scout-rule-fails/ddd.jpg" title="The cover of &ldquo;Domain Driven Design&rdquo;" ></a></p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470200818&amp;sr=8-1&amp;keywords=domain+driven+design">Domain-Driven Design: Tackling Complexity in the Heart of Software</a>, Eric Evans calls this knowledge distillation. He means that little by little, the team gains better understanding of the domain, sometimes going through what he calls a &lsquo;breakthrough&rsquo;. These breakthroughs often promote existing code to technical debt &hellip;</p>

<h3>It&rsquo;s context dependent</h3>

<p>Developers alone are not the only one responsible for creating technical debt. Changes to the environment also do.</p>

<p>For example, if the market conditions change, and that new expectations for the product are slowly becoming the norm, your old perfectly working system becomes legacy and technical debt. As an example, let&rsquo;s examine what happened to the capital markets software industry in response to the 2008 crisis.</p>

<ul>
<li>The sector became a lot more regulated</li>
<li>Risk control is moving from nightly batches to real time</li>
<li>The demand for complex (and risky) contracts decreased</li>
<li>As a consequence, trading on simpler contracts exploded</li>
</ul>


<p>All these elements combined invalidated existing architectures !</p>

<p>New technologies also create technical debt. Think the switch from mainframe to the web.</p>

<h2>What do we need then ?</h2>

<p>Should we stop using the boy scout rule ? Surely not, it would be a total non-sense. Submitting clean and readable code is a must.</p>

<p>But it is not enough. If you have spotted some large scale refactoring that could bring some improvement, we should do what a fund manager would do :</p>

<ol>
<li>Estimate the return on investment</li>
<li>If it is good enough, do it now</li>
</ol>


<p>Obviously, large refactorings should also be split into smaller <del>value adding</del> cost reducing items. But then what ?</p>

<p><a href="https://www.amazon.com/Nature-Software-Development-Simple-Valuable/dp/1941222374/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470290668&amp;sr=8-1&amp;keywords=the+nature+of+software+development"><img class="center" src="/imgs/2016-08-02-when-the-boy-scout-rule-fails/nature-of-software.jpg" title="The cover of &ldquo;The Nature of Software Development&rdquo;" ></a></p>

<p>In <a href="https://www.amazon.com/Nature-Software-Development-Simple-Valuable/dp/1941222374/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470290668&amp;sr=8-1&amp;keywords=the+nature+of+software+development">The Nature of Software Development</a> Ron Jefferies says that we need a unique value-based prioritization strategy for everything, including technical improvements. Once you&rsquo;ve got that, there&rsquo;s no sense in splitting and embedding your refactoring in other tasks, this will just increase your work in progress, reducing your throughput and cycle time.</p>

<p>Frankly, I think that&rsquo;s easier said than done. I can <em>think</em> of two ways :</p>

<ul>
<li>As Ron Jefferies tends to say, have a jelled-cross-functional team discuss and prioritize collectively</li>
<li>As <a href="http://reinertsenassociates.com/technical-debt-adding-math-metaphor/">Don Reintersen</a> advocates, use an <a href="/a-plan-for-technical-debt-lean-software-development-part-7/">economical framework</a> to estimate the return on investment</li>
</ul>


<p>At least that&rsquo;s a starting point !</p>
]]></content>
  </entry>
  
</feed>
