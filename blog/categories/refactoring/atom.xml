<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactoring | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/refactoring/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-07-12T06:01:03+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5 mistakes badass developers never do]]></title>
    <link href="http://philippe.bourgau.net/5-mistakes-badass-developers-never-do/"/>
    <updated>2018-07-12T12:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/5-mistakes-badass-developers-never-do</id>
    <content type="html"><![CDATA[<p>Here is a one sentence summary of my <a href="/why-we-need-badass-developers-to-perform-large-scale-refactorings/">previous post</a>.</p>

<blockquote><p>Badass developers negotiate large scale refactorings with the business better.</p></blockquote>

<p> Unfortunately, not all of us are sitting next to a true badass developer &hellip; Hopefully, we can all become one ! Depending on our track record, it&rsquo;s going to be more or less difficult, but with time and the good attitude, we can all do it. Becoming a badass developer is all about trustworthiness.</p>

<p>This post is the third in a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for a large scale refactoring</a>. If you haven&rsquo;t, I recommend you to start from <a href="/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/">the beginning</a>.</p>

<p>The first thing to become trustworthy is to avoid things that kill trust. Sounds obvious, but it&rsquo;s very easy to forget. Here are 5 examples of trust killers you should never do if you want to become a badass developer.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-07-03-5-mistakes-badass-developers-never-do/mistake.jpg" alt="Drawing of a hurt finger after someone made a mistake with a hammer. Badass developer don't do this kind of mistakes !" /></p>

<h2>Resume Driven Development</h2>

<p>We should pick the best tools for the job. The best tools are often a bit old, precisely because they&rsquo;ve been battle tested in production for a while ! That&rsquo;s exactly the kind of technologies you want your business to rely on.</p>

<p>To keep his skills up to date, a badass developer will not add a funky new tech in the production code. He would rather negotiate <a href="http://www.jamesshore.com/Agile-Book/slack.html">slack time</a> with the business. He might also openly <em>take</em> his Friday afternoons to experiment the latest techs ! He would simply explain that it&rsquo;s to avoid polluting the production system.</p>

<blockquote><p>ðŸ’¡ A badass developer will not add a funky new tech in the production code.</p></blockquote>

<h2>Over-engineering</h2>

<p>Gold plating or over-engineering are similar anti-patterns. A badass developer always keeps the business&rsquo;s interest in mind. This means he knows how to balance long term design and short term features. A good rule of thumb is to keep a vision in sight, but to get there in baby steps.</p>

<h2>Build features with no agreed upon value</h2>

<p>Product managers are here to select what should and what should not be in the product. As product experts, they are the ones who know how much a feature is worth. Except (maybe) when we are building tools for others developers, they know better than us. Adding something of dubious value in the product is bad in two ways.Â </p>

<ul>
<li>First, it takes some time to build, time that we could use to build valuable features instead. Remember : <a href="/real-developers-ship/">Real developers ship</a> !</li>
<li>Second, it creates unnecessary code to maintain. In the worst case, it can <a href="/incremental-architecture-a-cure-against-architecture-astronauts/">constraint the architecture</a>. Which might eventually prevent us from adding other more valuable features afterwards.</li>
</ul>


<h2>Hide in a tunnel</h2>

<p>We should always be careful of the tunnel effect. Seeing their money vanishing with no visible output makes business people, understandably, creepy. As soon as things become too complicated, a badass developer will raise the alarm. The fact is that he has been in this kind of situation before, and knows how to recognize it. At that point, it&rsquo;s still possible to discuss the problem with everyone, and adjust the plan.</p>

<p>As an interesting side note, I was at the <a href="https://www.meetup.com/fr-FR/DDD-Paris/">Paris DDD Meetup</a> last Thursday. We had the chance to welcome <a href="https://twitter.com/ericevans0">Eric Evans</a> as a surprise guest ! When asked what were his worst mistakes, he said something along this line :</p>

<blockquote><p>ðŸ’¡ Some of my biggest mistakes were not backtracking soon enough a few times as I was drifting in quagmire. Eric Evans</p></blockquote>

<p><a href="https://www.meetup.com/fr-FR/DDD-Paris/events/248022866/"><img src="http://philippe.bourgau.net/imgs/2018-07-03-5-mistakes-badass-developers-never-do/eric-evans-ddd-paris.jpg" alt="Eric Evans, the father of DDD, a true badass developer, answering questions at the Paris DDD meetup" /></a><div class="image-credits">By <a href="https://www.grodziski.com/">JÃ©rÃ©mie Grodziski</a>, on <a href="https://www.meetup.com/fr-FR/DDD-Paris/events/248022866/">Paris DDD Meetup</a></div><br></p>

<h2>Let the team down</h2>

<p>It&rsquo;s not only about getting the business&rsquo;s trust. We must also build trust from our fellow developers. Whenever we break the build and leave, or worse, deploy and leave, that trust is gone for a long while&hellip; We should not do that !</p>

<h2>There&rsquo;s more to a badass developer</h2>

<p>I&rsquo;m done with this list of things badass developers don&rsquo;t do. Avoiding these is only the first step to become a badass developer. In <a href="http://eepurl.com/dxKE95">next post</a>, I&rsquo;ll write about what we need to do if we want to build strong trust with the business.</p>

<p>This post is the third post in a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for a large scale refactoring.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why we need Badass developers to perform large scale refactorings]]></title>
    <link href="http://philippe.bourgau.net/why-we-need-badass-developers-to-perform-large-scale-refactorings/"/>
    <updated>2018-07-05T13:28:00+02:00</updated>
    <id>http://philippe.bourgau.net/why-we-need-badass-developers-to-perform-large-scale-refactorings</id>
    <content type="html"><![CDATA[<p><a href="/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/">My last post</a> was about the challenge for dev teams to get sponsorship for large scale refactorings. I listed two main reasons :</p>

<ol>
<li>The business doubts developers to have their interests in mind</li>
<li>They are also not aware of the cost of the current technical debt</li>
</ol>


<p>This post (and the next) will be about how to gain the business&rsquo;s trust. This is exactly where badass developers can help. Let me start with a story.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-06-27-why-we-need-badass-developers-to-perform-large-scale-refactorings/badass-dev.jpg" alt="Drawing of 2 hands of a badass developer over his keyboard, with &quot;&gt;badass&lt;&quot; tatooed on his fingers" /></p>

<p>Back in 2002, at my first job, I started to read <a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?ie=UTF8">Refactoring, Improving the Design of Existing code</a>. That&rsquo;s where I read about unit testing. I found it so great that I made a demo to other programmers. Being the junior dev in the team, my co-workers reaction was something between &ldquo;Meh&rdquo; and &ldquo;Maybe&rdquo;. Fortunately, a more experienced and respected developer gave it a try. A few weeks after my demo, he announced to the team that unit testing worked great on new code. This time, people showed no questioning about his opinion : he if said so, it must have been true. Even business people blessed the practice !</p>

<p><a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?ie=UTF8"><img src="http://philippe.bourgau.net/imgs/2018-06-27-why-we-need-badass-developers-to-perform-large-scale-refactorings/refactoring.jpg" alt="The &quot;Refactoring, improving the design of existing code&quot; cover. Badass developers know how to perform large scale refactoring" /></a></p>

<p>I had given a good live coding demo, but it was this respected developer&rsquo;s opinion that won the point. To convince business people of sponsoring a large scale refactoring, we need their trust. That&rsquo;s why we need badass developers around.</p>

<blockquote><p>ðŸ’¡ I had given a good live coding demo, but it was this respected developer&rsquo;s opinion that won the point.</p></blockquote>

<h2>What is a badass developer</h2>

<p><a href="https://commons.wikimedia.org/wiki/File:I_am_Badass_%28Unsplash%29.jpg"><img src="http://philippe.bourgau.net/imgs/2018-06-27-why-we-need-badass-developers-to-perform-large-scale-refactorings/i-am-badass.jpg" alt="Badass Developer's fist with a ring &quot;I am badass&quot;" /></a></p>

<div class="image-credits">By Brooke Lark<a href="https://unsplash.com/photos/jtvGydbUn30">CC0</a>, via Wikimedia Commons</div>


<br>


<p>Badass developers are first of all people who are credible to the business. This usually implies a track record of <a href="/real-developers-ship/">delivering features</a> and refactorings. Badass developers understand the business constraints. That&rsquo;s why they learned how to deliver <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">refactorings alongside features</a>. They also need to be responsible and bold enough to <a href="/are-software-developers-overworked-or-undecided/">stand ground in front of the business</a>. Finally, badass developers are able to train others.</p>

<blockquote><p>ðŸ’¡ Badass developers are first of all people who are credible to the business</p></blockquote>

<p>Unfortunately, there are not so many badass developers in the industry &hellip; <a href="/developer-are-you-losing-your-rat-race/">It has a youngster bias</a>, and tends to push experienced developers to other activities. As if 10 years of systems design was less valuable than knowing the latest language !</p>

<h2>Learn more about Badasss developers</h2>

<p>I tried to find other words before resorting to &lsquo;Badass&rsquo;. Unfortunately, I could find none that got the point so clearly. <a href="https://blog.cleancoder.com/">Uncle bob</a> calls them &lsquo;software professionals&rsquo; in <a href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073/ref=sr_1_1?s=books&amp;ie=UTF8">The Clean Coder</a>. Professionalism is not specific enough to me. Adam Nowak also calls them &lsquo;responsible developers&rsquo; in a <a href="https://thenextweb.com/dd/2016/03/28/how-to-be-a-responsible-developer/">blog post</a>. Â That does not convey the idea that, sometimes devs need to stand guard in front of the business.</p>

<p><a href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073/ref=sr_1_1?s=books&amp;ie=UTF8"><img src="http://philippe.bourgau.net/imgs/2018-06-27-why-we-need-badass-developers-to-perform-large-scale-refactorings/clean-coder.jpg" alt="The clean coder book cover. Clean coder looks like a form of badass developer" /></a></p>

<p>These concepts, though, are very close to my definition of a badass developer. Check by yourself :</p>

<ul>
<li><a href="https://thenextweb.com/dd/2016/03/28/how-to-be-a-responsible-developer/">How to be a responsible and badass developer</a> by Adam Nowak</li>
<li><a href="https://www.youtube.com/watch?v=BgPj5b6d6nk">Developer under influence</a> by Guillaume Duquesnay</li>
<li><a href="https://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073/ref=sr_1_1?ie=UTF8&amp;qid=1530082880&amp;sr=8-1&amp;keywords=the+clean+coder">The clean coder</a> by <a href="https://blog.cleancoder.com/">Robert Martin</a></li>
</ul>


<h2>To be continued</h2>

<p>This was why badass developers matter to the success of large scale refactorings. This was the second post in a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for a large scale refactoring</a>. Â In the next post, we&rsquo;ll look at what we can do to all become Badass developers.</p>

<p><a href="http://eepurl.com/dxKE95">Stay tuned !</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to convince your business of sponsoring a large scale refactoring]]></title>
    <link href="http://philippe.bourgau.net/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/"/>
    <updated>2018-06-28T06:14:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring</id>
    <content type="html"><![CDATA[<p>Whenever I present or suggest a good practice to dev teams, I often get the same remark. Here is how it goes :</p>

<blockquote><ul>
<li><p>That&rsquo;s a great idea and we would love to do this, but our code is in such a mess that we cannot !</p></li>
<li><p>Maybe you should start doing more refactoring then !</p></li>
<li><p>We would like to, but we don&rsquo;t have the time. We are fire fighting all the time.</p></li>
</ul>
</blockquote>

<p>It&rsquo;s a bit like the old adage of the lumberjack that is too busy to cut wood to sharpen his axe&hellip; The sad part here, is that most of the time, developers know they would be a lot faster if they could clean up their code. Unfortunately, they are usually not given the time.</p>

<h2>How do we end up in this silly situation ?</h2>

<p><a href="../imgs/2018-06-15-how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/why-are-large-scale-refactorings-not-prioritized.jpg"><img src="http://philippe.bourgau.net/imgs/2018-06-15-how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/why-are-large-scale-refactorings-not-prioritized-small.jpg" alt="Drawing of a '5 whys' mind map explaining why it is difficult to get sponsorship for a large scale refactoring" /></a></p>

<h3>Only developers see the bad code</h3>

<p>As I&rsquo;ve <a href="/the-size-of-code/">already been joking about</a>, code is invisible. Mess in the code even more so, especially to people who don&rsquo;t code. The code could look like that and no one would notice.</p>

<p><a href="https://en.wikipedia.org/wiki/Diogenes_syndrome"><img src="http://philippe.bourgau.net/imgs/2018-06-15-how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/Syllogomanie-Puteaux.jpg" alt="Inside of a kitchen from someone suffering from Diogenes syndrome" /></a></p>

<div class="image-credits">Par <a href="http://philippe.bourgau.net//commons.wikimedia.org/w/index.php?title=User:Un_Touriste&amp;action=edit&amp;redlink=1" class="new" title="User:Un Touriste (page does not exist)">Un Touriste</a> â€” <span class="int-own-work">Photographie personnelle</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=15988115">Lien</a></div>


<br>


<p>If someone put his own office in that state, he would get fired, but not for the source code. The good side is that we, developers, are safe, we can continue to wreak chaos without fear ! That&rsquo;s pretty weird when we think that this is what we ship to customers &hellip;</p>

<blockquote><p>ðŸ’¡ Is <a href="https://en.wikipedia.org/wiki/Diogenes_syndrome">Diogenes syndrome</a> for source code a recognized pathology ?</p></blockquote>

<p>Business might also not see bad code because that&rsquo;s the only thing they&rsquo;re used to ! Maybe they&rsquo;ve always been working in dysfunctional organizations that systematically create crappy code. Slow teams, late deliveries and fire fighting might be business as usual for them. From this point of view, trying to improve code is a pure waste of time and energy. The same goes for large scale refactorings.</p>

<p>The worse part of all this is that if devs don&rsquo;t have the time to keep their code clean, it will only get worse. This will reinforce the view that software delivery is slow and that there is nothing to do about it !</p>

<h3>Business has been burnt in the past !</h3>

<p>Bad experiences are another reason why business is unwilling to sponsor refactoring. Did someone sell them an unrealistic productivity boost that turned in a never-ending tunnel project ? Badly managed large scale refactorings deliver late, create no value, and a lot of bugs. At one company I worked for, business gave devs 1 full year (!) to clean up the code &hellip; We took 2 !! Meanwhile, the CEO had to dilute the stocks a bit to keep the boat afloat ! I&rsquo;d think twice before giving this kind of mandate myself.</p>

<p>Performing a large scale refactoring is not easy, and involves specific skills. These skills are about refactoring in baby steps, alongside feature delivery.</p>

<p>Usually, people acquire these skills through hard won experience &hellip; Unfortunately for us, our industry is not very nice to experienced engineers &hellip; It&rsquo;s a lot easier to hire a fresh grad who knows the latest javascript framework than a 2 decades engineer. (Who, BTW, could learn this framework in 2 weeks &hellip;) It&rsquo;s also a lot harder for the junior developer to succeed in negotiating a refactoring.</p>

<p>Again the twist of fate is that junior engineers are a lot more likely to start a submarine latest-framework.js rewrite supposed to solve all maintenance issues &hellip; which will only make things worse.</p>

<h2>Overestimate, only as last resort</h2>

<p>A quick fix is to systematically overestimate to get enough time to refactor. As any other &lsquo;submarine&rsquo; initiative, I would recommend it only in last resort, after you&rsquo;ve tried every other possible technique &hellip; and just before you quit.</p>

<p>Hiding things to the business people kills trust and hides problems. Trust and collaboration is what you need to get the business to sponsor large scale refactorings ! Plus, if ever you mess up (as submarine initiative often do) you&rsquo;ll be the only one to blame &hellip;</p>

<p>That said, &lsquo;overestimating&rsquo; so that you can write clean code is ok. It&rsquo;s not overestimating, it&rsquo;s estimating to do a good job.</p>

<blockquote><p>ðŸ’¡ We should never ask the permission to do a good job. (<a href="https://www.youtube.com/watch?v=SfWCRl75Kas">Doc Norton</a>)</p></blockquote>

<h2>To be continued</h2>

<p>You might wonder what these other techniques are ! That&rsquo;s exactly what I&rsquo;ll go through with the next posts. This was the first one in a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for a large scale refactoring</a>. The series will cover topics like :</p>

<ol>
<li> <a href="/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/">How to convince your business of sponsoring a large scale refactoring</a></li>
<li><a href="/why-we-need-badass-developers-to-perform-large-scale-refactorings/">Why we need Badass developers to perform large scale refactorings</a></li>
<li><a href="/5-mistakes-badass-developers-never-do/">5 mistakes badass developers never do</a></li>
<li>Principles That Will Make You Become a Badass Developer</li>
<li>Techniques to refactor in parallel with features</li>
<li>Nothing convinces business people like money</li>
</ol>


<p><a href="http://eepurl.com/dxKE95">Stay tuned !</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Throwing code away frequently]]></title>
    <link href="http://philippe.bourgau.net/throwing-code-away-frequently/"/>
    <updated>2017-09-01T06:56:00+02:00</updated>
    <id>http://philippe.bourgau.net/throwing-code-away-frequently</id>
    <content type="html"><![CDATA[<p>Here is the main feedback I got about my previous post <a href="/extreme-extreme-programming-2017/">eXtreme eXtreme Programming</a>.</p>

<blockquote><p>What do you actually mean by throwing code away ? Does it mean stoping unit testing and refactoring ?</p></blockquote>

<p><img src="http://philippe.bourgau.net/imgs/2017-09-01-throwing-code-away-frequently/shredder.jpeg" alt="A drawing of a shredder destroying some code" /></p>

<p>So I guess it deserves a bit of explanation.</p>

<h2>What is it all about ?</h2>

<p>When programming, I don&rsquo;t throw code away a lot. I tend to rely on my automated tests to change the code I already have. That might be a problem.</p>

<p>As with everything, there is no one size fits all. We should choose the best practice for our current situation. Same thing applies for incremental changes versus rewriting.</p>

<p>TDD makes incremental changes cost effective, and as such, is a key to get out of the Waterfall.</p>

<p>The idea of throwing code away frequently is to make rewriting cost effective, so we can do it more often.</p>

<h2>Why would we want to do so ?</h2>

<p>In &ldquo;<a href="https://blog.codinghorror.com/when-understanding-means-rewriting/">When Understanding means Rewriting"</a>, Jeff Atwood explains that reading code can be more difficult than writing it. There is a point where rewriting is going to be cheaper than changing.</p>

<p>The more unit test you have, the later you reach that point. The more technical debt you take, and the sooner. The bigger the part to rewrite, the more risky it becomes.</p>

<p>Let&rsquo;s imagine you knew a safe way to rewrite the module you are working on. You could be faster by taking more technical debt and writing less unit tests ! Mike Cavaliere framed it as<br/>
<a href="http://mikecavaliere.com/throw-away-your-code/">F**k Going Green: Throw Away Your Code</a>.</p>

<p>This would be great for new features, that might be removed if they don&rsquo;t bring any value. It would also be a good way to get rid of technical debt. Naresh Jain also makes the point that without tests, you&rsquo;ll have to keep things simple (<a href="https://blogs.agilefaqs.com/2008/10/07/throwing-away-code/">here</a> and <a href="https://fr.slideshare.net/nashjain/the-decline-and-fall-of-agile-antifragile-mindset-to-rescue">here</a>) !</p>

<p>Wait a minute, isn&rsquo;t that <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a> ?</p>

<h2>How to make it work</h2>

<p><a href="/extreme-extreme-programming-2017/"><img src="http://philippe.bourgau.net/imgs/2017-09-01-throwing-code-away-frequently/xxp.jpg" alt="A graph with all the practices from my previous article eXtreme eXtreme Programming" /></a></p>

<h3>How to ensure quality without unit tests ?</h3>

<p>TDD and unit testing is a cornerstone of XP. If we remove it, we need something else to build quality in. Could Mob Programming and Remote teams do the trick ?</p>

<p>&ldquo;Given enough eyeballs, all bugs are shallow&rdquo;. Pair programming and code reviews catch a lot more bugs than solo programming. Only a few bugs are likely to pass through the scrutiny of the whole team doing mob programming.</p>

<p>What about Remote ? Martin Fowler <a href="https://martinfowler.com/articles/remote-or-co-located.html">explains</a> that remote teams perform better by hiring the best. Skills of programmers have been known for a long time as a main driver of software quality.</p>

<p><a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/"><img src="http://philippe.bourgau.net/imgs/2017-09-01-throwing-code-away-frequently/ProductivityVariation.jpg" alt="People vs methodology impact on productivity" /></a><div class="image-credits">Photo from Steve McConnell on <a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/">Construx</a></div></p>

<p>Finally, the Cucumber team <a href="https://cucumber.io/blog/2015/12/21/the-mob-rules-ok">reported</a> that Mob Programming works well for remote teams.</p>

<h3>How to make this safer ?</h3>

<p>Even with the best team, mistakes will happen. How can we avoid pushing a rewrite that crashes the whole system ?</p>

<p>The main answer to that is good continuous deployment. We should deploy to a subset of users first. We should be able to rollback straight away if things don&rsquo;t work as expected.</p>

<p>As the system grows, <a href="https://en.wikipedia.org/wiki/Microservices">microservices</a> can keep continuous deployment under control. We can deploy, update and roll them back independently. By nature, microservices also reduce the scope of the rewrite. That alone, as we said earlier, makes rewrites safer.</p>

<p>As a last point, some technologies make building microservice systems easier and incremental. The <a href="https://stackoverflow.com/questions/16779162/what-kind-of-virtual-machine-is-beam-the-erlang-vm">Erlang VM</a>, for example, with first class actors, is one these. Time to give <a href="https://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a> a try !</p>

<h3>Is this always a good idea ?</h3>

<p>There are good and bad situations.</p>

<p>For example, a lean startup or data driven environment seems a good fit. Suppose your team measures the adoption of new features before deciding to keep or ditch them. You&rsquo;d better not invest in unit tests straight away.</p>

<p>On the other side, software for a complex domain will be very difficult to rewrite flawlessly. I have worked in the finance industry for some years, I know what a complex domain is. I doubt I could rewrite a piece of intricate finance logic without bugs. I would stick to <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a> and unit testing in these areas.</p>

<h3>How to dip your toe</h3>

<p>Here is how I intend to dip <em>my</em> toe. I won&rsquo;t drop automated testing completely yet. What I could do instead (and that I already did on side projects) is to start with end to end tests only.</p>

<p>From there every time I want to change a piece of code, I have many options :</p>

<ul>
<li>Add a new end to end test and change the code.</li>
<li>If the code is too much of a mess, I can rewrite it from scratch. I&rsquo;ll have the safety of the end to end tests.</li>
<li>If I see that the module is stabilizing, has not been rewritten for a while, and yields well to modifications. I could start splitting end to end tests into unit tests, and embark on the TDD road.</li>
</ul>


<p>Maybe later, when I have a team doing mob programming to find my mistakes, we&rsquo;ll skip the end to end tests.</p>

<h2>Other interesting links</h2>

<ul>
<li><a href="http://corgibytes.com/blog/2016/11/01/throwaway-code/">Throwaway Code</a> by M. Scott Ford</li>
<li><a href="http://wiki.c2.com/?RewriteCodeFromScratch">Rewrite Code From Scratch</a> on c2 wiki</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 things to know that will make you great at refactoring legacy code]]></title>
    <link href="http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/"/>
    <updated>2017-07-28T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>We write tons of <a href="https://en.wikipedia.org/wiki/Legacy_code">legacy code</a> everyday. Experienced developers understand that legacy code is not something special. Legacy code is our daily bread and butter.</p>

<p>Should we abandon all hope as we enter legacy code ? Would that be professional ? In the end, code is only a bunch of bytes, somewhere on a drive. We are the software professionals. We need to deal with that.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/keep-calm-and-take-the-power-back-4.jpg" alt="Keep Calm and Take The Power Back" /></p>

<h2>1. Master non legacy refactoring first</h2>

<p>Please calm down before this &ldquo;Bring &lsquo;em out&rdquo; energy goes to your head.</p>

<p>I did not say that refactoring legacy code is easy. Legacy code can bite &hellip; bad. I&rsquo;ve been in teams which literally spent nights fixing a bad refactoring gone to production &hellip;</p>

<p>Before you can refactor legacy code, you need to be good at refactoring new code. We all learned to swim in the shallow pool, it&rsquo;s the same with refactoring. Mastering green code refactoring will help you when tackling legacy code.</p>

<p>First, you&rsquo;ll know the ideal you&rsquo;d like to get to. Knowing how productive a fast feedback loop is will motivate you to keep on refactoring.</p>

<p>Second, you&rsquo;ll have a better idea of the baby steps to take you through a tricky refactoring.</p>

<p>If you are not yet at ease with greenfield refactoring, have a look at <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">my previous post</a>.</p>

<h2>2. Understand that refactoring legacy code is different</h2>

<p>The next thing to remember is that refactoring legacy code is different. Let&rsquo;s assume <a href="https://stackoverflow.com/questions/4174867/what-is-the-definition-of-legacy-code">Michael Feather&rsquo;s definition of legacy code</a> : &ldquo;Code without tests&rdquo;. Getting rid of legacy code means adding automated tests.</p>

<p>Unfortunately, trying to force push unit tests in legacy code usually results in a mess. It introduces lot&rsquo;s of artificial mocks in a meaningless design. It also creates brittle and unmaintainable tests. More harm than good. This might be an intermediate step, but it is usually not the quickest way to master your legacy code beast.</p>

<p>Here are alternatives I prefer.</p>

<h2>3. Divide and conquer</h2>

<p>This is the most straightforward way to deal with legacy code. It&rsquo;s an iterative process to repeat until you get things under control. Here is how it goes :</p>

<p>(1) Rely on the tests you have, (2) to refactor enough, (3) to test sub-parts in isolation. (4) Repeat until you are happy with the speed of the feedback loop.</p>

<p>Depending on the initial state of your tests, this might take more or less time. Your first tests might even be manual. This is the bulldozer of refactoring. Very effective, but slow.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/bulldozer.jpg" alt="Bulldozer" /></p>

<h2>4. Pair or mob program</h2>

<blockquote><p>Given enough eyeballs, all bugs are shallow.</p>

<p><a href="https://en.wikipedia.org/wiki/Linus%27s_Law">Linus&rsquo;s Law</a></p></blockquote>

<p>Changing legacy code is a lot easier when you team up. First, it creates a motivating &ldquo;we&rsquo;re all in this together&rdquo; mindset. Second, it guards us against silly mistakes.</p>

<p><a href="https://en.wikipedia.org/wiki/Mob_programming">Mob programming</a>, might seem very expensive, so let me explain why it is not. Suppose you want to introduce some tests in a tricky section of code.</p>

<p>With mob programming, all the team gathers for half a day to work on this change. Together, they find and avoid most of the pitfalls. They commit a high quality change, which creates only one bug down the road.</p>

<p>Let&rsquo;s see the alternative.</p>

<p>Using solo programming, a poor programmer tries to tackle the change all by himself. He spends a few days to understand and double check all the traps he can think of. Finally, he commits his change, which results in many bugs later on. Every time a bug pops up, it interrupts someone to fix it ASAP.</p>

<p>The savings in interruptions are greater than up front cost of mob or pair programming.Â </p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/p_pvslS4gEI" frameborder="0" allowfullscreen></iframe>


<h2>5. Seams</h2>

<blockquote><p>A software seam is <em>a place where you can alter behavior in your program without editing in that place.</em></p>

<p><a href="http://wiki.c2.com/?SoftwareSeam">Michael Feathers</a></p></blockquote>

<p>This is one of the many interesting things I learned from Michael&rsquo;s book about legacy code.</p>

<p><a href="https://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=edaadc6370c2c8c9e943348d9fbdafb9"><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/legacy-code.jpg" alt="Cover of Working Effectively with Legacy Code" /></a></p>

<p>Object polymorphism is only one kind of seam. Depending on your language, many other types of seams can be available.Â </p>

<ul>
<li>Type seam for generic languages</li>
<li>Static link seam for static libraries</li>
<li>Dynamic link seam for dynamic libraries</li>
<li>&hellip;</li>
</ul>


<p>Finding seams in your program is something opportunistic. Keep in mind though that testing through seams is not the end goal. It is only a step to bootstrap the test-refactor loop and start your refactoring journey.</p>

<h2>6. Mikado Method</h2>

<p>How do you get to your end then ? How to you refactor only what&rsquo;s useful for your features ? How do you do large refactorings in baby steps ?</p>

<p>Over time, I found that the mikado method is a good answer to all these issues. The goal of the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> is to build a graph of dependent refactoring. It can then use it to perform all these refactorings one by one. Here is the mikado method by the book.</p>

<p>Before anything else, you&rsquo;ll need a large sheet of paper to draw the graph. Then repeat the following :</p>

<ol>
<li>try to do the change you want</li>
<li>If it builds and the tests pass, great, commit and you&rsquo;re done</li>
<li>Otherwise, add a node for the change you wanted to do in your mikado graph</li>
<li>Write down the compilation and test errorsÂ </li>
<li>Revert your change</li>
<li>Recurse from 1 for every compilation or test error</li>
<li>Draw a dependency arrow from the nodes of errors to the node of your initial change</li>
</ol>


<p>Once you built the full graph, tackle the refactorings from the leaves. As leafs have no dependencies, it should be easy to do and commit them.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado.jpg" alt="A Sample Mikado Graph" /></p>

<p>When I first read about the mikado method, it seemed very simple and powerful. Things got more complex when I tried to apply it. For example, the fact that some changes don&rsquo;t compile hide future test failures. That means that very often, the &ldquo;Build the graph&rdquo; and &ldquo;Walk the graph&rdquo; phases overlap. In real life, the graph evolves and changes over time.Â </p>

<p>My advice about the Mikado Method is not to take it to the letter. It&rsquo;s a fantastic communication tool. It helps not to get lost and to avoid a refactoring tunnel. It also helps to tackle refactoring as a team.</p>

<p>It is not a strict algorithm though. Build and tests are not the only way to build the graph. Very often, a bit of thinking and expert knowledge are the best tools at hand.</p>

<p><a href="https://www.amazon.com/gp/product/1617291218/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617291218&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=f7405cd74335b3cbb8b263f1a5c37c1d"><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado-book.jpg" alt="Cover of The Mikado Method book" /></a></p>

<h2>7. Bubble Context</h2>

<p>Refactoring needs to be opportunistic. Sometimes there are shortcuts in your refactoring path.</p>

<p>If you have access to a domain expert, the <a href="http://dddcommunity.org/library/evans_2011_2/2">Bubble Context</a> will cut the amount of refactoring to do. It&rsquo;s also an occasion to get rid of all the features that are in your software but that are not required anymore.Â </p>

<p>The Bubble Context originated from the <a href="http://dddcommunity.org/library/evans_2011_2/">DDD community</a>, as a way to grow a domain in an existing code base. It goes like that :</p>

<ol>
<li>Find a domain expert</li>
<li>(Re)write clean code for a very tiny sub domain</li>
<li>Protect it from the outside with an <a href="https://softwareengineering.stackexchange.com/questions/184464/what-is-an-anti-corruption-layer-and-how-is-it-used">anticorruption layer</a></li>
<li>Grow it little by little</li>
</ol>


<p>I have friends who are fans of the bubble context. It is super effective provided you have a domain expert. It is a method of choice in complex domain software.</p>

<h2>8. Strangler</h2>

<p>Bubble Context works great when refactoring domain specific code, what about the rest ? I had good results with the <a href="https://www.martinfowler.com/bliki/StranglerApplication.html">Strangler pattern</a>.</p>

<p>For example, we had to refactor a rather complex parser for an internal DSL. It was very difficult to incrementally change the old parser, so we started to build a new one aside. It would try to parse, but delegate to the old one when it failed. Little by little, the new parser was handling more and more of the grammar. When it supported all the inputs, we removed the old one.</p>

<p>The strangler is particularly well suited for refactoring technical components. They have more stable interfaces and can be very difficult to change incrementally.</p>

<h2>9. Parallel Run</h2>

<p>This is more of a trick than a long term strategy. The idea is to use the initial (legacy) version of the code as a reference for your refactoring. Run both and check that they are doing the same thing.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/railroad.jpg" alt="Parallel Railroads" /></p>

<p>Here are some variations around this idea.</p>

<p>If the code you want to refactor is side effect free, it should be easy to duplicate it before refactoring. This enables running both to check that they compute the same thing.</p>

<p>Put this in a unit test to bootstrap a test-refactor loop. You can also run both in production and log any difference. You&rsquo;ll need access to production logs &hellip; Devops teams have a refactoring advantage !</p>

<p>Here is another use of your logs. If the code writes a lot of logs, we can use them as a reference. Capture the logs of the old version, and unit test that the refactored version prints the same logs out. That&rsquo;s an unmaintainable test, but good enough to bootstrap the test-refactor loop.</p>

<p>The <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose kata</a> is a good exercise to practice this last technique.</p>

<h2>10. Dead code is better off dead</h2>

<p>You don&rsquo;t need to refactor dead code ! Again, access to production logs is a great advantage for refactoring.</p>

<p>Add logs to learn how the real code runs. If it&rsquo;s never called, then delete it. If it&rsquo;s only called with some set of values, simplify it.</p>

<h2>No silver bullet</h2>

<p>That was a whirlwind tour of the legacy code refactoring techniques I know. It&rsquo;s no promise that refactoring will become easy or fast. I hope it is a good starting point to set up and walk a refactoring plan.</p>

<p>This was the last post of a series of 3 about how to learn refactoring techniques. If you didn&rsquo;t already, check part 1 <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a> and part 2 <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">How to Start Learning the Tao of Incremental Code Refactoring Today</a>.</p>
]]></content>
  </entry>
  
</feed>
