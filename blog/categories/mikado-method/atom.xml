<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mikado-method | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/mikado-method/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-08-20T19:49:59+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Incremental Software Development Strategies for Large Scale Refactoring #2 : Baby Steps]]></title>
    <link href="http://philippe.bourgau.net/incremental-software-development-strategies-for-large-scale-refactoring-number-2-baby-steps/"/>
    <updated>2018-08-09T08:50:00+02:00</updated>
    <id>http://philippe.bourgau.net/incremental-software-development-strategies-for-large-scale-refactoring-number-2-baby-steps</id>
    <content type="html"><![CDATA[<p><a href="/incremental-software-development-strategies-for-large-scale-refactoring-number-1-constant-merciless-refactoring/">My previous post</a> was about how to get slots of time in your daily (or weekly) work to do some refactoring. I left my readers with the promise of techniques to fit the refactoring work into these small slots.</p>

<p>Obviously, it won&rsquo;t be possible to perform any refactoring of any size in this way. With a bit of discipline and know-how though, it is possible to deal with quite a lot by splitting them up.</p>

<p>Baby steps are small increments of working software. The idea is that we test, commit, integrate and even deploy every small code change ! Using baby steps, we can perform large scale refactorings little by little. Refactoring in this way might seem involved, but it&rsquo;s so much safer that it&rsquo;s <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">a no brainer once you&rsquo;ve tried it</a> ! Refactoring in baby steps can be challenging to master though.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-08-07-incremental-software-development-strategies-for-large-scale-refactoring-number-2-baby-steps/baby-steps.jpg" alt="Baby footprints. Taking really small baby steps when going through a large scale refactoring is safer" /></p>

<p>10 years ago, I used to work in a large bank in Paris. I had been dabbling on my own with <a href="https://en.wikipedia.org/wiki/Extreme_programming">eXtreme Programming</a> for a few years, when we started a small project. I was to become the informal XP coach. The project was about connecting to an online brokering service. It involved adapting an existing domain library. It went out pretty well. More precisely, we created very few bugs in production, which was very different from the norm at the time. I remember this feedback from the manager :</p>

<blockquote><p>We managed to move the code from X to Y through a succession of working baby steps ! That&rsquo;s pretty uncommon ! A manager in 2006</p></blockquote>

<p>Keep in mind that this was 10 years ago. We had not done anything special except trying to apply eXtreme Programming. Nowadays, as Continuous Integration has become mainstream these skills are becoming more common. That said, we still need to learn how to apply incremental software development to large scale refactoring. This is what I&rsquo;m going to write about today.</p>

<p>This is the seventh post in a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for large scale refactoring</a>. If you haven&rsquo;t, I encourage you to start from <a href="/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/">the beginning</a>.</p>

<h2>Team TDD Coding Dojos</h2>

<p>Learning to work in baby steps is not as complicated as it might first seem. The safest and easiest way is to setup a <a href="/blog/categories/team-randori-series/">team TDD coding dojo</a>. With its Red-Green-Refactor loop TDD sets up a baby steps rhythm. As I&rsquo;ll explain in <a href="/incremental-software-development-strategies-for-large-scale-refactoring-number-3-manage-it/">my next post</a>, baby steps work best when all the team uses them. That&rsquo;s another thing the team Coding Dojo helps with.</p>

<blockquote><p>ðŸ’¡ TDD has a baby steps rhythm baked in.</p></blockquote>

<p>We can push the learning further. For example, we can use the <a href="http://kata-log.rocks/baby-steps">baby steps constraint</a> during a few coding dojo sessions. With this constraint, we revert the code if tests fail for more than 2 minutes ! Here is a way to go at it :</p>

<ol>
<li>Setup <a href="https://www.amazon.com/Continuous-Testing-Ruby-Rails-JavaScript/dp/1934356700/ref=sr_1_4?ie=UTF8&amp;qid=1533638529&amp;sr=8-4&amp;keywords=continuous+testing">continuous testing</a> : <a href="https://www.ncrunch.net/">NCrunch</a> in <a href="https://www.microsoft.com/net">.Net</a>, <a href="https://github.com/guard/guard">Guard</a> in <a href="https://www.ruby-lang.org/fr/">Ruby</a> or <a href="http://infinitest.github.io/">Infinitest</a> in <a href="https://en.wikipedia.org/wiki/Java_(programming_language">Java</a>)</li>
<li>Only use automated refactorings or extremely simple code changes in order to &hellip;.</li>
<li>&hellip; keep the code compiling all the time &hellip;</li>
<li>&hellip; and cut the time the tests fail as much as possible</li>
</ol>


<h2>Mikado Method</h2>

<p>One way to keep the tests green all the time is to use a slightly different TDD loop, as <a href="http://natpryce.com/articles/000780.html">Nat Pryce suggests</a> :</p>

<p><a href="http://natpryce.com/articles/000780.html"><img src="http://philippe.bourgau.net/imgs/2018-08-07-incremental-software-development-strategies-for-large-scale-refactoring-number-2-baby-steps/listening-to-the-tests.png" alt="The red-green-refactor loop of TDD with an extra green arrow from failing test to refactor. This alternate TDD loop illustrates how to take baby steps with the Mikado Method" /></a></p>

<div class="image-credits">From <a href="http://natpryce.com">Nat Pryce's</a> <a href="http://natpryce.com/articles/000780.html">blog</a></div>


<br>


<p>Here is how it goes.Â </p>

<ol>
<li>Add a new failing testÂ </li>
<li>If it&rsquo;s trivial to fix, fix it. We are done</li>
<li>If not, see what&rsquo;s missing in the code</li>
<li>Comment the test to get back to a green state</li>
<li>Refactor the code to add what&rsquo;s missing (and use other tests if needed)</li>
<li>Uncomment the test</li>
<li>Repeat from step 2</li>
</ol>


<p>When doing this at the scale of a real life story or feature, we&rsquo;d use <code>git stash</code> instead of comments. This way of working has a name, it&rsquo;s called the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a>. It is at the heart of making baby steps work in real life.</p>

<blockquote><p>ðŸ’¡ The Mikado Method is at the heart of making baby steps work in real life</p></blockquote>

<h2>Take a break</h2>

<p>With TDD and the Mikado Method we can put the refactoring on pause. We can perform a small increment of the refactoring, commit and deploy it &hellip; and pause ! We&rsquo;ll work on business features for a while, and resume the refactoring later on.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-08-07-incremental-software-development-strategies-for-large-scale-refactoring-number-2-baby-steps/coffee-break.jpg" alt="A cup of coffee next to a computer. Developers can pause their large scale refactoring if they work in small enough baby steps" /></p>

<p>When done well, it feels slow. We have to remember that the alternative is to convince business people of prioritizing a refactoring &hellip; As we&rsquo;ll regularly ship baby steps of a large scale refactoring, we&rsquo;ll know we&rsquo;re on the good track !</p>

<h2>More to come</h2>

<p>Unfortunately, even with bandwidth and skills, we are not there yet &hellip; It&rsquo;s one thing for developers to do incremental software development of large scale refactoring on their own. It&rsquo;s another to do it as a team !</p>

<p>This was the seventh post in a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for large scale refactoring</a>. <a href="/incremental-software-development-strategies-for-large-scale-refactoring-number-3-manage-it/">Next post</a> will be about how to manage constant merciless refactoring and baby steps as a team.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reducing the risks of large organization changes with the Mikado Method - part 3]]></title>
    <link href="http://philippe.bourgau.net/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-3/"/>
    <updated>2018-02-22T08:53:00+01:00</updated>
    <id>http://philippe.bourgau.net/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-3</id>
    <content type="html"><![CDATA[<p>In the <a href="/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-1/">previous posts</a>, I presented how to use the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> to large organization changes. Drawn from the programming world, this technique keeps a low transformation <a href="https://en.wikipedia.org/wiki/Work_in_process">WIP</a>. In theory, this should reduce risk and the time to see return on investment. Let&rsquo;s see the pros and cons in more detail.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-01-24-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-3/mikado-weighter.jpg" alt="A weighting machine comparing big bang and midado" /></p>

<h2>An experiment culture</h2>

<p>A first interesting point is the &ldquo;Try &ndash; Revert&rdquo; attitude. No one is signing with his blood that the change will have to succeed ! It&rsquo;s liberating for everyone to have to try its best instead of having to succeed at all costs. In fact, it&rsquo;s an opportunity to show a &ldquo;right to fail&rdquo; mindset. (You can read more about the topic <a href="/blog/categories/agile-transformations-fail-series/">here</a>). It&rsquo;s a clear message that leaders are proponents of experiments.</p>

<blockquote><p>ðŸ’¡ Transforming large organization with the Mikado Method shows a &ldquo;right to fail&rdquo; mindset.</p></blockquote>

<p>The flip side of that, is that people might not like to try Scrum 7 times before adopting it definitely. Plus switching process every month will not be very productive. Here is what we can do about these problems.Â </p>

<p>As I read in <a href="https://www.amazon.com/Freedom-Inc-Employees-Business-Productivity/dp/0307409384/ref=sr_1_sc_1?ie=UTF8&amp;qid=1516857037&amp;sr=8-1-spell&amp;keywords=isac+getz">Freedom, Inc.</a> &ldquo;It&rsquo;s not that people don&rsquo;t like to change, its that they don&rsquo;t like to <em>be</em> changed !&rdquo;. If a transformation teams manages all the change initiative top down, people will hate it. Hopefully, the mikado graph is a unique collaboration tool. Start by presenting the method and sharing a blank graph. Ask everyone to build it together. Then let the teams handle their own part of the graph. Here is an example. Suppose a team needs to be able to integrate every hour. Add this goal to the mikado, and hand the responsibility to get there to this team. As <a href="https://www.ted.com/talks/dan_pink_on_motivation?language=en#t-195602">Daniel Pink</a> said, autonomy and mastery are key motivators.</p>

<p>We should also pay special attention to how we name mikado (sub) goals. If the general goal is to adopt <a href="https://less.works/">LeSS</a>, jumping in and out of LeSS will be very painful ! Instead of &ldquo;How&rdquo; goals, we should use specific &ldquo;What&rdquo; goals. For example, we could replace &ldquo;Adopting LeSS&rdquo; with &ldquo;All teams integrate in less than 10 minutes&rdquo;. It is a lot easier (and faster) to try to integrate in 10 minutes for a day. In one day, we should know if it works, and if not, what&rsquo;s blocking. In this case, experiments will be standard improvement items in the backlogs of teams. Teams could try to integrate every 10 minutes by hand for example !</p>

<p><a href="http://noop.nl/2015/06/success-and-failure.html"><img src="http://philippe.bourgau.net/imgs/2018-01-24-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-3/celebration-grid.jpg" alt="The Management 3.0 celebration grid poster" /></a><div class="image-credits"><a href="http://noop.nl/2015/06/success-and-failure.html">Original Poster</a> By Jurgen Appelo</div></p>

<h2>Reduced WIP</h2>

<p>In fact, it lets people work on smaller changes, one at a time. I can think of two direct advantages of small changes. First, it does not disrupt the rest of the organization, letting it deliver as it used to. Second, it&rsquo;s a lot less stressful for the people, who then have more energy to focus on the experiment.</p>

<p>Another point is that less things are being changed at the same time. After reverting previous attempts, less parts of the organization are being changed. There&rsquo;ll be no teams halfway in the change waiting for fixes to their impediments. As usual, reducing WIP brings many advantages :</p>

<ul>
<li>It requires less coaches, as they will only concentrate on areas where they can drive the change to its end.</li>
<li>It removes the synchronization overhead of different teams working on the same problem.</li>
</ul>


<h2>What about speed ?</h2>

<p>I can hear you think &ldquo;But that&rsquo;s going to take forever !&rdquo; It is quite the opposite. Here is why :</p>

<ul>
<li>The first completed changes will be root problems. Focusing on these will bring general improvement to all the organization. The state of the rest of the organization does not matter. The path you used to discover this root problem does not matter either. Fixing this root problem is likely to bring improvement to all the teams !</li>
<li>As the graph unravels, we can use it to start independent change initiatives in parallel ! This is a classic way to speed up code refactoring that transposes to organizations. The graph gives you a clear map of which problems are independent. Perform changes that won&rsquo;t conflict in parallel.</li>
<li>There are quick wins also. You don&rsquo;t need to be dogmatic about reverting. Suppose you tried something that brought improvement, but that uncovers a deeper problem. If the people felt an improvement and prefer to continue the new way, let them !</li>
</ul>


<blockquote><p>ðŸ’¡ Transforming large organization with the Mikado Method helps to parallelize work.</p></blockquote>

<p>Granted, if the goal is just to move to &ldquo;Agile&rdquo;, then it might be slower than switching all teams to &ldquo;Agile method X&rdquo;. This is only faster on paper though. If you want more details about why becoming agile takes time, I encourage you to read these <a href="/blog/categories/agile-transformations-fail-series/">other blog posts</a>. Plus, as I said above we should prefer &ldquo;What&rdquo; goals.</p>

<h2>Continuous improvement</h2>

<p>One final advantage I see with this technique is that it&rsquo;s sustainable. As it&rsquo;s a lot less stressful than a typical large re-org, it is possible to keep it going all the time ! It&rsquo;s a gateway to continuous improvement. It&rsquo;s no wonder Toyota (see <a href="https://www.amazon.com/Toyota-Kata-Managing-Improvement-Adaptiveness/dp/0071635238/ref=sr_1_1?ie=UTF8&amp;qid=1516857324&amp;sr=8-1&amp;keywords=toyota+kata">Toyota Kata</a>) people say that the <a href="http://www-personal.umich.edu/~mrother/The_Improvement_Kata.html">improvement kata</a> is their main management tool !</p>

<p><a href="https://www.amazon.com/Mikado-Method-Ola-Ellnestam/dp/1617291218/ref=sr_1_1"><img src="http://philippe.bourgau.net/imgs/2018-01-24-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-3/mikado-method-cover.jpg" alt="The cover of the 'Mikado Method' book" /></a></p>

<h2>Closing thought</h2>

<p>It&rsquo;s funny how two practices like the Mikado Method and the Improvement Kata are the same idea ! I also noticed similarities with thefirst <a href="https://blog.hubspot.com/sales/habits-of-highly-effective-people-summary">&ldquo;Be Proactive&rdquo; practice</a> of Stephen R. Covey&rsquo;s <a href="https://www.amazon.com/Habits-Highly-Effective-People-Powerful/dp/1451639619/ref=sr_1_3?ie=UTF8&amp;qid=1516857434&amp;sr=8-3&amp;keywords=7+habits+of+highly+effective+people">7 habits of highly effective people</a>. Could it be the same idea again ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reducing the risks of large organization changes with the Mikado Method - part 2]]></title>
    <link href="http://philippe.bourgau.net/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-2/"/>
    <updated>2018-02-15T06:45:00+01:00</updated>
    <id>http://philippe.bourgau.net/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-2</id>
    <content type="html"><![CDATA[<p>In the <a href="/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-1/">previous post</a>, I presented both large scale code and organization changes. I highlighted how they face similar difficulties of huge <a href="https://en.wikipedia.org/wiki/Work_in_process">Work In Progress</a>. Let&rsquo;s see how programmers deal with these problems.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-01-22-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-2/mind-your-wip.jpg" alt="A drawing of a wipe, with the text &quot;Mind your WIP&quot;" /></p>

<h2>The mikado method algorithm</h2>

<p>The <a href="https://mikadomethod.wordpress.com/">mikado method</a> is a programming technique to perform large <a href="https://en.wikipedia.org/wiki/Code_refactoring">code refactoring</a> one step at a time. It fixes the problematic situation we raised at the beginning of these posts. It enables developers to integrate their work with their teammates' continuously. It allows to build features and do the refactoring in parallel. Developers can also pause a mikado refactoring for a while if needed. On top of all this, it makes it easier for the full team to collaborate on the same refactoring.</p>

<blockquote><p>ðŸ’¡ Developers can pause a Mikado Method refactoring for a while if needed.</p></blockquote>

<p>Here is how it goes, but you can get a more detailed (and technical) description <a href="/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/">here</a>.</p>

<ol>
<li>Try to do the change you want</li>
<li>If it the tests pass, great, you&rsquo;re done</li>
<li>Otherwise, add a node for the change you wanted to do in your mikado graph</li>
<li>Write down the errors you faced</li>
<li>Revert your change</li>
<li>Recurse from 1 for every error</li>
<li>Draw a dependency arrow from the nodes of errors to the node of your initial change</li>
</ol>


<p>The catch is that developers should revert the work they could not finish to move on !</p>

<h2>How to apply it to an organization change</h2>

<p>In some way, the Mikado Method is very similar to the <a href="http://www-personal.umich.edu/~mrother/The_Improvement_Kata.html">improvement kata</a>. The flow of the Improvement kata goes on like that :</p>

<ol>
<li>Determine a target condition</li>
<li>Try to work with the target condition in place</li>
<li>If it works, you&rsquo;re done</li>
<li>Otherwise, understand the main impediment, and revert to the old way of doing things</li>
<li>Work to remove the impediment</li>
<li>Start again from step 2</li>
</ol>


<p>Have a look at <a href="http://philippe.bourgau.net/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-1/">these blog posts</a> for a more practical presentation of the improvement kata.</p>

<blockquote><p>ðŸ’¡ The Mikado Method and the Improvement Kata are more than similar.</p></blockquote>

<p>Granted, the Mikado method and the improvement kata look similar. They are in fact more than similar. The improvement kata does not prescribe how you should fix your impediments. What&rsquo;s not explicit is that we can use it recursively to fix impediments ! That makes it almost identical to the Mikado Method, but for organization instead of code. It won&rsquo;t be a surprise to know that some companies have used the improvement kata for that. For example, <a href="https://www.amazon.com/Practical-Approach-Large-Scale-Agile-Development/dp/0321821726?pd_rd_wg=UdZ7n&amp;pd_rd_r=ea4d5912-c825-432a-b633-ac6822a475f4&amp;pd_rd_w=rQ1LZ&amp;ref_=pd_gw_psimh&amp;pf_rd_r=0N5KT332R3TD0DWK8FM0&amp;pf_rd_p=a1e8e44e-a6a8-5785-afd0-7f174f0d74f9">HP used it to drive its Laser Jet team transformation</a>. Others have already used the <a href="http://nomad8.com/organisational-change-with-mikado/">Mikado Method for organization transformation</a>.</p>

<p><a href="http://nomad8.com/organisational-change-with-mikado/"><img src="http://philippe.bourgau.net/imgs/2018-01-22-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-2/orga-mikado-post-its.jpg" alt="Extract of the orga mikado graph used by the Sandy Mamoli" /></a><div class="image-credits"><a href="http://nomad8.com/organisational-change-with-mikado/">Original Post</a> by Sandy Mamoli</div></p>

<p>Suppose your organization wants to move to full <a href="https://en.wikipedia.org/wiki/Continuous_integration">Continuous Integration</a>. It could start by trying to integrate all their devs in 10 minutes on a small group of teams. If it works, fine, other large teams can try it as well. Let&rsquo;s see what to do if it fails though. Thanks to a <a href="/blog/categories/retrospectives/">retrospective</a> teams understand that they need to master CI themselves first. In this case, they could revert large scale CI, and have one of the teams try to do continuous integration. If it works, fine, another team can try it too. If it does not, they&rsquo;ll do a post-mortem of some sort to understand the root issue, and work on it. For example, here the main impediment could be a coupled architecture. The fun thing would be to apply the Mikado Method to do this refactoring ðŸ˜‰.</p>

<p>As with the Mikado Method, it is possible to draw an organization change Mikado graph along the way :</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-01-22-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-2/sample-mikado.png" alt="The mikado graph for the story above" /></p>

<p>The graph is a living artifact. As we try and revert new experiments, we should expand and collapse the graph. This creates a global and shared view of the state of the change. Needless to say that this is great for collaboration.</p>

<h2>To be continued (again)</h2>

<p>This was part 2 of a <a href="/blog/categories/mikado-method-organization-series/">series on applying the Mikado Method to organization changes</a>. I&rsquo;ll end this series up with <a href="/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-3/">next post</a>, where I&rsquo;ll go through the pros and cons of the approach.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reducing the risks of large organization changes with the Mikado Method - part 1]]></title>
    <link href="http://philippe.bourgau.net/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-1/"/>
    <updated>2018-02-08T11:53:00+01:00</updated>
    <id>http://philippe.bourgau.net/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-1</id>
    <content type="html"><![CDATA[<p>Large scale agile transformations are often painful, stressful and &hellip; failed ! Mixing the <a href="http://www-personal.umich.edu/~mrother/The_Improvement_Kata.html">Improvement Kata</a> and the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> can make them more successful.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-01-21-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-1/mikado.jpg" alt="A drawing of entangled mikado sticks" /></p>

<p>The Mikado Method is a programming technique to reduce the risks of large code changes. Let&rsquo;s see how to apply it to organization changes.</p>

<h2><a href="https://dzone.com/articles/if-it-aint-broke-dont-fix-it">&ldquo;If it&rsquo;s not broke, don&rsquo;t touch it !&rdquo;</a></h2>

<p>A lot of programmers have learned this maxim the hard way. Here is how it goes.</p>

<p>It all starts with a shitty piece of code that gets into everyone&rsquo;s way as soon as they have to deal with it. It&rsquo;s badly written, difficult to understand, and very difficult to change. One day, a brave programmer suggests to rewrite or revamp it so that it gets easy to work with. This is not a small task, but after some discussion and negotiation, he gets a &lsquo;go&rsquo; from his team.</p>

<p>A few hours in this refactoring, he discovers that he needs to adapt other pieces of the code before he moves on. He leaves his work in progress as it is, and starts to change these pre-requisites. Unfortunately, these too have pre-requisite. Little by little, he builds up <a href="https://en.wikipedia.org/wiki/Work_in_process">work in progress</a>(WIP) on different parts of the code. He still has nothing working though ! He&rsquo;s beginning to have troubles keeping track of all his WIP. On top of that, he&rsquo;s wasting time integrating the work done by his colleagues with his WIP. As days pass by with nothing to show, his team begins to doubt that he&rsquo;ll be able to bring this to its end ! The situation as a whole accumulates an awful lot of stress on the developer. In the end, it is pretty likely that the team will abandon the whole thing.</p>

<blockquote><p>ðŸ’¡ By never changing the code, programmers make it even harder to change</p></blockquote>

<p>The problem with this maxim is that by never changing the code, programmers make it even harder to change. In the end, this makes new features too expensive to build, which is pretty bad for the business.</p>

<p>Let&rsquo;s see how this related to large organization changes.</p>

<h2>The typical large scale agile transformation</h2>

<p>It all starts when a leader decides that Agile is the way to go. It could be because everyone is doing it or that he got convinced by someone. It could also be because consultants sold him a 10% productivity increase. The reason does not matter. What matters is that in a few months, all the company should switch to an Agile method. Large groups of people will have to switch to <a href="https://www.agilealliance.org/glossary/scrum-of-scrums/">Scrum of Scrum</a>, <a href="https://less.works/">LeSS</a>, <a href="http://www.scaledagileframework.com/">SAFe</a> or any other framework. Even if the transformation is split in product teams, these will still be big.</p>

<p>One great thing about these frameworks is that they show problems. After a few sprints people discover that they have troubles delivering incrementally. After analysis, they understand another deeper problem. Examples : bad management, legacy code, outdated tooling, bad underlying processes &hellip; As Agile is the new <a href="https://sourcemaking.com/antipatterns/golden-hammer">Golden Hammer</a>, the teams responsible of these problems in turn jump to Agile X method. Unfortunately, these too might fall into deeper problems &hellip; and the pattern repeats itself. Meanwhile, the top down transformation team sticks its own objectives. It continues to onboard new product teams to Agile, fueling the mess that is spreading.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-01-21-reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-1/hammer.jpg" alt="A golden hammer" /></p>

<p>At any moment, a very large proportion of the people in the company are in a state of transformation. This is pretty bad for productivity. What is even worse is that they are all facing the same root problems. They are all blocked in a sub-optimal state, impeded by the root problems. Following agile principles, they all start similar initiatives to workaround these issues ! They then need to coordinate with other teams, to avoid duplicate efforts. On top of that, as agile newbies, all these teams need coaches to help them at the same time.</p>

<blockquote><p>ðŸ’¡ Large scale Agile transformations are too often stressful for everyone &hellip;</p></blockquote>

<p>Needless to say that this situation is pretty stressful for everyone. It costs a lot, in productivity and consulting, for results yet to come. Despite reassurance that things will get better, the leader&rsquo;s trust is eroding.</p>

<p>The story ends bad when it goes on for too long. When the leader loses faith in the initiative, he cancels it, and goes back to the old ways. That&rsquo;s what we call the <a href="https://www.google.fr/search?q=agile+hangover">Agile hangover</a> : &ldquo;We tried it, but it was a mess. It does not work for us.&rdquo;</p>

<h2>To be continued</h2>

<p>As you can see, the two situations have a lot in common. Programmers have invented the Mikado Method to deal with large scale code changes. This was the first post of a <a href="/blog/categories/mikado-method-organization-series/">series about the Mikado Method and large scale organization changes</a>. In <a href="/reducing-the-risks-of-large-organization-changes-with-the-mikado-method-part-2/">next post</a>, we&rsquo;ll detail this technique, and see how to apply it on organization changes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 things to know that will make you great at refactoring legacy code]]></title>
    <link href="http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/"/>
    <updated>2017-07-28T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>We write tons of <a href="https://en.wikipedia.org/wiki/Legacy_code">legacy code</a> everyday. Experienced developers understand that legacy code is not something special. Legacy code is our daily bread and butter.</p>

<p>Should we abandon all hope as we enter legacy code ? Would that be professional ? In the end, code is only a bunch of bytes, somewhere on a drive. We are the software professionals. We need to deal with that.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/keep-calm-and-take-the-power-back-4.jpg" alt="Keep Calm and Take The Power Back" /></p>

<h2>1. Master non legacy refactoring first</h2>

<p>Please calm down before this &ldquo;Bring &lsquo;em out&rdquo; energy goes to your head.</p>

<p>I did not say that refactoring legacy code is easy. Legacy code can bite &hellip; bad. I&rsquo;ve been in teams which literally spent nights fixing a bad refactoring gone to production &hellip;</p>

<p>Before you can refactor legacy code, you need to be good at refactoring new code. We all learned to swim in the shallow pool, it&rsquo;s the same with refactoring. Mastering green code refactoring will help you when tackling legacy code.</p>

<p>First, you&rsquo;ll know the ideal you&rsquo;d like to get to. Knowing how productive a fast feedback loop is will motivate you to keep on refactoring.</p>

<p>Second, you&rsquo;ll have a better idea of the baby steps to take you through a tricky refactoring.</p>

<p>If you are not yet at ease with greenfield refactoring, have a look at <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">my previous post</a>.</p>

<h2>2. Understand that refactoring legacy code is different</h2>

<p>The next thing to remember is that refactoring legacy code is different. Let&rsquo;s assume <a href="https://stackoverflow.com/questions/4174867/what-is-the-definition-of-legacy-code">Michael Feather&rsquo;s definition of legacy code</a> : &ldquo;Code without tests&rdquo;. Getting rid of legacy code means adding automated tests.</p>

<p>Unfortunately, trying to force push unit tests in legacy code usually results in a mess. It introduces lot&rsquo;s of artificial mocks in a meaningless design. It also creates brittle and unmaintainable tests. More harm than good. This might be an intermediate step, but it is usually not the quickest way to master your legacy code beast.</p>

<p>Here are alternatives I prefer.</p>

<h2>3. Divide and conquer</h2>

<p>This is the most straightforward way to deal with legacy code. It&rsquo;s an iterative process to repeat until you get things under control. Here is how it goes :</p>

<p>(1) Rely on the tests you have, (2) to refactor enough, (3) to test sub-parts in isolation. (4) Repeat until you are happy with the speed of the feedback loop.</p>

<p>Depending on the initial state of your tests, this might take more or less time. Your first tests might even be manual. This is the bulldozer of refactoring. Very effective, but slow.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/bulldozer.jpg" alt="Bulldozer" /></p>

<h2>4. Pair or mob program</h2>

<blockquote><p>Given enough eyeballs, all bugs are shallow.</p>

<p><a href="https://en.wikipedia.org/wiki/Linus%27s_Law">Linus&rsquo;s Law</a></p></blockquote>

<p>Changing legacy code is a lot easier when you team up. First, it creates a motivating &ldquo;we&rsquo;re all in this together&rdquo; mindset. Second, it guards us against silly mistakes.</p>

<p><a href="https://en.wikipedia.org/wiki/Mob_programming">Mob programming</a>, might seem very expensive, so let me explain why it is not. Suppose you want to introduce some tests in a tricky section of code.</p>

<p>With mob programming, all the team gathers for half a day to work on this change. Together, they find and avoid most of the pitfalls. They commit a high quality change, which creates only one bug down the road.</p>

<p>Let&rsquo;s see the alternative.</p>

<p>Using solo programming, a poor programmer tries to tackle the change all by himself. He spends a few days to understand and double check all the traps he can think of. Finally, he commits his change, which results in many bugs later on. Every time a bug pops up, it interrupts someone to fix it ASAP.</p>

<p>The savings in interruptions are greater than up front cost of mob or pair programming.Â </p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/p_pvslS4gEI" frameborder="0" allowfullscreen></iframe>


<h2>5. Seams</h2>

<blockquote><p>A software seam is <em>a place where you can alter behavior in your program without editing in that place.</em></p>

<p><a href="http://wiki.c2.com/?SoftwareSeam">Michael Feathers</a></p></blockquote>

<p>This is one of the many interesting things I learned from Michael&rsquo;s book about legacy code.</p>

<p><a href="https://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=edaadc6370c2c8c9e943348d9fbdafb9"><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/legacy-code.jpg" alt="Cover of Working Effectively with Legacy Code" /></a></p>

<p>Object polymorphism is only one kind of seam. Depending on your language, many other types of seams can be available.Â </p>

<ul>
<li>Type seam for generic languages</li>
<li>Static link seam for static libraries</li>
<li>Dynamic link seam for dynamic libraries</li>
<li>&hellip;</li>
</ul>


<p>Finding seams in your program is something opportunistic. Keep in mind though that testing through seams is not the end goal. It is only a step to bootstrap the test-refactor loop and start your refactoring journey.</p>

<h2>6. Mikado Method</h2>

<p>How do you get to your end then ? How to you refactor only what&rsquo;s useful for your features ? How do you do large refactorings in baby steps ?</p>

<p>Over time, I found that the mikado method is a good answer to all these issues. The goal of the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> is to build a graph of dependent refactoring. It can then use it to perform all these refactorings one by one. Here is the mikado method by the book.</p>

<p>Before anything else, you&rsquo;ll need a large sheet of paper to draw the graph. Then repeat the following :</p>

<ol>
<li>try to do the change you want</li>
<li>If it builds and the tests pass, great, commit and you&rsquo;re done</li>
<li>Otherwise, add a node for the change you wanted to do in your mikado graph</li>
<li>Write down the compilation and test errorsÂ </li>
<li>Revert your change</li>
<li>Recurse from 1 for every compilation or test error</li>
<li>Draw a dependency arrow from the nodes of errors to the node of your initial change</li>
</ol>


<p>Once you built the full graph, tackle the refactorings from the leaves. As leafs have no dependencies, it should be easy to do and commit them.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado.jpg" alt="A Sample Mikado Graph" /></p>

<p>When I first read about the mikado method, it seemed very simple and powerful. Things got more complex when I tried to apply it. For example, the fact that some changes don&rsquo;t compile hide future test failures. That means that very often, the &ldquo;Build the graph&rdquo; and &ldquo;Walk the graph&rdquo; phases overlap. In real life, the graph evolves and changes over time.Â </p>

<p>My advice about the Mikado Method is not to take it to the letter. It&rsquo;s a fantastic communication tool. It helps not to get lost and to avoid a refactoring tunnel. It also helps to tackle refactoring as a team.</p>

<p>It is not a strict algorithm though. Build and tests are not the only way to build the graph. Very often, a bit of thinking and expert knowledge are the best tools at hand.</p>

<p><a href="https://www.amazon.com/gp/product/1617291218/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617291218&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=f7405cd74335b3cbb8b263f1a5c37c1d"><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado-book.jpg" alt="Cover of The Mikado Method book" /></a></p>

<h2>7. Bubble Context</h2>

<p>Refactoring needs to be opportunistic. Sometimes there are shortcuts in your refactoring path.</p>

<p>If you have access to a domain expert, the <a href="http://dddcommunity.org/library/evans_2011_2/2">Bubble Context</a> will cut the amount of refactoring to do. It&rsquo;s also an occasion to get rid of all the features that are in your software but that are not required anymore.Â </p>

<p>The Bubble Context originated from the <a href="http://dddcommunity.org/library/evans_2011_2/">DDD community</a>, as a way to grow a domain in an existing code base. It goes like that :</p>

<ol>
<li>Find a domain expert</li>
<li>(Re)write clean code for a very tiny sub domain</li>
<li>Protect it from the outside with an <a href="https://softwareengineering.stackexchange.com/questions/184464/what-is-an-anti-corruption-layer-and-how-is-it-used">anticorruption layer</a></li>
<li>Grow it little by little</li>
</ol>


<p>I have friends who are fans of the bubble context. It is super effective provided you have a domain expert. It is a method of choice in complex domain software.</p>

<h2>8. Strangler</h2>

<p>Bubble Context works great when refactoring domain specific code, what about the rest ? I had good results with the <a href="https://www.martinfowler.com/bliki/StranglerApplication.html">Strangler pattern</a>.</p>

<p>For example, we had to refactor a rather complex parser for an internal DSL. It was very difficult to incrementally change the old parser, so we started to build a new one aside. It would try to parse, but delegate to the old one when it failed. Little by little, the new parser was handling more and more of the grammar. When it supported all the inputs, we removed the old one.</p>

<p>The strangler is particularly well suited for refactoring technical components. They have more stable interfaces and can be very difficult to change incrementally.</p>

<h2>9. Parallel Run</h2>

<p>This is more of a trick than a long term strategy. The idea is to use the initial (legacy) version of the code as a reference for your refactoring. Run both and check that they are doing the same thing.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/railroad.jpg" alt="Parallel Railroads" /></p>

<p>Here are some variations around this idea.</p>

<p>If the code you want to refactor is side effect free, it should be easy to duplicate it before refactoring. This enables running both to check that they compute the same thing.</p>

<p>Put this in a unit test to bootstrap a test-refactor loop. You can also run both in production and log any difference. You&rsquo;ll need access to production logs &hellip; Devops teams have a refactoring advantage !</p>

<p>Here is another use of your logs. If the code writes a lot of logs, we can use them as a reference. Capture the logs of the old version, and unit test that the refactored version prints the same logs out. That&rsquo;s an unmaintainable test, but good enough to bootstrap the test-refactor loop.</p>

<p>The <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose kata</a> is a good exercise to practice this last technique.</p>

<h2>10. Dead code is better off dead</h2>

<p>You don&rsquo;t need to refactor dead code ! Again, access to production logs is a great advantage for refactoring.</p>

<p>Add logs to learn how the real code runs. If it&rsquo;s never called, then delete it. If it&rsquo;s only called with some set of values, simplify it.</p>

<h2>No silver bullet</h2>

<p>That was a whirlwind tour of the legacy code refactoring techniques I know. It&rsquo;s no promise that refactoring will become easy or fast. I hope it is a good starting point to set up and walk a refactoring plan.</p>

<p>This was the last post of a series of 3 about how to learn refactoring techniques. If you didn&rsquo;t already, check part 1 <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a> and part 2 <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">How to Start Learning the Tao of Incremental Code Refactoring Today</a>.</p>
]]></content>
  </entry>
  
</feed>
