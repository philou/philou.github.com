<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rspec | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2013-06-07T07:10:23+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Display full backtraces in rspec]]></title>
    <link href="http://philippe.bourgau.net/display-full-backtraces-in-rspec/"/>
    <updated>2013-06-07T06:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/display-full-backtraces-in-rspec</id>
    <content type="html"><![CDATA[<p>I use <a href="http://rspec.info/">rspec</a> a lot. I thinks it's a great testing framework.</p>

<p>In order to get shorter error output, rspec cleans backtraces from outside code. Here are all the patterns that are removed from the full backtrace :</p>

<p><code>ruby
DEFAULT_BACKTRACE_PATTERNS = [
  /\/lib\d*\/ruby\//,
  /org\/jruby\//,
  /bin\//,
  %r|/gems/|,
  /spec\/spec_helper\.rb/,
  /lib\/rspec\/(core|expectations|matchers|mocks)/
]
</code></p>

<p>Most of the time, that's great. Sometimes though, we get messages that seem completly unrelated to the code. Even worse, we might get misleading messages, such as "method called with unexpected number of arguments" that does not refer to the code in the backtrace, but to some other library code ...</p>

<p>I thought it would be nice if we could switch this cleaning off sometimes. Here is how I did this :</p>

<p>```ruby
RSpec.configure do |config|</p>

<p>  # RSpec automatically cleans stuff out of backtraces;
  # sometimes this is annoying when trying to debug something e.g. a gem
  if ENV['FULLBACKTRACES'] == 'true'</p>

<pre><code>config.backtrace_clean_patterns = []
</code></pre>

<p>  end</p>

<p>  # some other configuration here</p>

<p>end
```</p>

<p>This way, it is still possible to call rspec as before to get the standard behaviour, but it is now possible to specify the FULLBACKTRACES variable to get full backtraces.</p>

<p><code>
FULLBACKTRACES=true bundle exec rspec spec
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to stub around a call to the original method with rspec ?]]></title>
    <link href="http://philippe.bourgau.net/how-to-stub-around-a-call-to-the-original-method-with-rspec/"/>
    <updated>2013-04-19T07:05:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-stub-around-a-call-to-the-original-method-with-rspec</id>
    <content type="html"><![CDATA[<p>Rspec mocks now features a 'and_call_original' method to create simple proxy mocks. But how could we build more complex proxies ?</p>

<p>For the sake of the subject, let's take an example that is not a testing best practice, but that everybody will understand. Suppose you want to simulate a faulty network in your tests. You'd like to stub Net::HTTP.get so that it raises errors from time to time. Here is what you could do</p>

<p><code>ruby
i = 0
original_get = Net::HTTP.method(:get)
Net::HTTP.stub(:get) do |*args, &amp;block|
  i = i+1
  raise RuntimeError.new("network down") if i%3 == 0
  original_get.call(*args, &amp;block)
end
</code></p>

<p>Note the block is taken into account, in this example, it does not matter so much, but forgetting it can bring up really strange issues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stub_model and mock_model]]></title>
    <link href="http://philippe.bourgau.net/stubmodel-and-mockmodel/"/>
    <updated>2012-04-16T00:00:00+02:00</updated>
    <id>http://philippe.bourgau.net/stubmodel-and-mockmodel</id>
    <content type="html"><![CDATA[<p>I decided to stop using stub_model and mock_model. I do not use them enough to get fluent with them. Everytime I have to deal with them, something breaks in an unexpected way. I just decided to stand with good old stubs.</p>


<p>I am also thinking of switching to RR (double ruby) and to use proxy objects to get simplify mocking even further. Did you try it ?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Order of execution of before blocks in RSpec]]></title>
    <link href="http://philippe.bourgau.net/order-of-execution-of-before-blocks-in-rspec/"/>
    <updated>2012-01-05T00:00:00+01:00</updated>
    <id>http://philippe.bourgau.net/order-of-execution-of-before-blocks-in-rspec</id>
    <content type="html"><![CDATA[<p>I discovered that before blocks in RSpec's examples are executed in the order they are declared. There is no great deal about it, but it can be useful when using shared examples.<br />In rspec 1.3.8, it is possible to simulate shared examples with parameters by using instance variables instead. This is were it gets useful to know the order of evaluation of before blocks. As an example :<p />
```ruby
shared_example_for "anything" do
  before :each do
    @thing.should_not be_nil
  end
end

describe "A monkey wrench" do
  it_should_behave_like "anything"
   before :each do
    @thing = MonkeyWrench.new
  end
end
```
<p />The previous example will fail, whereas the next one will succeed.<p />
```ruby
describe "A monkey wrench" do
  before :each do
    @thing = MonkeyWrench.new
  end
  it_should_behave_like "anything"
end
```
<p />That is the before blocks nested in shared examples still evaluate in the order of declaration.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rspec messes up stubs and expectations]]></title>
    <link href="http://philippe.bourgau.net/rspec-messes-up-stubs-and-expectations/"/>
    <updated>2011-10-20T00:00:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-messes-up-stubs-and-expectations</id>
    <content type="html"><![CDATA[<p>Here is an example showing the issue :<p />
```ruby
before :each do
  @car = stub("a car")
  @car.stub(:move)
end
it "should be possible to mix stubbing and expectations" do
  @car.should_receive(:move).once

  2.times { @car.move }
end
```
<p />This example should obviously fail, but it passes ! Here is a working (failing) version :<p />
```ruby
before :each do
  @car = stub("a car")
 end
it "should be possible to mix stubbing and expectations" do
  @car.should_receive(:move).once

  2.times { @car.move }
end
```
<p /> I am using rspec 1.3.0. Did you fall into the same issues ? Is this fixed in rspec 2 ?</p>

]]></content>
  </entry>
  
</feed>
