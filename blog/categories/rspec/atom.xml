<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rspec | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2013-07-25T07:34:11+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hitting the middle ground between classicist and mockist TDD]]></title>
    <link href="http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd/"/>
    <updated>2013-06-18T08:55:00+02:00</updated>
    <id>http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd</id>
    <content type="html"><![CDATA[<p>From <a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler&rsquo;s point of view</a>, I must have been a mockist. With using mocks extensively comes quite a few advantages :</p>

<ul>
<li>test failures often pinpoint the falsy code</li>
<li>easier test organisation mimicking that of the code</li>
<li>faster tests</li>
<li>simpler test initialization</li>
</ul>


<p>Mocks also have their own problems, but mostly :</p>

<ul>
<li>especialy with dynamicaly typed languages, a mock for class A might not implement the same methods than the real class A, but the test might be passing though ! This ampers refactoring with a longer feedback loop and mock setup rewriting</li>
</ul>


<p>That&rsquo;s what always bothered me. Eventually I tried a combinaison of techniques that seem to work well together and provides most of the best of both worlds.</p>

<ul>
<li>extensive use of factories (with <a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a>) to simplify setup</li>
<li>use of an <a href="http://www.sqlite.org/inmemorydb.html">in memory sqlite database</a> to get a fast full working db</li>
<li>implement fully functional fakes for some parts of the system</li>
<li>carefull use of mocks, inspired from <a href="http://blog.rubybestpractices.com/posts/gregory/052-issue-20-thoughts-on-mocking.html">Gregory Brown&rsquo;s thoughts on mocks</a>

<ul>
<li>when a test is too slow</li>
<li>to cut off a dependency to a subsystem that is not available in a unit test</li>
<li>to simplify overly long test data setup</li>
</ul>
</li>
<li>use of test proxies (as in <a href="https://github.com/rr/rr">rr</a>) to inject specific behaviour or to perform specific checks without modifying the rest of the program.</li>
</ul>


<p>Here is how I implemented this with rspec :</p>

<script src="https://gist.github.com/philou/5894144.js"></script>


<p>With all this in place, it is most of the time possible to write straightforward tests. For example here, only real objects are used. @order gets its value when Order.create! is called.</p>

<p>```ruby
it &ldquo;should create an order with the cart&rdquo; do
  capture_result_from(Order, :create!, into: :order)</p>

<p>  check_in_cart</p>

<p>  @order.should_not be_nil
  @order.cart.should == @cart
end
```</p>

<p>Maybe I should swith to rr &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Display full backtraces in rspec]]></title>
    <link href="http://philippe.bourgau.net/display-full-backtraces-in-rspec/"/>
    <updated>2013-06-07T06:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/display-full-backtraces-in-rspec</id>
    <content type="html"><![CDATA[<p>I use <a href="http://rspec.info/">rspec</a> a lot. I thinks it&rsquo;s a great testing framework.</p>

<p>In order to get shorter error output, rspec cleans backtraces from outside code. Here are all the patterns that are removed from the full backtrace :</p>

<p><code>ruby
DEFAULT_BACKTRACE_PATTERNS = [
  /\/lib\d*\/ruby\//,
  /org\/jruby\//,
  /bin\//,
  %r|/gems/|,
  /spec\/spec_helper\.rb/,
  /lib\/rspec\/(core|expectations|matchers|mocks)/
]
</code></p>

<p>Most of the time, that&rsquo;s great. Sometimes though, we get messages that seem completly unrelated to the code. Even worse, we might get misleading messages, such as &ldquo;method called with unexpected number of arguments&rdquo; that does not refer to the code in the backtrace, but to some other library code &hellip;</p>

<p>I thought it would be nice if we could switch this cleaning off sometimes. Here is how I did this :</p>

<p>```ruby
RSpec.configure do |config|</p>

<p>  # RSpec automatically cleans stuff out of backtraces;
  # sometimes this is annoying when trying to debug something e.g. a gem
  if ENV[&lsquo;FULLBACKTRACES&rsquo;] == &lsquo;true&rsquo;</p>

<pre><code>config.backtrace_clean_patterns = []
</code></pre>

<p>  end</p>

<p>  # some other configuration here</p>

<p>end
```</p>

<p>This way, it is still possible to call rspec as before to get the standard behaviour, but it is now possible to specify the FULLBACKTRACES variable to get full backtraces.</p>

<p><code>
FULLBACKTRACES=true bundle exec rspec spec
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to stub around a call to the original method with rspec ?]]></title>
    <link href="http://philippe.bourgau.net/how-to-stub-around-a-call-to-the-original-method-with-rspec/"/>
    <updated>2013-04-19T07:05:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-stub-around-a-call-to-the-original-method-with-rspec</id>
    <content type="html"><![CDATA[<p>Rspec mocks now features a &lsquo;and_call_original&rsquo; method to create simple proxy mocks. But how could we build more complex proxies ?</p>

<p>For the sake of the subject, let&rsquo;s take an example that is not a testing best practice, but that everybody will understand. Suppose you want to simulate a faulty network in your tests. You&rsquo;d like to stub Net::HTTP.get so that it raises errors from time to time. Here is what you could do</p>

<p><code>ruby
i = 0
original_get = Net::HTTP.method(:get)
Net::HTTP.stub(:get) do |*args, &amp;block|
  i = i+1
  raise RuntimeError.new("network down") if i%3 == 0
  original_get.call(*args, &amp;block)
end
</code></p>

<p>Note the block is taken into account, in this example, it does not matter so much, but forgetting it can bring up really strange issues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stub_model and mock_model]]></title>
    <link href="http://philippe.bourgau.net/stubmodel-and-mockmodel/"/>
    <updated>2012-04-16T00:00:00+02:00</updated>
    <id>http://philippe.bourgau.net/stubmodel-and-mockmodel</id>
    <content type="html"><![CDATA[<p>I decided to stop using stub_model and mock_model. I do not use them enough to get fluent with them. Everytime I have to deal with them, something breaks in an unexpected way. I just decided to stand with good old stubs.</p>


<p>I am also thinking of switching to RR (double ruby) and to use proxy objects to get simplify mocking even further. Did you try it ?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Order of execution of before blocks in RSpec]]></title>
    <link href="http://philippe.bourgau.net/order-of-execution-of-before-blocks-in-rspec/"/>
    <updated>2012-01-05T00:00:00+01:00</updated>
    <id>http://philippe.bourgau.net/order-of-execution-of-before-blocks-in-rspec</id>
    <content type="html"><![CDATA[<p><p>I discovered that before blocks in RSpec&rsquo;s examples are executed in the order they are declared. There is no great deal about it, but it can be useful when using shared examples.<br />In rspec 1.3.8, it is possible to simulate shared examples with parameters by using instance variables instead. This is were it gets useful to know the order of evaluation of before blocks. As an example :<p />
```ruby
shared_example_for &ldquo;anything&rdquo; do
  before :each do</p>

<pre><code>@thing.should_not be_nil
</code></pre>

<p>  end
end</p>

<p>describe &ldquo;A monkey wrench&rdquo; do
  it_should_behave_like &ldquo;anything&rdquo;
   before :each do</p>

<pre><code>@thing = MonkeyWrench.new
</code></pre>

<p>  end
end
<code>
&lt;p /&gt;The previous example will fail, whereas the next one will succeed.&lt;p /&gt;
</code>ruby
describe &ldquo;A monkey wrench&rdquo; do
  before :each do</p>

<pre><code>@thing = MonkeyWrench.new
</code></pre>

<p>  end
  it_should_behave_like &ldquo;anything&rdquo;
end
```
<p />That is the before blocks nested in shared examples still evaluate in the order of declaration.</p></p>
]]></content>
  </entry>
  
</feed>
