<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rspec | Philippe Bourgau's blog]]></title>
  <link href="http://philou.github.com/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://philou.github.com/"/>
  <updated>2013-04-01T21:07:28+02:00</updated>
  <id>http://philou.github.com/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[stub_model and mock_model]]></title>
    <link href="http://philou.github.com/blog/2012/04/16/stubmodel-and-mockmodel/"/>
    <updated>2012-04-16T00:00:00+02:00</updated>
    <id>http://philou.github.com/blog/2012/04/16/stubmodel-and-mockmodel</id>
    <content type="html"><![CDATA[<p>I decided to stop using stub_model and mock_model. I do not use them enough to get fluent with them. Everytime I have to deal with them, something breaks in an unexpected way. I just decided to stand with good old stubs.</p>


<p>I am also thinking of switching to RR (double ruby) and to use proxy objects to get simplify mocking even further. Did you try it ?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Order of execution of before blocks in RSpec]]></title>
    <link href="http://philou.github.com/blog/2012/01/05/order-of-execution-of-before-blocks-in-rspec/"/>
    <updated>2012-01-05T00:00:00+01:00</updated>
    <id>http://philou.github.com/blog/2012/01/05/order-of-execution-of-before-blocks-in-rspec</id>
    <content type="html"><![CDATA[<p>I discovered that before blocks in RSpec's examples are executed in the order they are declared. There is no great deal about it, but it can be useful when using shared examples.<br />In rspec 1.3.8, it is possible to simulate shared examples with parameters by using instance variables instead. This is were it gets useful to know the order of evaluation of before blocks. As an example :<p />
```ruby
shared_example_for "anything" do
  before :each do
    @thing.should_not be_nil
  end
end

describe "A monkey wrench" do
  it_should_behave_like "anything"
   before :each do
    @thing = MonkeyWrench.new
  end
end
```
<p />The previous example will fail, whereas the next one will succeed.<p />
```ruby
describe "A monkey wrench" do
  before :each do
    @thing = MonkeyWrench.new
  end
  it_should_behave_like "anything"
end
```
<p />That is the before blocks nested in shared examples still evaluate in the order of declaration.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rspec messes up stubs and expectations]]></title>
    <link href="http://philou.github.com/blog/2011/10/20/rspec-messes-up-stubs-and-expectations/"/>
    <updated>2011-10-20T00:00:00+02:00</updated>
    <id>http://philou.github.com/blog/2011/10/20/rspec-messes-up-stubs-and-expectations</id>
    <content type="html"><![CDATA[<p>Here is an example showing the issue :<p />
```ruby
before :each do
  @car = stub("a car")
  @car.stub(:move)
end
it "should be possible to mix stubbing and expectations" do
  @car.should_receive(:move).once

  2.times { @car.move }
end
```
<p />This example should obviously fail, but it passes ! Here is a working (failing) version :<p />
```ruby
before :each do
  @car = stub("a car")
 end
it "should be possible to mix stubbing and expectations" do
  @car.should_receive(:move).once

  2.times { @car.move }
end
```
<p /> I am using rspec 1.3.0. Did you fall into the same issues ? Is this fixed in rspec 2 ?</p>

]]></content>
  </entry>
  
</feed>
