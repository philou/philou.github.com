<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-03-01T08:51:38+01:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why you should start a team coding dojo Randori right now]]></title>
    <link href="http://philippe.bourgau.net/why-you-should-start-a-team-coding-dojo-randori-right-now/"/>
    <updated>2018-03-01T07:05:00+01:00</updated>
    <id>http://philippe.bourgau.net/why-you-should-start-a-team-coding-dojo-randori-right-now</id>
    <content type="html"><![CDATA[<p><a href="http://codingdojo.org/">Coding Dojos</a> are easy to start and have a high return on investment. They will improve everyone&rsquo;s technical skills. That&rsquo;s only the start though. Practiced as a team Randori, they will also be a tremendous boost to team work.</p>

<p><img src="../imgs/2018-02-20-why-you-should-start-a-team-coding-dojo-randori-right-now/aikidoka-keyboard.jpg" alt="An AÃ¯kidoka holding a keyboard instead of a boken" /></p>

<h2>My own story</h2>

<p>Coming up with team coding conventions is always a challenge. A few years ago, I remember organizing a meeting to discuss this with my team mates. In about 1 hour, we managed to agree on the standard C# code style, but not much more. Important points like the usage of singletons were still far from any agreement. I was disappointed. At least I learned that this is not the good way to build coding conventions.</p>

<p>A few years later, in another team, the coding conventions topic came up again. I did not want to repeat my previous failure. I created a wiki page where we could suggest, comment and vote for conventions. It was a lot better than my previous attempt, but it was slow. It turned out that we had also been doing team coding dojos for a while. A colleague suggested to try to fix a <a href="https://www.sonarqube.org/">Sonar</a> issue from our production code during a Randori session. It took us 2 hours to fix not one but a bunch of errors and to agree on 3 or 4 coding conventions. That was far more effective than my wiki page ! Looking back at the past few months, I realized what other topics the Randoris had helped the team with.</p>

<blockquote><p>ðŸ’¡ Team Coding Dojo Randori are great at defining coding conventions.</p></blockquote>

<h2>Classic Team Problems</h2>

<p>Coding conventions is only one of the team work problems that Randoris help to solve. Here is a non-exhaustive list :</p>

<ul>
<li>People waste time by ignoring how to use their tools as best as they could.</li>
<li>People lack skills that they could easily learn from one of their colleagues.</li>
<li>Team mates don&rsquo;t agree on the same design principles. This harms collective code ownership as the design goes 1 step in a direction and then 2 in the opposite.</li>
<li>People don&rsquo;t know how to work in baby steps and, as a result, perform large commits. This makes code reviews difficult and breaks the <a href="https://www.martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a> more often.</li>
<li>Because they are not at ease to give and receive feedback, people don&rsquo;t pair. Reviews suffer from this as well, either not going in the depth of things, or ending bad !</li>
<li>Some team members might have difficulties explaining what they are doing to others.</li>
</ul>


<p>Believe it of not, Randoris can help you with all these issues.</p>

<h2>What is a Randori ?</h2>

<h3>A Coding dojo</h3>

<p>A coding dojo is a meeting where programmers deliberately practice their skills. To be effective, the coding dojo should be regular, and safe. Created to spread TDD (<a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>), it&rsquo;s an effective way to teach other skills as well. Whatever the goal, it should use TDD. TDD sets up the fast feedback loop necessary to collaboration and effective learning. The dojo should end with a short retrospective : everyone stops what they are doing to discuss how it went.</p>

<p>People have invented many formats to the coding dojo, but there were only 2 at the origin. The Kata, where someone live codes a prepared solution to a problem using TDD. The Randori which I&rsquo;ll detail right away.</p>

<h3>A Randori</h3>

<p>In a Randori, you&rsquo;ll be using a single machine, a wide screen and a timer. Pairs of programmers round-rob at the keyboard every 5 minutes or so. Particularly here, we should stick to TDD for collaboration and fast feedback loop. When the timer rings, the co-pilot gets the keyboard, and a new co-pilot comes in.</p>

<p>5 minutes are very short, and force people to use real baby steps. If they try to do something too big, they will not reach a stable state before the end of their turn. If their change is too complex, others will get lost, and remove the code. The pair needs to collaborate a lot for others to understand and continue in the same direction. They have to explain what they are doing, and take feedback into account as much as they write code.</p>

<p><a href="https://www.youtube.com/watch?v=vqnwQ3oVM1M"><img src="../imgs/2018-02-20-why-you-should-start-a-team-coding-dojo-randori-right-now/randori.jpg" alt="Programmers doing a randori" /></a><div class="image-credits">From a <a href="https://www.youtube.com/watch?v=vqnwQ3oVM1M">YouTube video</a> by <a href="http://globo.com">globo.com</a></div></p>

<h3>Your team</h3>

<p>A team Randori is a Randori with your team. It improves all the problems I listed above.</p>

<ul>
<li>People will share coding conventions and design best practices. They are likely to agree on something for the sake of progress in a 2 hours session. The opportunity to see how the convention works with dojo code often leads to a production code agreement.</li>
<li>People will share IDE shortcuts and tricks.</li>
<li>The constant feedback will make people accustomed to it.</li>
<li>On top of that, people will refactor or have their code refactored from time to time. This is a great lesson in egoless programming.</li>
</ul>


<blockquote><p>ðŸ’¡ Coding Dojo Randoris are a great lesson in Egoless Programming</p></blockquote>

<p>I hope I convinced you that you should start team coding dojo Randoris. In my next post, I&rsquo;ll go into more details about how to setup and run your first Randori. Don&rsquo;t miss it, <a href="https://feedburner.google.com/fb/a/mailverify?uri=PhilippeBourgau&amp;loc=en_US">subscribe</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Throwing code away frequently]]></title>
    <link href="http://philippe.bourgau.net/throwing-code-away-frequently/"/>
    <updated>2017-09-01T06:56:00+02:00</updated>
    <id>http://philippe.bourgau.net/throwing-code-away-frequently</id>
    <content type="html"><![CDATA[<p>Here is the main feedback I got about my previous post <a href="/extreme-extreme-programming-2017/">eXtreme eXtreme Programming</a>.</p>

<blockquote><p>What do you actually mean by throwing code away ? Does it mean stoping unit testing and refactoring ?</p></blockquote>

<p><img src="../imgs/2017-09-01-throwing-code-away-frequently/shredder.jpeg" alt="A drawing of a shredder destroying some code" /></p>

<p>So I guess it deserves a bit of explanation.</p>

<h2>What is it all about ?</h2>

<p>When programming, I don&rsquo;t throw code away a lot. I tend to rely on my automated tests to change the code I already have. That might be a problem.</p>

<p>As with everything, there is no one size fits all. We should choose the best practice for our current situation. Same thing applies for incremental changes versus rewriting.</p>

<p>TDD makes incremental changes cost effective, and as such, is a key to get out of the Waterfall.</p>

<p>The idea of throwing code away frequently is to make rewriting cost effective, so we can do it more often.</p>

<h2>Why would we want to do so ?</h2>

<p>In &ldquo;<a href="https://blog.codinghorror.com/when-understanding-means-rewriting/">When Understanding means Rewriting"</a>, Jeff Atwood explains that reading code can be more difficult than writing it. There is a point where rewriting is going to be cheaper than changing.</p>

<p>The more unit test you have, the later you reach that point. The more technical debt you take, and the sooner. The bigger the part to rewrite, the more risky it becomes.</p>

<p>Let&rsquo;s imagine you knew a safe way to rewrite the module you are working on. You could be faster by taking more technical debt and writing less unit tests ! Mike Cavaliere framed it as<br/>
<a href="http://mikecavaliere.com/throw-away-your-code/">F**k Going Green: Throw Away Your Code</a>.</p>

<p>This would be great for new features, that might be removed if they don&rsquo;t bring any value. It would also be a good way to get rid of technical debt. Naresh Jain also makes the point that without tests, you&rsquo;ll have to keep things simple (<a href="https://blogs.agilefaqs.com/2008/10/07/throwing-away-code/">here</a> and <a href="https://fr.slideshare.net/nashjain/the-decline-and-fall-of-agile-antifragile-mindset-to-rescue">here</a>) !</p>

<p>Wait a minute, isn&rsquo;t that <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a> ?</p>

<h2>How to make it work</h2>

<p><a href="/extreme-extreme-programming-2017/"><img src="../imgs/2017-09-01-throwing-code-away-frequently/xxp.jpg" alt="A graph with all the practices from my previous article eXtreme eXtreme Programming" /></a></p>

<h3>How to ensure quality without unit tests ?</h3>

<p>TDD and unit testing is a cornerstone of XP. If we remove it, we need something else to build quality in. Could Mob Programming and Remote teams do the trick ?</p>

<p>&ldquo;Given enough eyeballs, all bugs are shallow&rdquo;. Pair programming and code reviews catch a lot more bugs than solo programming. Only a few bugs are likely to pass through the scrutiny of the whole team doing mob programming.</p>

<p>What about Remote ? Martin Fowler <a href="https://martinfowler.com/articles/remote-or-co-located.html">explains</a> that remote teams perform better by hiring the best. Skills of programmers have been known for a long time as a main driver of software quality.</p>

<p><a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/"><img src="../imgs/2017-09-01-throwing-code-away-frequently/ProductivityVariation.jpg" alt="People vs methodology impact on productivity" /></a><div class="image-credits">Photo from Steve McConnell on <a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/">Construx</a></div></p>

<p>Finally, the Cucumber team <a href="https://cucumber.io/blog/2015/12/21/the-mob-rules-ok">reported</a> that Mob Programming works well for remote teams.</p>

<h3>How to make this safer ?</h3>

<p>Even with the best team, mistakes will happen. How can we avoid pushing a rewrite that crashes the whole system ?</p>

<p>The main answer to that is good continuous deployment. We should deploy to a subset of users first. We should be able to rollback straight away if things don&rsquo;t work as expected.</p>

<p>As the system grows, <a href="https://en.wikipedia.org/wiki/Microservices">microservices</a> can keep continuous deployment under control. We can deploy, update and roll them back independently. By nature, microservices also reduce the scope of the rewrite. That alone, as we said earlier, makes rewrites safer.</p>

<p>As a last point, some technologies make building microservice systems easier and incremental. The <a href="https://stackoverflow.com/questions/16779162/what-kind-of-virtual-machine-is-beam-the-erlang-vm">Erlang VM</a>, for example, with first class actors, is one these. Time to give <a href="https://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a> a try !</p>

<h3>Is this always a good idea ?</h3>

<p>There are good and bad situations.</p>

<p>For example, a lean startup or data driven environment seems a good fit. Suppose your team measures the adoption of new features before deciding to keep or ditch them. You&rsquo;d better not invest in unit tests straight away.</p>

<p>On the other side, software for a complex domain will be very difficult to rewrite flawlessly. I have worked in the finance industry for some years, I know what a complex domain is. I doubt I could rewrite a piece of intricate finance logic without bugs. I would stick to <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a> and unit testing in these areas.</p>

<h3>How to dip your toe</h3>

<p>Here is how I intend to dip <em>my</em> toe. I won&rsquo;t drop automated testing completely yet. What I could do instead (and that I already did on side projects) is to start with end to end tests only.</p>

<p>From there every time I want to change a piece of code, I have many options :</p>

<ul>
<li>Add a new end to end test and change the code.</li>
<li>If the code is too much of a mess, I can rewrite it from scratch. I&rsquo;ll have the safety of the end to end tests.</li>
<li>If I see that the module is stabilizing, has not been rewritten for a while, and yields well to modifications. I could start splitting end to end tests into unit tests, and embark on the TDD road.</li>
</ul>


<p>Maybe later, when I have a team doing mob programming to find my mistakes, we&rsquo;ll skip the end to end tests.</p>

<h2>Other interesting links</h2>

<ul>
<li><a href="http://corgibytes.com/blog/2016/11/01/throwaway-code/">Throwaway Code</a> by M. Scott Ford</li>
<li><a href="http://wiki.c2.com/?RewriteCodeFromScratch">Rewrite Code From Scratch</a> on c2 wiki</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forget unit tests, only fast tests matter]]></title>
    <link href="http://philippe.bourgau.net/forget-unit-tests/"/>
    <updated>2017-08-08T06:24:00+02:00</updated>
    <id>http://philippe.bourgau.net/forget-unit-tests</id>
    <content type="html"><![CDATA[<p>Don&rsquo;t worry if your unit tests go to the DB, that might not be so bad.</p>

<p>When I started writing unit tests, I did not know what these were. I read <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=126923">the definition</a>, and strived to follow the recommandations :</p>

<ul>
<li>they should be independent from each other</li>
<li>they should not access the DB</li>
<li>they should not use the network</li>
<li>they should only cover a small scope of your code</li>
</ul>


<p>I started to write unit tests on my own and became <a href="http://wiki.c2.com/?TestInfected">test infected</a> pretty fast. Once I got convinced of the benefits of unit testing, I tried to spread the practice around me. I used to explain to people that it is very important to write real unit tests by the book. Otherwise, <em>Bad Things</em> would happen &hellip;</p>

<h2>How I changed my mind</h2>

<p>A few years ago, I spent a few years working on a <a href="http://rubyonrails.org/">Rails</a> side project called <a href="https://github.com/philou/mes-courses">mes-courses.fr</a>. I was using a small test gem to enforce that no unit tests were accessing the db. I had to write a lot of mocks around the code. I ended up hating mocks : they are too painful to maintain and provide a false sense of security. I&rsquo;m not alone in this camp, check <a href="https://www.youtube.com/watch?v=9LfmrkyP81M">DHH&rsquo;s keynote at RailsConf 2014</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/9LfmrkyP81M" frameborder="0" allowfullscreen></iframe>


<p>At some point, the mock pain got so bad that I stopped all developments until I found another way. I found a pretty simple workaround : use in-memory SQLite. I got rid of all the DB access mocks. Not only were the tests easier to write and maintain, but they were as fast as before, and they covered more code.</p>

<p>That changed something fundamental in my understanding of testing</p>

<h2>It&rsquo;s all about speed baby</h2>

<p>The only thing that makes unit tests so important is that they run fast.</p>

<p>Unit tests as described in the literature run fast. Let&rsquo;s see what happens when you remove one of the recommandations for unit tests.</p>

<ul>
<li>If tests depend on each other, their outcome will change with the execution order. This wastes our time in analyzing the results. On top of that, independent unit tests are easy to run in parallel, providing an extra speedup. We lose this potential when our tests are dependent.</li>
<li>Tests that rely on an out-of-process DB run slower. Tests need to start the DB before anything else. Data needs to be setup and cleaned at every test. Accessing the DB implies using the network, which takes time as well. There&rsquo;s also a risk of making the tests dependent by sharing the same DB. A last issue is troubleshooting the DB process when things don&rsquo;t work.</li>
<li>Tests that use the network are slow too ! First, Network is slower than memory. Second, data serialization between processes is slow as well. Finally, these tests are likely to use some form of sleep or polling, which is slow, fragile, or both !</li>
<li>Finally, there is always a scope past which a test will be too slow.</li>
</ul>


<p>This means that not only unit tests are fast, but also that fast tests usually show the features of unit tests.</p>

<p>My guess is that &lsquo;unit tests&rsquo; were explicitly defined as a recipe for fast tests ! If you stick to the definition of unit tests, you&rsquo;ll get fast tests and all their benefits.</p>

<p><img src="../imgs/2017-08-08-forget-unit-tests/speedometer.jpg" alt="A speedometer" /></p>

<h2>Fast tests</h2>

<p>That also means that we should focus first on having fast tests rather than unit tests. Here is my real check to know if tests are fast enough :</p>

<ul>
<li>Is the build (and the tests and everything) less than 10 minutes ?</li>
<li>Can I continuously run my tests while coding and stay in the flow ?</li>
</ul>


<p>If both answers are yes, then I won&rsquo;t question myself too much whether my tests are unit, integration or end to end.</p>

<h2>So what ?</h2>

<p>I&rsquo;ve been experimenting with these heuristics for some time. Side projects are great for experimenting since you don&rsquo;t have a team to convince ! Here are my main takeaways :</p>

<ul>
<li>Stick to end to end tests at the beginning of your project. They are easy to refactor to finer grained tests later on.</li>
<li>In-memory DBs are great to speed tests up without wasting your time with mocking.  We can use a unique DB for every test to keep them independent.</li>
<li>Large scope tests are not an issue provided 2 things.

<ol>
<li>The code contains very few side effects.</li>
<li>It provides good exceptions and assertions messages</li>
</ol>
</li>
</ul>


<p>On the other side, there are things that I still recommend :</p>

<ul>
<li>Independent tests are easy to write from the beginning, difficult to fix later on. As they save a lot of headaches in diagnostic, I stick to them from the start.</li>
<li>Avoid network, it makes the tests slow, fragile and tricky to diagnostic. But please, read <a href="http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb/">this</a> before jumping to mocks.</li>
</ul>


<p>These rules have served me well, particularly in my side projects, where I don&rsquo;t have a lot of time. What about you ? Do you have your own testing rules ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't stick to TDD's Red-Green-Refactor loop to the letter]]></title>
    <link href="http://philippe.bourgau.net/dont-stick-to-tdds-red-green-refactor-loop-to-the-letter/"/>
    <updated>2017-06-28T15:52:00+02:00</updated>
    <id>http://philippe.bourgau.net/dont-stick-to-tdds-red-green-refactor-loop-to-the-letter</id>
    <content type="html"><![CDATA[<p>As long as you are writing your tests before your code and doing regular refactoring, you are doing <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !</p>

<p>The Red &ndash; Green &ndash; Refactor loop is useful to introduce TDD to new developers. Different loops can be more effective in real world situation.</p>

<p>The Red &ndash; Green &ndash; Refactor loop is not a dogma !</p>

<p><a href="http://www.natpryce.com/"><img src="../imgs/2017-06-28-dont-stick-to-tdds-red-green-refactor-loop-to-the-letter/red-green-refactor.jpg" alt="The famous red, green, refactor TDD loop" /></a></p>

<h2>Refactor &ndash; Red &ndash; Green</h2>

<p>When I work on a story, I very often keep a TODO list next to my desk. I use it to keep track of the next steps, the edge cases to test, the code smells and refactorings to do.</p>

<p>When I get to the end of the story, all that remains of this list is a few refactorings. Very often, I don&rsquo;t do them !</p>

<p>With the feature working, doing these refactorings feels like violation of <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>. Next time we&rsquo;ll have to work on this part of the code, we&rsquo;ll have a story to serve as guide to which refactorings to do.</p>

<p>The same thing is effective at the unit test scale. It&rsquo;s easier to refactor when you know the test you want to add. Refactor to make this test easy to write !</p>

<p>Here is an example with <a href="https://en.wikipedia.org/wiki/Fizz_buzz">Fizz Buzz</a></p>

<p>```java
static int fizzBuzz(int number) {
Â Â Â return number;
}</p>

<p>@Test public void
it_is_1_for_1() {
Â Â Â assertThat(fizzBuzz(1)).isEqualTo(1);
}</p>

<p>@Test public void
it_is_2_for_2() {
Â Â Â assertThat(fizzBuzz(2)).isEqualTo(2);
}
```</p>

<p>Here is the test I&rsquo;d like to add.Â </p>

<p><code>java
@Test public void
it_is_Fizz_for_3() {
Â Â Â assertThat(fizzBuzz(3)).isEqualTo("Fizz");
}
</code></p>

<p>Unfortunately, fizzBuzz needs to return a String instead of an integer for it to compile. That&rsquo;s when I would refactor before adding the new test.</p>

<p>```java
static String fizzBuzz(int number) {
Â Â Â return Integer.toString(number);
}</p>

<p>@Test public void
it_is_1_for_1() {
Â Â Â assertThat(fizzBuzz(1)).isEqualTo(&ldquo;1&rdquo;);
}</p>

<p>@Test public void
it_is_2_for_2() {
Â Â Â assertThat(fizzBuzz(2)).isEqualTo(&ldquo;2&rdquo;);
}
```</p>

<p>In the end, this loop is very like the classic TDD loop :</p>

<p><code>
red-green-refactor-red-green-refactor-red-green-refactor.............
..........refactor-red-green-refactor-red-green-refactor-red-green...
</code></p>

<p>A bit more YAGNI, that&rsquo;s all.</p>

<h2>Red &ndash; Better Red &ndash; Green &ndash; Refactor</h2>

<p>A few weeks ago, <a href="/speed-up-the-tdd-feedback-loop-with-better-assertion-messages/">I wrote about error messages in unit tests</a>. To summarize, extra work on error messages reduces the testing feedback loop.</p>

<p>We can translate this focus on error messages into an extra TDD step. Whatever the TDD loop you are using, you can add this step after the Red step.</p>

<h2><del>Red</del> &ndash; Green &ndash; Refactor &ndash; Red &ndash; Green</h2>

<p>Sometimes, it makes sense to refactor before fixing the test. The idea is to rely on the existing tests to prepare the code to fix the new test in one line.</p>

<p>Let&rsquo;s take our Fizz Buzz example again. Imagine we finished the kata, when we decide to tweak the rules and try Fizz Buzz Bang. We should now print Bang on multiples of 7.</p>

<p>Here is our starting point :</p>

<p>```java
static String fizzBuzz(int number) {
Â Â Â if (multipleOf(number, 3)) {
Â Â Â Â Â Â return &ldquo;Fizz&rdquo;;
Â Â Â }
Â Â Â if (multipleOf(number, 5)) {
Â Â Â Â Â Â return &ldquo;Buzz&rdquo;;
Â Â Â }
Â Â Â if (multipleOf(number, 3*5)) {
Â Â Â Â Â Â return &ldquo;FizzBuzz&rdquo;;
Â Â Â } Â Â 
Â Â Â return Integer.toString(number);
}</p>

<p>&hellip;</p>

<p>@Test public void
it_is_Bang_for_7() {
Â Â Â assertThat(fizzBuzz(7)).isEqualTo(&ldquo;Bang&rdquo;);
}
```</p>

<p>I could go through all the hoops, 7, 14, then 3<em>7, 5</em>7 and finally 3<em>5</em>7 &hellip; By now, I should know the music though !</p>

<p>What I would do in this case is :</p>

<ul>
<li>first to comment the new failing test to get back to green</li>
<li>refactor the code to prepare for the new code</li>
<li>uncomment the failing test</li>
<li>fix it</li>
</ul>


<p>In our example, here is the refactoring I would do</p>

<p>```java
static String fizzBuzz(int number) {
Â Â Â String result = &ldquo;&rdquo;;
Â Â Â result += multipleWord(number, 3, &ldquo;Fizz&rdquo;);
Â Â Â result += multipleWord(number, 5, &ldquo;Buzz&rdquo;);
Â Â Â if (result.isEmpty()) {
Â Â Â Â Â Â result = Integer.toString(number);
Â Â Â }
Â Â Â return result;
}</p>

<p>private static String multipleWord(int number, int multiple, String word) {
Â Â Â if (multipleOf(number, multiple)) {
Â Â Â Â Â Â return word;
Â Â Â }
Â Â Â return &ldquo;&rdquo;;
}</p>

<p>&hellip;</p>

<p>//@Test public void
//it_is_Bang_for_7() {
// Â Â assertThat(fizzBuzz(7)).isEqualTo(&ldquo;Bang&rdquo;);
//}
```</p>

<p>From there, fixing the test is dead simple.</p>

<p>In practice I find this loop very useful. At local scale as we saw but it&rsquo;s also a great way to refactor your architecture at larger scale.</p>

<p>One downsize is that if you are not careful, it might lead to over-engineering. Be warned, keep an eye on that !</p>

<p>Last caveat : not all TDD interviewers like this technique &hellip;</p>

<h2>Don&rsquo;t obsess</h2>

<p>It&rsquo;s not because you are not following the Red Green Refactor loop to the letter that you are not doing TDD.</p>

<p>An interesting point is that these variations to the TDD loop are combinable ! Experienced TDD practitioners can jump from one to the other without even noticing.</p>

<p><a href="https://blog.acolyer.org/2017/06/13/a-dissection-of-the-test-driven-development-process-does-it-really-matter-to-test-first-or-test-last/">This paper</a> argues that as long as you write the tests along (before or after) the code, you get the same benefit. That&rsquo;s not going to make me stop writing my tests first, but it is interesting. That would mean that even a Code &ndash; Test &ndash; Refactor loop would be ok if it is fast enough !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Speed up the TDD feedback loop with better assertion messages]]></title>
    <link href="http://philippe.bourgau.net/speed-up-the-tdd-feedback-loop-with-better-assertion-messages/"/>
    <updated>2017-05-29T06:37:00+02:00</updated>
    <id>http://philippe.bourgau.net/speed-up-the-tdd-feedback-loop-with-better-assertion-messages</id>
    <content type="html"><![CDATA[<p>There is a rather widespread <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> practice to have a <a href="https://softwareengineering.stackexchange.com/questions/7823/is-it-ok-to-have-multiple-asserts-in-a-single-unit-test">single assertion per test</a>. The goal is to have faster feedback loop while coding. When a test fails, it can be for a single reason, making the diagnostic faster.</p>

<p>The same goes with the test names. When a test fails, a readable test name in the report simplifies the diagnostic. Some testing frameworks allow the use of plain strings as test names. In others, people use <a href="https://en.wikipedia.org/wiki/Naming_convention_(programming">underscores</a>#Multiple-word_identifiers) instead of <a href="https://en.wikipedia.org/wiki/Camel_case">CamelCase</a> in test names.</p>

<p><img src="../imgs/2017-05-29-speed-up-the-tdd-feedback-loop-with-better-assertion-messages/rubymine.jpg" alt="RubyMine test report" /></p>

<h2>A 4th step in TDD: Fail, <em>Fail better</em>, Pass, Refactor</h2>

<h3>First, make it fail</h3>

<p>Everyone knows that Test Driven Development starts by making the test fail. Let me illustrate why.</p>

<p>A few years ago, I was working on a <a href="https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29">C#</a> project. We were using TDD and <a href="https://github.com/nunit/nunit">NUnit</a>. At some point, while working on a story, I forgot to make my latest test fail. I wrote some code to pass this test, I ran the tests, and they were green. When I was almost done, I tried to plug all the parts together, but nothing was working. I had to start the debugger to understand what was going wrong. At first, I could not understand why the exact thing I had unit tested earlier was now broken. After more investigation I discovered that I had forgotten to make my test public. NUnit only runs public tests &hellip;</p>

<p>If I had made sure my test was failing, I would have spotted straightaway that it was not ran.</p>

<h3>Then make it fail &hellip; better !</h3>

<p>I lived the same kind of story with wrong failures many times. The test fails, but for a bad reason. I move on to implement the code to fix it &hellip; but it still does not pass ! Only then do I check the error message and discover the real thing to fix. Again, it&rsquo;s a transgression to baby steps and to the <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a> principle. If the tests is small, that might not be too much of an issue. But it can be if the test is big, or if the real fix deprecates all the premature work.</p>

<h3>Strive for explicit error message</h3>

<p>The idea is to make sure to have good enough error messages before moving on to the &ldquo;pass&rdquo; step.</p>

<p><a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1495080583&amp;sr=1-1&amp;keywords=growing+object-oriented+software+guided+by+tests"><img src="../imgs/2017-05-29-speed-up-the-tdd-feedback-loop-with-better-assertion-messages/growing.jpg" alt="Cover of GOOSGT" /></a></p>

<p>There&rsquo;s nothing groundbreaking about this practice. It&rsquo;s not a step as explicit as the other 3 steps of TDD. The first place I read about this idea was in <a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1495080583&amp;sr=1-1&amp;keywords=growing+object-oriented+software+guided+by+tests">Growing Object Oriented Software Guided By Tests</a>.</p>

<h2>How to improve your messages</h2>

<h3>Readable code</h3>

<p>Some test frameworks print out the failed assertion code to the test failure report. Others, especially in dynamic languages, use the assertion code itself to deduce an error message. If your test code is readable enough, your error messages might be as well !</p>

<p>For example, with <a href="https://www.ruby-lang.org">Ruby</a> <a href="http://rspec.info/">RSpec</a> testing framework :</p>

<p><code>ruby
it "must have an ending" do
  expect(Vote.new(team: @daltons)).to be_valid
end
</code></p>

<p>Yield the following error :</p>

<p>```
expected #<Vote ...> to be valid, but got errors: Ending can&rsquo;t be blank</p>

<p>```</p>

<h3>Pass in a message argument</h3>

<p>Sometimes, readable code is not enough to provide good messages. All testing frameworks I know provide some way to pass in a custom error message. That&rsquo;s often a cheap and straightforward way to clarify your test reports.</p>

<p>```ruby
  it &ldquo;should not render anything&rdquo; do</p>

<pre><code>post_create
expect(response.code).to eq(HTTP::Status::OK.to_s),
                         "expected the post to succeed, but got http status #{response.code}"
</code></pre>

<p>  end
```</p>

<p>Yields</p>

<p><code>
expected the post to succeed, but got http status 204
</code></p>

<h3>Define your own matchers</h3>

<p>The drawback with explicit error message is that they harm code readability. If this becomes too much of an issue, one last solution is the use of <a href="https://objectpartners.com/2013/09/18/the-benefits-of-using-assertthat-over-other-assert-methods-in-unit-tests/">test matchers</a>. A test matcher is a class encapsulating assertion code. The test framework provides a fluent api to bind a matcher with the actual and expected values. Almost all test framework support some flavor of these. If not, or if you want more, there are libraries that do :</p>

<ul>
<li><a href="http://joel-costigliola.github.io/assertj/index.html">AssertJ</a> is a fluent assertion library for Java. You can easily extend it with your own assertions (ie. matchers)</li>
<li><a href="http://n-fluent.net/">NFluent</a> is the same thing for .Net.</li>
</ul>


<p>As an example, in a past side project, I defined an <a href="https://github.com/philou/mes-courses/blob/master/spec/support/include_all_matcher.rb">include_all</a> rspec matcher that verifies that many elements are present in a collection. It can be used that way :</p>

<p><code>ruby
expect(items).to include_all(["Tomatoes", "Bananas", "Potatoes"])
</code></p>

<p>It yields error messages like</p>

<p><code>
["Bananas", "Potatoes"] are missing
</code></p>

<p>A custom matcher is more work, but it provides both readable code and clean error messages.</p>

<h2>Other good points of matchers</h2>

<p>Like any of these 3 tactics, matchers provide better error messages. Explicit error messages, in turn, speed up the diagnostic on regression. In the end, faster diagnostic means easier maintenance.</p>

<p>But there&rsquo;s more awesomness in custom test matchers !</p>

<h3>Adaptive error messages</h3>

<p>In a custom matcher, you have to write code to generate the error message. This means we can add logic there ! It&rsquo;s an opportunity to build more detailed error messages.</p>

<p>This can be particularly useful when testing recursive (tree-like) structures. A few years ago, I wrote an rspec matcher library called <a href="https://github.com/philou/xpath-specs">xpath-specs</a>. It checks html views for the presence of recursive XPath. Instead of printing</p>

<p><code>
Could not find //table[@id="grades"]//span[text()='Joe'] in ...
</code></p>

<p>It will print</p>

<p><code>
Could find //table[@id="grades"] but not //table[@id="grades"]//span[text()='Joe'] in ...
</code></p>

<p>(BTW, I&rsquo;m still wondering if testing views this way is a good idea &hellip;)</p>

<h3>Test code reuse</h3>

<p>One of the purpose of custom test matchers is to be reusable. That&rsquo;s a good place to factorize assertion code. It is both more readable and more organized than extracting an assertion method.</p>

<h3>Better coverage</h3>

<p>I noticed that custom matcher have a psychological effect on test coverage ! A matcher is a place to share assertion code. Adding thorough assertions seems legitimate, contrary to repeating them inline.</p>

<h3>Avoids mocking</h3>

<p>We often resort to mocks instead of side effect tests because it&rsquo;s a lot shorter. A custom matcher encapsulates the assertion code. It makes it OK to use a few assertions to test for side effects, which is usually preferable to mocking.</p>

<p>For example, here is a matcher that checks that our remote service API received the correct calls, without doing any mocking.</p>

<p>```ruby
RSpec::Matchers.define :have_received_order do |cart, credentials|
  match do |api|</p>

<pre><code>not api.nil? and
api.login == credentials.email and
api.password == credentials.password and
cart.lines.all? do |cart_line|
  cart.content.include?(cart_line.item.remote_id)
end
</code></pre>

<p>  end</p>

<p>  failure_message do |api|</p>

<pre><code>"expected #{api.inspect} to have received order #{cart.inspect} from #{credentials}"
</code></pre>

<p>  end
end
```</p>

<h2>Care about error messages</h2>

<p>Providing good error messages is a small effort compared to unit testing in general. At the same time, it speeds up the feedback loop, both while coding and during later maintenance. Imagine how easier it would be to analyze and fix regressions if they all had clear error messages !</p>

<p>Spread the word ! Leave comments in code reviews, demo the practice to your pair buddy. Prepare a team coding dojo about custom assertion matchers. Discuss the issue in a retro !</p>

<p><img src="../imgs/2017-05-29-speed-up-the-tdd-feedback-loop-with-better-assertion-messages/just-do-it.jpg" alt="'Just Do It' written on a board" /></p>
]]></content>
  </entry>
  
</feed>
