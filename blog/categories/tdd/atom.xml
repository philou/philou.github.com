<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-03-13T09:41:20+01:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to start a team coding dojo Randori today]]></title>
    <link href="http://philippe.bourgau.net/how-to-start-a-team-coding-dojo-randori-today/"/>
    <updated>2018-03-08T08:57:00+01:00</updated>
    <id>http://philippe.bourgau.net/how-to-start-a-team-coding-dojo-randori-today</id>
    <content type="html"><![CDATA[<p>In my <a href="/why-you-should-start-a-team-coding-dojo-randori-right-now/">previous post</a>, I explained why you should start a team <a href="http://codingdojo.org/">coding dojo</a> <a href="http://codingdojo.org/RandoriKata/">Randori</a> as soon as you can. Here is a step by step guide to set one up today.</p>

<p><img src="../imgs/2018-02-23-how-to-start-a-team-coding-dojo-randori-today/white-belt.jpg" alt="A white belt" /></p>

<h2>Logistics</h2>

<p>This the most important, and most easy, part !</p>

<h3>A Time Slot</h3>

<p>For a regular team coding dojo, practice showed that 2 hours every 2 weeks works great. Most teams I&rsquo;ve worked with had 2 weeks sprints, which made this rhythm natural.</p>

<p>Try to find a day and a slot that fits your own constraints. It could on the first, last or mid day of the sprint. It could be in the morning where people are usually fresh. People might have a bit less energy in the afternoon. Don&rsquo;t put it in the middle of the afternoon, or you&rsquo;ll ruin the programmers' focus. Some teams use the lunch break, and bring food in to make the coding dojo even more fun.</p>

<p>Once you&rsquo;ve found the perfect slot, book a recurring meeting with all your team. It&rsquo;s now official, you are going to have your first team coding dojo !</p>

<h3>Material Stuff</h3>

<p>You now need only 4 other things :</p>

<ul>
<li>a room</li>
<li>a laptop with a programming environment</li>
<li>a large visible screen to display the laptop</li>
<li>a timer</li>
</ul>


<p>It used to need a bit of preparation to get all these, but nowadays, it should be easy.</p>

<h2>Your first session</h2>

<p>The good thing about the Randori is that it is almost preparation-free. Here is the typical agenda for a Randori session :</p>

<ol>
<li>Introduction (0:05)</li>
<li>Problem Selection (0:05)</li>
<li>Coding (1:40)</li>
<li>Retrospective (0:10)</li>
</ol>


<h3>Introduction</h3>

<p>Start by reviewing last session&rsquo;s retrospective. This will bring good resolutions back to everyone&rsquo;s minds. Obviously, you cannot do that at the first session. Present the rules of the Randori instead (as stated by <a href="https://twitter.com/emilybache?lang=fr">Emily Bache</a> in her <a href="https://www.amazon.com/Coding-Dojo-Handbook-Emily-Bache/dp/919811803X/ref=sr_1_1?ie=UTF8&amp;qid=1519388493&amp;sr=8-1&amp;keywords=coding+dojo+handbook">book</a>):</p>

<blockquote><ol>
<li>If you have the keyboard, you get to decide what to type</li>
<li>If you have the keyboard and you don‚Äôt know what to type, ask for help</li>
<li>If you are asked for help, kindly respond to the best of your ability</li>
<li>If you are not asked, but you see an opportunity for improvement or learning, choose an appropriate moment to mention it. This may involve waiting until the next time all the tests pass (for design improvement suggestions) or until the retrospective.</li>
</ol>
</blockquote>

<p>Don&rsquo;t hesitate to repeat the rules when you have a newcomer or when you see fit.</p>

<p>The introduction is also a moment where participants can share things together. Just make sure it does not eat on coding time.</p>

<h3>Problem Selection</h3>

<p>There is a ton of coding dojo subjects out there. For the first session, pick in 1 or 2 problems for the team to choose from. After a few sessions, let people bring in problems and dot vote on their favorite subjects.</p>

<p>As a first problem, I like the <a href="http://codingdojo.org/kata/RomanNumerals/">Roman Numerals</a> kata. It&rsquo;s not too difficult and has some interesting <a href="https://martinfowler.com/bliki/Yagni.html">YAGNI</a> and &ldquo;Do the simplest thing that could work&rdquo; properties. That&rsquo;s only a personal preference though. Here some resources where to find kata problems :</p>

<ul>
<li><a href="http://codingdojo.org/">codingdojo.org</a></li>
<li><a href="http://cyber-dojo.org/">cyber-dojo.org</a></li>
<li><a href="http://kata-log.rocks">kata-log.rocks</a></li>
<li><a href="https://www.amazon.com/Coding-Dojo-Handbook-Emily-Bache/dp/919811803X/ref=sr_1_1?ie=UTF8&amp;qid=1519279127&amp;sr=8-1&amp;keywords=coding+dojo+handbook">The Coding Dojo Handbook</a> (Where you&rsquo;ll also find tons of other valuable advices)</li>
</ul>


<p><a href="https://www.amazon.com/Coding-Dojo-Handbook-Emily-Bache/dp/919811803X/ref=sr_1_1?ie=UTF8&amp;qid=1519279127&amp;sr=8-1&amp;keywords=coding+dojo+handbook"><img src="../imgs/2018-02-23-how-to-start-a-team-coding-dojo-randori-today/coding-dojo.jpg" alt="The Coding Dojo Handbook cover" /></a></p>

<p>Whatever the topic you chose for your first session, make sure it is not too difficult.</p>

<blockquote><p>üí° As a first team Randori coding dojo problem, I like <a href="http://codingdojo.org/kata/RomanNumerals/">Roman Numerals</a> kata.</p></blockquote>

<h3>Coding</h3>

<p>That&rsquo;s why we are here ! The Randori is a dojo format where everyone works together, on the same problem, through the same computer. Start the timer for 5 minutes as the first pair works on the problem. When the timer rings, the co-pilot takes the keyboard, and someone new becomes the co-pilot. Start the timer again, and repeat after 5 more minutes. If you did not already, have a look at my previous post(TODO) for more details.</p>

<p>You should be using <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a> during the Randori. Even if you are not (yet) using it on your production code. Here is why :</p>

<ul>
<li>It provides a fast feedback loop which enables the fast paced 5 minutes round robin</li>
<li>It teaches how to design testable code, which is always useful</li>
<li>It teaches how to do baby steps refactorings</li>
<li>üéÅ Bonus : it demonstrates agile principles in practice (focus on outcome, incremental delivery, YAGNI &hellip;)</li>
</ul>


<p>I&rsquo;ve written a lot about TDD, have a look at my posts(TODO) for more. Applying TDD means sticking to the Red-Green-Refactor loop. During first sessions, be particularly careful that people don&rsquo;t refactor on red tests.</p>

<blockquote><p>üí° Team Randori coding dojo demonstrates agile principles in practice (focus on outcome, incremental delivery, YAGNI &hellip;)</p></blockquote>

<h3>Retrospective</h3>

<p>Stop coding 10 minutes before the end of the session. It might be difficult, but remind everyone that you are here to learn and that you can resume on next session. Use these 10 minutes to think about how it went. As the facilitator, take the keyboard, write these 4 questions in a text document :</p>

<ul>
<li>What did we do ?</li>
<li>What did we learn ?</li>
<li>What still puzzles us ?</li>
<li>What did we decide ?</li>
</ul>


<p>Ask everyone for their answers and write them down. You&rsquo;ll use this at the beginning of next session.</p>

<h2>Next Post</h2>

<p>I thought 2 posts would be enough to cover coding dojos, but it seems I have more to say ! My next post will be about tricks and advices to make your dojos a success. Don&rsquo;t miss it : <a href="https://feedburner.google.com/fb/a/mailverify?uri=PhilippeBourgau&amp;loc=en_US">subscribe</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why you should start a team coding dojo Randori right now]]></title>
    <link href="http://philippe.bourgau.net/why-you-should-start-a-team-coding-dojo-randori-right-now/"/>
    <updated>2018-03-01T07:05:00+01:00</updated>
    <id>http://philippe.bourgau.net/why-you-should-start-a-team-coding-dojo-randori-right-now</id>
    <content type="html"><![CDATA[<p><a href="http://codingdojo.org/">Coding Dojos</a> are easy to start and have a high return on investment. They will improve everyone&rsquo;s technical skills. That&rsquo;s only the start though. Practiced as a team Randori, they will also be a tremendous boost to team work.</p>

<p><img src="../imgs/2018-02-20-why-you-should-start-a-team-coding-dojo-randori-right-now/aikidoka-keyboard.jpg" alt="An A√Økidoka holding a keyboard instead of a boken" /></p>

<h2>My own story</h2>

<p>Coming up with team coding conventions is always a challenge. A few years ago, I remember organizing a meeting to discuss this with my team mates. In about 1 hour, we managed to agree on the standard C# code style, but not much more. Important points like the usage of singletons were still far from any agreement. I was disappointed. At least I learned that this is not the good way to build coding conventions.</p>

<p>A few years later, in another team, the coding conventions topic came up again. I did not want to repeat my previous failure. I created a wiki page where we could suggest, comment and vote for conventions. It was a lot better than my previous attempt, but it was slow. It turned out that we had also been doing team coding dojos for a while. A colleague suggested to try to fix a <a href="https://www.sonarqube.org/">Sonar</a> issue from our production code during a Randori session. It took us 2 hours to fix not one but a bunch of errors and to agree on 3 or 4 coding conventions. That was far more effective than my wiki page ! Looking back at the past few months, I realized what other topics the Randoris had helped the team with.</p>

<blockquote><p>üí° Team Coding Dojo Randori are great at defining coding conventions.</p></blockquote>

<h2>Classic Team Problems</h2>

<p>Coding conventions is only one of the team work problems that Randoris help to solve. Here is a non-exhaustive list :</p>

<ul>
<li>People waste time by ignoring how to use their tools as best as they could.</li>
<li>People lack skills that they could easily learn from one of their colleagues.</li>
<li>Team mates don&rsquo;t agree on the same design principles. This harms collective code ownership as the design goes 1 step in a direction and then 2 in the opposite.</li>
<li>People don&rsquo;t know how to work in baby steps and, as a result, perform large commits. This makes code reviews difficult and breaks the <a href="https://www.martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a> more often.</li>
<li>Because they are not at ease to give and receive feedback, people don&rsquo;t pair. Reviews suffer from this as well, either not going in the depth of things, or ending bad !</li>
<li>Some team members might have difficulties explaining what they are doing to others.</li>
</ul>


<p>Believe it of not, Randoris can help you with all these issues.</p>

<h2>What is a Randori ?</h2>

<h3>A Coding dojo</h3>

<p>A coding dojo is a meeting where programmers deliberately practice their skills. To be effective, the coding dojo should be regular, and safe. Created to spread TDD (<a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>), it&rsquo;s an effective way to teach other skills as well. Whatever the goal, it should use TDD. TDD sets up the fast feedback loop necessary to collaboration and effective learning. The dojo should end with a short retrospective : everyone stops what they are doing to discuss how it went.</p>

<p>People have invented many formats to the coding dojo, but there were only 2 at the origin. The Kata, where someone live codes a prepared solution to a problem using TDD. The Randori which I&rsquo;ll detail right away.</p>

<h3>A Randori</h3>

<p>In a Randori, you&rsquo;ll be using a single machine, a wide screen and a timer. Pairs of programmers round-rob at the keyboard every 5 minutes or so. Particularly here, we should stick to TDD for collaboration and fast feedback loop. When the timer rings, the co-pilot gets the keyboard, and a new co-pilot comes in.</p>

<p>5 minutes are very short, and force people to use real baby steps. If they try to do something too big, they will not reach a stable state before the end of their turn. If their change is too complex, others will get lost, and remove the code. The pair needs to collaborate a lot for others to understand and continue in the same direction. They have to explain what they are doing, and take feedback into account as much as they write code.</p>

<p><a href="https://www.youtube.com/watch?v=vqnwQ3oVM1M"><img src="../imgs/2018-02-20-why-you-should-start-a-team-coding-dojo-randori-right-now/randori.jpg" alt="Programmers doing a randori" /></a><div class="image-credits">From a <a href="https://www.youtube.com/watch?v=vqnwQ3oVM1M">YouTube video</a> by <a href="http://globo.com">globo.com</a></div></p>

<h3>Your team</h3>

<p>A team Randori is a Randori with your team. It improves all the problems I listed above.</p>

<ul>
<li>People will share coding conventions and design best practices. They are likely to agree on something for the sake of progress in a 2 hours session. The opportunity to see how the convention works with dojo code often leads to a production code agreement.</li>
<li>People will share IDE shortcuts and tricks.</li>
<li>The constant feedback will make people accustomed to it.</li>
<li>On top of that, people will refactor or have their code refactored from time to time. This is a great lesson in egoless programming.</li>
</ul>


<blockquote><p>üí° Coding Dojo Randoris are a great lesson in Egoless Programming</p></blockquote>

<p>I hope I convinced you that you should start team coding dojo Randoris. In my <a href="/how-to-start-a-team-coding-dojo-randori-today/">next post</a>, I&rsquo;ll go into more details about how to setup and run your first Randori.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Throwing code away frequently]]></title>
    <link href="http://philippe.bourgau.net/throwing-code-away-frequently/"/>
    <updated>2017-09-01T06:56:00+02:00</updated>
    <id>http://philippe.bourgau.net/throwing-code-away-frequently</id>
    <content type="html"><![CDATA[<p>Here is the main feedback I got about my previous post <a href="/extreme-extreme-programming-2017/">eXtreme eXtreme Programming</a>.</p>

<blockquote><p>What do you actually mean by throwing code away ? Does it mean stoping unit testing and refactoring ?</p></blockquote>

<p><img src="../imgs/2017-09-01-throwing-code-away-frequently/shredder.jpeg" alt="A drawing of a shredder destroying some code" /></p>

<p>So I guess it deserves a bit of explanation.</p>

<h2>What is it all about ?</h2>

<p>When programming, I don&rsquo;t throw code away a lot. I tend to rely on my automated tests to change the code I already have. That might be a problem.</p>

<p>As with everything, there is no one size fits all. We should choose the best practice for our current situation. Same thing applies for incremental changes versus rewriting.</p>

<p>TDD makes incremental changes cost effective, and as such, is a key to get out of the Waterfall.</p>

<p>The idea of throwing code away frequently is to make rewriting cost effective, so we can do it more often.</p>

<h2>Why would we want to do so ?</h2>

<p>In &ldquo;<a href="https://blog.codinghorror.com/when-understanding-means-rewriting/">When Understanding means Rewriting"</a>, Jeff Atwood explains that reading code can be more difficult than writing it. There is a point where rewriting is going to be cheaper than changing.</p>

<p>The more unit test you have, the later you reach that point. The more technical debt you take, and the sooner. The bigger the part to rewrite, the more risky it becomes.</p>

<p>Let&rsquo;s imagine you knew a safe way to rewrite the module you are working on. You could be faster by taking more technical debt and writing less unit tests ! Mike Cavaliere framed it as<br/>
<a href="http://mikecavaliere.com/throw-away-your-code/">F**k Going Green: Throw Away Your Code</a>.</p>

<p>This would be great for new features, that might be removed if they don&rsquo;t bring any value. It would also be a good way to get rid of technical debt. Naresh Jain also makes the point that without tests, you&rsquo;ll have to keep things simple (<a href="https://blogs.agilefaqs.com/2008/10/07/throwing-away-code/">here</a> and <a href="https://fr.slideshare.net/nashjain/the-decline-and-fall-of-agile-antifragile-mindset-to-rescue">here</a>) !</p>

<p>Wait a minute, isn&rsquo;t that <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a> ?</p>

<h2>How to make it work</h2>

<p><a href="/extreme-extreme-programming-2017/"><img src="../imgs/2017-09-01-throwing-code-away-frequently/xxp.jpg" alt="A graph with all the practices from my previous article eXtreme eXtreme Programming" /></a></p>

<h3>How to ensure quality without unit tests ?</h3>

<p>TDD and unit testing is a cornerstone of XP. If we remove it, we need something else to build quality in. Could Mob Programming and Remote teams do the trick ?</p>

<p>&ldquo;Given enough eyeballs, all bugs are shallow&rdquo;. Pair programming and code reviews catch a lot more bugs than solo programming. Only a few bugs are likely to pass through the scrutiny of the whole team doing mob programming.</p>

<p>What about Remote ? Martin Fowler <a href="https://martinfowler.com/articles/remote-or-co-located.html">explains</a> that remote teams perform better by hiring the best. Skills of programmers have been known for a long time as a main driver of software quality.</p>

<p><a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/"><img src="../imgs/2017-09-01-throwing-code-away-frequently/ProductivityVariation.jpg" alt="People vs methodology impact on productivity" /></a><div class="image-credits">Photo from Steve McConnell on <a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/">Construx</a></div></p>

<p>Finally, the Cucumber team <a href="https://cucumber.io/blog/2015/12/21/the-mob-rules-ok">reported</a> that Mob Programming works well for remote teams.</p>

<h3>How to make this safer ?</h3>

<p>Even with the best team, mistakes will happen. How can we avoid pushing a rewrite that crashes the whole system ?</p>

<p>The main answer to that is good continuous deployment. We should deploy to a subset of users first. We should be able to rollback straight away if things don&rsquo;t work as expected.</p>

<p>As the system grows, <a href="https://en.wikipedia.org/wiki/Microservices">microservices</a> can keep continuous deployment under control. We can deploy, update and roll them back independently. By nature, microservices also reduce the scope of the rewrite. That alone, as we said earlier, makes rewrites safer.</p>

<p>As a last point, some technologies make building microservice systems easier and incremental. The <a href="https://stackoverflow.com/questions/16779162/what-kind-of-virtual-machine-is-beam-the-erlang-vm">Erlang VM</a>, for example, with first class actors, is one these. Time to give <a href="https://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a> a try !</p>

<h3>Is this always a good idea ?</h3>

<p>There are good and bad situations.</p>

<p>For example, a lean startup or data driven environment seems a good fit. Suppose your team measures the adoption of new features before deciding to keep or ditch them. You&rsquo;d better not invest in unit tests straight away.</p>

<p>On the other side, software for a complex domain will be very difficult to rewrite flawlessly. I have worked in the finance industry for some years, I know what a complex domain is. I doubt I could rewrite a piece of intricate finance logic without bugs. I would stick to <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a> and unit testing in these areas.</p>

<h3>How to dip your toe</h3>

<p>Here is how I intend to dip <em>my</em> toe. I won&rsquo;t drop automated testing completely yet. What I could do instead (and that I already did on side projects) is to start with end to end tests only.</p>

<p>From there every time I want to change a piece of code, I have many options :</p>

<ul>
<li>Add a new end to end test and change the code.</li>
<li>If the code is too much of a mess, I can rewrite it from scratch. I&rsquo;ll have the safety of the end to end tests.</li>
<li>If I see that the module is stabilizing, has not been rewritten for a while, and yields well to modifications. I could start splitting end to end tests into unit tests, and embark on the TDD road.</li>
</ul>


<p>Maybe later, when I have a team doing mob programming to find my mistakes, we&rsquo;ll skip the end to end tests.</p>

<h2>Other interesting links</h2>

<ul>
<li><a href="http://corgibytes.com/blog/2016/11/01/throwaway-code/">Throwaway Code</a> by M. Scott Ford</li>
<li><a href="http://wiki.c2.com/?RewriteCodeFromScratch">Rewrite Code From Scratch</a> on c2 wiki</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forget unit tests, only fast tests matter]]></title>
    <link href="http://philippe.bourgau.net/forget-unit-tests/"/>
    <updated>2017-08-08T06:24:00+02:00</updated>
    <id>http://philippe.bourgau.net/forget-unit-tests</id>
    <content type="html"><![CDATA[<p>Don&rsquo;t worry if your unit tests go to the DB, that might not be so bad.</p>

<p>When I started writing unit tests, I did not know what these were. I read <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=126923">the definition</a>, and strived to follow the recommandations :</p>

<ul>
<li>they should be independent from each other</li>
<li>they should not access the DB</li>
<li>they should not use the network</li>
<li>they should only cover a small scope of your code</li>
</ul>


<p>I started to write unit tests on my own and became <a href="http://wiki.c2.com/?TestInfected">test infected</a> pretty fast. Once I got convinced of the benefits of unit testing, I tried to spread the practice around me. I used to explain to people that it is very important to write real unit tests by the book. Otherwise, <em>Bad Things</em> would happen &hellip;</p>

<h2>How I changed my mind</h2>

<p>A few years ago, I spent a few years working on a <a href="http://rubyonrails.org/">Rails</a> side project called <a href="https://github.com/philou/mes-courses">mes-courses.fr</a>. I was using a small test gem to enforce that no unit tests were accessing the db. I had to write a lot of mocks around the code. I ended up hating mocks : they are too painful to maintain and provide a false sense of security. I&rsquo;m not alone in this camp, check <a href="https://www.youtube.com/watch?v=9LfmrkyP81M">DHH&rsquo;s keynote at RailsConf 2014</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/9LfmrkyP81M" frameborder="0" allowfullscreen></iframe>


<p>At some point, the mock pain got so bad that I stopped all developments until I found another way. I found a pretty simple workaround : use in-memory SQLite. I got rid of all the DB access mocks. Not only were the tests easier to write and maintain, but they were as fast as before, and they covered more code.</p>

<p>That changed something fundamental in my understanding of testing</p>

<h2>It&rsquo;s all about speed baby</h2>

<p>The only thing that makes unit tests so important is that they run fast.</p>

<p>Unit tests as described in the literature run fast. Let&rsquo;s see what happens when you remove one of the recommandations for unit tests.</p>

<ul>
<li>If tests depend on each other, their outcome will change with the execution order. This wastes our time in analyzing the results. On top of that, independent unit tests are easy to run in parallel, providing an extra speedup. We lose this potential when our tests are dependent.</li>
<li>Tests that rely on an out-of-process DB run slower. Tests need to start the DB before anything else. Data needs to be setup and cleaned at every test. Accessing the DB implies using the network, which takes time as well. There&rsquo;s also a risk of making the tests dependent by sharing the same DB. A last issue is troubleshooting the DB process when things don&rsquo;t work.</li>
<li>Tests that use the network are slow too ! First, Network is slower than memory. Second, data serialization between processes is slow as well. Finally, these tests are likely to use some form of sleep or polling, which is slow, fragile, or both !</li>
<li>Finally, there is always a scope past which a test will be too slow.</li>
</ul>


<p>This means that not only unit tests are fast, but also that fast tests usually show the features of unit tests.</p>

<p>My guess is that &lsquo;unit tests&rsquo; were explicitly defined as a recipe for fast tests ! If you stick to the definition of unit tests, you&rsquo;ll get fast tests and all their benefits.</p>

<p><img src="../imgs/2017-08-08-forget-unit-tests/speedometer.jpg" alt="A speedometer" /></p>

<h2>Fast tests</h2>

<p>That also means that we should focus first on having fast tests rather than unit tests. Here is my real check to know if tests are fast enough :</p>

<ul>
<li>Is the build (and the tests and everything) less than 10 minutes ?</li>
<li>Can I continuously run my tests while coding and stay in the flow ?</li>
</ul>


<p>If both answers are yes, then I won&rsquo;t question myself too much whether my tests are unit, integration or end to end.</p>

<h2>So what ?</h2>

<p>I&rsquo;ve been experimenting with these heuristics for some time. Side projects are great for experimenting since you don&rsquo;t have a team to convince ! Here are my main takeaways :</p>

<ul>
<li>Stick to end to end tests at the beginning of your project. They are easy to refactor to finer grained tests later on.</li>
<li>In-memory DBs are great to speed tests up without wasting your time with mocking.  We can use a unique DB for every test to keep them independent.</li>
<li>Large scope tests are not an issue provided 2 things.

<ol>
<li>The code contains very few side effects.</li>
<li>It provides good exceptions and assertions messages</li>
</ol>
</li>
</ul>


<p>On the other side, there are things that I still recommend :</p>

<ul>
<li>Independent tests are easy to write from the beginning, difficult to fix later on. As they save a lot of headaches in diagnostic, I stick to them from the start.</li>
<li>Avoid network, it makes the tests slow, fragile and tricky to diagnostic. But please, read <a href="http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb/">this</a> before jumping to mocks.</li>
</ul>


<p>These rules have served me well, particularly in my side projects, where I don&rsquo;t have a lot of time. What about you ? Do you have your own testing rules ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't stick to TDD's Red-Green-Refactor loop to the letter]]></title>
    <link href="http://philippe.bourgau.net/dont-stick-to-tdds-red-green-refactor-loop-to-the-letter/"/>
    <updated>2017-06-28T15:52:00+02:00</updated>
    <id>http://philippe.bourgau.net/dont-stick-to-tdds-red-green-refactor-loop-to-the-letter</id>
    <content type="html"><![CDATA[<p>As long as you are writing your tests before your code and doing regular refactoring, you are doing <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !</p>

<p>The Red &ndash; Green &ndash; Refactor loop is useful to introduce TDD to new developers. Different loops can be more effective in real world situation.</p>

<p>The Red &ndash; Green &ndash; Refactor loop is not a dogma !</p>

<p><a href="http://www.natpryce.com/"><img src="../imgs/2017-06-28-dont-stick-to-tdds-red-green-refactor-loop-to-the-letter/red-green-refactor.jpg" alt="The famous red, green, refactor TDD loop" /></a></p>

<h2>Refactor &ndash; Red &ndash; Green</h2>

<p>When I work on a story, I very often keep a TODO list next to my desk. I use it to keep track of the next steps, the edge cases to test, the code smells and refactorings to do.</p>

<p>When I get to the end of the story, all that remains of this list is a few refactorings. Very often, I don&rsquo;t do them !</p>

<p>With the feature working, doing these refactorings feels like violation of <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>. Next time we&rsquo;ll have to work on this part of the code, we&rsquo;ll have a story to serve as guide to which refactorings to do.</p>

<p>The same thing is effective at the unit test scale. It&rsquo;s easier to refactor when you know the test you want to add. Refactor to make this test easy to write !</p>

<p>Here is an example with <a href="https://en.wikipedia.org/wiki/Fizz_buzz">Fizz Buzz</a></p>

<p>```java
static int fizzBuzz(int number) {
¬†¬†¬†return number;
}</p>

<p>@Test public void
it_is_1_for_1() {
¬†¬†¬†assertThat(fizzBuzz(1)).isEqualTo(1);
}</p>

<p>@Test public void
it_is_2_for_2() {
¬†¬†¬†assertThat(fizzBuzz(2)).isEqualTo(2);
}
```</p>

<p>Here is the test I&rsquo;d like to add.¬†</p>

<p><code>java
@Test public void
it_is_Fizz_for_3() {
¬†¬†¬†assertThat(fizzBuzz(3)).isEqualTo("Fizz");
}
</code></p>

<p>Unfortunately, fizzBuzz needs to return a String instead of an integer for it to compile. That&rsquo;s when I would refactor before adding the new test.</p>

<p>```java
static String fizzBuzz(int number) {
¬†¬†¬†return Integer.toString(number);
}</p>

<p>@Test public void
it_is_1_for_1() {
¬†¬†¬†assertThat(fizzBuzz(1)).isEqualTo(&ldquo;1&rdquo;);
}</p>

<p>@Test public void
it_is_2_for_2() {
¬†¬†¬†assertThat(fizzBuzz(2)).isEqualTo(&ldquo;2&rdquo;);
}
```</p>

<p>In the end, this loop is very like the classic TDD loop :</p>

<p><code>
red-green-refactor-red-green-refactor-red-green-refactor.............
..........refactor-red-green-refactor-red-green-refactor-red-green...
</code></p>

<p>A bit more YAGNI, that&rsquo;s all.</p>

<h2>Red &ndash; Better Red &ndash; Green &ndash; Refactor</h2>

<p>A few weeks ago, <a href="/speed-up-the-tdd-feedback-loop-with-better-assertion-messages/">I wrote about error messages in unit tests</a>. To summarize, extra work on error messages reduces the testing feedback loop.</p>

<p>We can translate this focus on error messages into an extra TDD step. Whatever the TDD loop you are using, you can add this step after the Red step.</p>

<h2><del>Red</del> &ndash; Green &ndash; Refactor &ndash; Red &ndash; Green</h2>

<p>Sometimes, it makes sense to refactor before fixing the test. The idea is to rely on the existing tests to prepare the code to fix the new test in one line.</p>

<p>Let&rsquo;s take our Fizz Buzz example again. Imagine we finished the kata, when we decide to tweak the rules and try Fizz Buzz Bang. We should now print Bang on multiples of 7.</p>

<p>Here is our starting point :</p>

<p>```java
static String fizzBuzz(int number) {
¬†¬†¬†if (multipleOf(number, 3)) {
¬†¬†¬†¬†¬†¬†return &ldquo;Fizz&rdquo;;
¬†¬†¬†}
¬†¬†¬†if (multipleOf(number, 5)) {
¬†¬†¬†¬†¬†¬†return &ldquo;Buzz&rdquo;;
¬†¬†¬†}
¬†¬†¬†if (multipleOf(number, 3*5)) {
¬†¬†¬†¬†¬†¬†return &ldquo;FizzBuzz&rdquo;;
¬†¬†¬†} ¬†¬†
¬†¬†¬†return Integer.toString(number);
}</p>

<p>&hellip;</p>

<p>@Test public void
it_is_Bang_for_7() {
¬†¬†¬†assertThat(fizzBuzz(7)).isEqualTo(&ldquo;Bang&rdquo;);
}
```</p>

<p>I could go through all the hoops, 7, 14, then 3<em>7, 5</em>7 and finally 3<em>5</em>7 &hellip; By now, I should know the music though !</p>

<p>What I would do in this case is :</p>

<ul>
<li>first to comment the new failing test to get back to green</li>
<li>refactor the code to prepare for the new code</li>
<li>uncomment the failing test</li>
<li>fix it</li>
</ul>


<p>In our example, here is the refactoring I would do</p>

<p>```java
static String fizzBuzz(int number) {
¬†¬†¬†String result = &ldquo;&rdquo;;
¬†¬†¬†result += multipleWord(number, 3, &ldquo;Fizz&rdquo;);
¬†¬†¬†result += multipleWord(number, 5, &ldquo;Buzz&rdquo;);
¬†¬†¬†if (result.isEmpty()) {
¬†¬†¬†¬†¬†¬†result = Integer.toString(number);
¬†¬†¬†}
¬†¬†¬†return result;
}</p>

<p>private static String multipleWord(int number, int multiple, String word) {
¬†¬†¬†if (multipleOf(number, multiple)) {
¬†¬†¬†¬†¬†¬†return word;
¬†¬†¬†}
¬†¬†¬†return &ldquo;&rdquo;;
}</p>

<p>&hellip;</p>

<p>//@Test public void
//it_is_Bang_for_7() {
// ¬†¬†assertThat(fizzBuzz(7)).isEqualTo(&ldquo;Bang&rdquo;);
//}
```</p>

<p>From there, fixing the test is dead simple.</p>

<p>In practice I find this loop very useful. At local scale as we saw but it&rsquo;s also a great way to refactor your architecture at larger scale.</p>

<p>One downsize is that if you are not careful, it might lead to over-engineering. Be warned, keep an eye on that !</p>

<p>Last caveat : not all TDD interviewers like this technique &hellip;</p>

<h2>Don&rsquo;t obsess</h2>

<p>It&rsquo;s not because you are not following the Red Green Refactor loop to the letter that you are not doing TDD.</p>

<p>An interesting point is that these variations to the TDD loop are combinable ! Experienced TDD practitioners can jump from one to the other without even noticing.</p>

<p><a href="https://blog.acolyer.org/2017/06/13/a-dissection-of-the-test-driven-development-process-does-it-really-matter-to-test-first-or-test-last/">This paper</a> argues that as long as you write the tests along (before or after) the code, you get the same benefit. That&rsquo;s not going to make me stop writing my tests first, but it is interesting. That would mean that even a Code &ndash; Test &ndash; Refactor loop would be ok if it is fast enough !</p>
]]></content>
  </entry>
  
</feed>
