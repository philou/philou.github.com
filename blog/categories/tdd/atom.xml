<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-05-03T06:12:41+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Immutable Value Objects vs Mocks : Fizz Buzz]]></title>
    <link href="http://philippe.bourgau.net/immutable-value-objects-vs-mocks-fizz-buzz/"/>
    <updated>2018-05-03T19:28:00+02:00</updated>
    <id>http://philippe.bourgau.net/immutable-value-objects-vs-mocks-fizz-buzz</id>
    <content type="html"><![CDATA[<p>In my <a href="/how-immutable-value-objects-fight-mocks/">previous post</a> I explained how <a href="https://martinfowler.com/bliki/ValueObject.html">Immutable Value Objects</a> help us to avoid mocks. In this post, I&rsquo;ll illustrate this in practice with real code.</p>

<p>This is the third post on a <a href="/blog/categories/how-to-avoid-mocks-series/">series about how to avoid mocks</a>. If you haven&rsquo;t, you can start reading the full story <a href="/careless-mocking-considered-harmful/">here</a>.</p>

<p><img src="../imgs/2018-04-17-immutable-value-objects-vs-mocks-fizz-buzz/immutable-fizz-buzz.jpg" alt="A drawing &quot;FIZZ BUZZ&quot; rock fallen and sealed in the ground" /></p>

<h2>Fizz Buzz Example</h2>

<p>As a simple example, I&rsquo;ll go through the classic <a href="http://codingdojo.org/kata/FizzBuzz/">Fizz Buzz</a>. I&rsquo;ve implemented and tested it with and without immutable value objects. Please keep in mind that this is a toy example, where problems are obvious and easily fixed. I try to highlight at small scale the same problems that get hidden by the complexity of a large scale program.</p>

<p>Let&rsquo;s start with a typical FizzBuzz implementation.</p>

<p>```ruby
1.upto(100) do |i|
  if (i%3 == 0 and i%5 == 0)</p>

<pre><code>STDOUT.puts("FizzBuzz\n")
</code></pre>

<p>  elsif (i%3 == 0)</p>

<pre><code>STDOUT.puts("Fizz\n")
</code></pre>

<p>  elsif (i%5 == 0)</p>

<pre><code>STDOUT.puts("Buzz\n")
</code></pre>

<p>  else</p>

<pre><code>STDOUT.puts("#{i}\n")
</code></pre>

<p>  end
end
```</p>

<p>Suppose you need to add some tests around the code. The most straightforward way is to mock <code>STDOUT</code> :</p>

<p>```ruby
require &lsquo;rspec&rsquo;</p>

<p>def fizzBuzz(max, out)
  1.upto(max) do |i|</p>

<pre><code>if (i%3 == 0 and i%5 == 0)
  out.puts("FizzBuzz\n")
elsif (i%3 == 0)
  out.puts("Fizz\n")
elsif (i%5 == 0)
  out.puts("Buzz\n")
else
  out.puts("#{i}\n")
end
</code></pre>

<p>  end
end</p>

<h1>main</h1>

<p>fizzBuzz(100,STDOUT)</p>

<p>describe &lsquo;Mockist Fizz Buzz&rsquo; do</p>

<p>  it &lsquo;should print numbers, fizz and buzz&rsquo; do</p>

<pre><code>out = double("out")
expect(out).to receive(:puts).with("1\n").ordered
expect(out).to receive(:puts).with("2\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("4\n").ordered
expect(out).to receive(:puts).with("Buzz\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("7\n").ordered
expect(out).to receive(:puts).with("8\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("Buzz\n").ordered
expect(out).to receive(:puts).with("11\n").ordered
expect(out).to receive(:puts).with("Fizz\n").ordered
expect(out).to receive(:puts).with("13\n").ordered
expect(out).to receive(:puts).with("14\n").ordered
expect(out).to receive(:puts).with("FizzBuzz\n").ordered

fizzBuzz(15, out)
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>Unfortunately, there are a few problems with this code :</p>

<ul>
<li>With nested logic and complicated mock setup, both code and tests aren&rsquo;t very readable</li>
<li>They both seem to violate the single responsibility principle as well</li>
<li>It&rsquo;s depending on a mutable output. Within a larger program, something could be messing around with this output stream. That would break FizzBuzz.</li>
</ul>


<p>Let&rsquo;s now try to use as many immutable values objects as possible, and see what happens to the mocks.</p>

<p>```ruby
require &lsquo;rspec&rsquo;</p>

<h1>We extracted a function to do the fizz buzz on a single number</h1>

<p>def fizzBuzzN(i)
  if (i%3 == 0 and i%5 == 0)</p>

<pre><code>"FizzBuzz"
</code></pre>

<p>  elsif (i%3 == 0)</p>

<pre><code>"Fizz"
</code></pre>

<p>  elsif (i%5 == 0)</p>

<pre><code>"Buzz"
</code></pre>

<p>  else</p>

<pre><code>i.to_s
</code></pre>

<p>  end
end</p>

<h1>We replaced the many calls to STDOUT.puts by building a single</h1>

<h1>large (and immutable) string</h1>

<p>def fizzBuzz(max)
  ((1..max).map {|i| fizzBuzzN(i)}).join(&ldquo;\n&rdquo;)
end</p>

<h1>main, with a single call to STDOUT.puts</h1>

<p>STDOUT.puts fizzBuzz(100)</p>

<p>describe &lsquo;Statist Fizz Buzz&rsquo; do</p>

<p>  it &lsquo;should print numbers not multiples of 3 or 5&rsquo; do</p>

<pre><code>expect(fizzBuzzN(1)).to eq("1")
expect(fizzBuzzN(2)).to eq("2")
expect(fizzBuzzN(4)).to eq("4")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print Fizz for multiples of 3&rsquo; do</p>

<pre><code>expect(fizzBuzzN(3)).to eq("Fizz")
expect(fizzBuzzN(6)).to eq("Fizz")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print Buzz for multiples of 3&rsquo; do</p>

<pre><code>expect(fizzBuzzN(5)).to eq("Buzz")
expect(fizzBuzzN(10)).to eq("Buzz")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print FizzBuzz for multiples of 3 and 5&rsquo; do</p>

<pre><code>expect(fizzBuzzN(15)).to eq("FizzBuzz")
expect(fizzBuzzN(30)).to eq("FizzBuzz")
</code></pre>

<p>  end</p>

<p>  it &lsquo;should print numbers, fizz and buzz&rsquo; do</p>

<pre><code>expect(fizzBuzz(15)).to start_with("1\n2\nFizz").and(end_with("14\nFizzBuzz"))
</code></pre>

<p>  end
end
```</p>

<p>As we can see, using immutable value objects got us rid of the mocks. Obviously, this new code will not be as efficient as the original version, but most of the time, this does not matter. As a bonus though we get finer grain and more readable tests.</p>

<h3>Other testing advantages</h3>

<p>Appart from preventing mocks, Immutable Value Objects have other advantages related to testing.</p>

<ul>
<li>We can directly assert their equality, without having to dig into their guts</li>
<li>We can call methods as many times as we want, without the risk of changing anything and breaking the tests</li>
<li>Immutable Value Objects are a lot less likely to contain invalid state. This removes the need for a whole range of validity tests.</li>
</ul>


<blockquote><p>ðŸ’¡ Immutable Value Objects simplify testing in many ways.</p></blockquote>

<h3>Convincing your teammates</h3>

<p>We&rsquo;ve seen that Immutable Value Objects have a ton of advantages when testing. People have found that they also have many other benefits :</p>

<ul>
<li><a href="https://www.linkedin.com/pulse/20140528113353-16837833-6-benefits-of-programming-with-immutable-objects-in-java/">6 Benefits of Programming with Immutable Objects in Java</a></li>
<li><a href="https://hackernoon.com/5-benefits-of-immutable-objects-worth-considering-for-your-next-project-f98e7e85b6ac">5 Benefits of Immutable Objects Worth Considering for Your NextÂ Project</a></li>
</ul>


<p>Surprisingly though, it&rsquo;s difficult to persuade programmers to use more immutability. It&rsquo;s tricky to explain why returning a modified copy is simpler than just adding a setter.</p>

<blockquote><p>ðŸ’¡ Why is it so hard to persuade other developers to use immutable data structures ?</p></blockquote>

<p>I had the most success by far when encountering a bug resulting of share mutable state. When this happens, the long term benefits and safety of the immutable design wins people over. The good thing is that as you convince more people in the team, immutability will spread like a virus !</p>

<p>Outside of this situation, you might try some of the following arguments to move people :</p>

<ul>
<li>Immutable values prevent bugs caused by different parts of the system changing the same mutable state</li>
<li>They make it easier to deal with the program in smaller parts and to reason about the system in general</li>
<li>Immutable values don&rsquo;t need any synchronization and make multithreaded programming easier</li>
<li>When tempted to add a simple setter instead of keeping a class immutable, highlight the stressful debugging time to come</li>
<li>If you&rsquo;re dealing with a Design By Contract adept, explain how <a href="/almost-15-years-of-using-design-by-contract/">immutability has it built-in</a></li>
<li>Admit that mainstream languages have bad support for Immutable Value. Point to patterns like <a href="https://dzone.com/articles/immutability-with-builder-design-pattern">Data Builders</a> that work around these limitation</li>
</ul>


<h2>Next post</h2>

<p>I&rsquo;m done with immutable value objects. It was a far longer post than I thought, but there was a lot to say. This was the third post in a <a href="/blog/categories/how-to-avoid-mocks-series/">series about avoiding mocks</a>. In next post, I&rsquo;ll dig into another small scale mock fighting pattern : <a href="http://www.natpryce.com/articles/000714.html">Test Data Builders</a>.</p>

<p><a href="https://feedburner.google.com/fb/a/mailverify?uri=PhilippeBourgau&amp;loc=en_US">Stay tuned !</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Immutable Value Objects fight Mocks]]></title>
    <link href="http://philippe.bourgau.net/how-immutable-value-objects-fight-mocks/"/>
    <updated>2018-04-26T08:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-immutable-value-objects-fight-mocks</id>
    <content type="html"><![CDATA[<p>Excessive use of mocks makes tests very painful to maintain. If we stick painful mocks for too long, we&rsquo;ll end up abandoning unit testing. Eventually, the system will degrade into legacy.Â </p>

<p>There are many techniques to avoid mocks. Some of the most effective involve architecture changes. Unfortunately, there are not the most straightforward to use. Re-architecting involves people and time that you may not dispose of right now. In the following posts, I&rsquo;ll go over techniques that any developer can use in his day to day code to avoid mocks. These battle tested techniques that I&rsquo;ve used on different projects in the past. Check <a href="/careless-mocking-considered-harmful/">the previous post</a> if you&rsquo;re interested to learn how I came to use them.</p>

<p>This is the second post <a href="/blog/categories/how-to-avoid-mocks-series/">of a series about how to avoid mocks</a> in automated tests. If you haven&rsquo;t yet, I recommend you to read my <a href="/careless-mocking-considered-harmful/">first post</a> to understand the perils of mocks in more details.</p>

<p>The first mock fighting small-scale technique I&rsquo;ll go over is <a href="https://martinfowler.com/bliki/ValueObject.html">Immutable Value Objects</a>.</p>

<p><img src="../imgs/2018-04-17-how-immutable-value-objects-fight-mocks/immutable-rock.jpg" alt="A drawing of a rock written &quot;Immutable Value Object&quot;" /></p>

<h2>What are Immutable Value Objects ?</h2>

<p>Behind this weird name is something very simple to understand. Immutable Value Objects :</p>

<ul>
<li>Cannot change their state after construction</li>
<li>Only depend on other Immutable Value Objects</li>
<li>Don&rsquo;t change the state of the whole system in any way</li>
<li>Don&rsquo;t do side effects, like inputs and outputs for example</li>
</ul>


<p>Eric Evans popularized the name in the <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_2?ie=UTF8&amp;qid=1523985269&amp;sr=8-2&amp;keywords=domain+driven+design">Domain-Driven Design Blue Book</a>. Immutable Value Objects have existed for decades in functional languages though. We say these objects are immutable (they cannot change) and pure (they cannot do side effects). Here are 2 interesting properties of Value Objects :</p>

<ul>
<li>you can call a method any number of times with no risk of changing anything to the system</li>
<li>you&rsquo;ll always get the same result every time you call the same method on the same object</li>
</ul>


<p>These by itself, can already be handy when testing.</p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_2?ie=UTF8&amp;qid=1523985269&amp;sr=8-2&amp;keywords=domain+driven+design"><img src="../imgs/2018-04-17-how-immutable-value-objects-fight-mocks/ddd.jpg" alt="Cover of Eric Evans's DDD book" /></a></p>

<h2>How do they prevent mocks ?</h2>

<p>That was a bit theoretical, so let&rsquo;s see how this helps to reduce mocking.</p>

<h3>Simpler &ldquo;init path&rdquo;</h3>

<p>Let&rsquo;s take it the other way round and see how side effects can lead to mocking. Every test starts with setting the state in which to run the test. Side effects make this complicated, as many objects need to collaborate to set this state up. When this becomes too painful, people start hacking around with mocks. This in turn makes the tests more fragile :</p>

<ul>
<li>We are not testing a &ldquo;real&rdquo; situation</li>
<li>We need to keep this setup in line with the real code</li>
</ul>


<blockquote><p>ðŸ’¡ Intricate state initialization encourage people to use mocks.</p></blockquote>

<h3>Isolates parts of the system</h3>

<p>Unfortunately, that is not all the story ! Mutable state also, tricks us into using mocks. As soon as your test deals with mutable state, there is a chance that this state is changed in the &lsquo;real&rsquo; system. This means that some bugs might &lsquo;escape&rsquo; unit tests and appear in end to end tests or in production. That&rsquo;s where the mocks strike ! In order to detect this bug in a fast feedback loop, we&rsquo;re likely to add larger scope tests and use mocks to speed them up &hellip;</p>

<blockquote><p>ðŸ’¡ Mutable state and side effects make unit tests less effective.</p></blockquote>

<h3>Reduces code with side effects</h3>

<p>But there&rsquo;s another reason why Immutable Value Objects help us to avoid mocks. As we&rsquo;ll try to use them more and more for the previous two reasons, we&rsquo;ll need to adapt our programming style. As we&rsquo;ll push more and more code in Immutable Value Objects, the &lsquo;imperative&rsquo; part will shrink. This &lsquo;imperative&rsquo; part is where side-effect happen. This is the part where mocking out IOs makes sense. To summarize, the more Immutable Value Objects we use, the more isolated the IOs are, and the less mocking we need.</p>

<p>Javascript expert Eric Elliot also wrote about the immutability and mocks <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">here</a>.</p>

<h2>Next week</h2>

<p>This was the second post in a <a href="/blog/categories/how-to-avoid-mocks-series/">series about how to prevent mocks</a> in your automated tests. <a href="/immutable-value-objects-vs-mocks-fizz-buzz/">Next post</a> will be an example of using immutable value objects on the <a href="http://codingdojo.org/kata/FizzBuzz/">FizzBuzz kata</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Careless Mocking Considered Harmful]]></title>
    <link href="http://philippe.bourgau.net/careless-mocking-considered-harmful/"/>
    <updated>2018-04-19T13:13:00+02:00</updated>
    <id>http://philippe.bourgau.net/careless-mocking-considered-harmful</id>
    <content type="html"><![CDATA[<blockquote><p>ðŸ’¡ Mock hell : when excessive use of test mocks makes <a href="https://en.wikipedia.org/wiki/Code_refactoring">refactoring</a> extremely slow or difficult.</p></blockquote>

<p>A few years ago, I managed to get a side project out of mock hell. Since then, I&rsquo;ve been using what I learned to avoid mocks in all the projects I&rsquo;ve worked on. This is the start of a series of posts about my mock-avoiding techniques.</p>

<p><img src="../imgs/2018-04-10-careless-mocking-considered-harmful/mocks-dont-rock.jpg" alt="A tag &quot;Mocks don't rock !&quot;" /></p>

<h2>Escape from Mock Hell</h2>

<p>Between 2010 and 2014, I was working on a side project I called <a href="https://github.com/philou/mes-courses">http://mes-courses.fr</a>. Which actually means &ldquo;my house shopping&rdquo; in English. I wanted people to be able to do their house shopping in 5 minutes, by using a better UI for online groceries. I was using Ruby, and I had just read <a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;qid=1523422024&amp;sr=8-1&amp;keywords=growing+object-oriented+software+guided+by+tests">Growing Object Oriented Software Guided by Tests</a>. I got a bit too excited with mocking, and was using it way too much.</p>

<p>I&rsquo;d been practicing <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a> for more than 5 years and I was expecting great results with a language like Ruby. After a few months though, I could feel that something was not going as well as it should. The test initialization code was getting longer and longer, as it included a lot of mock setup. This made the tests more complex and less readable. It also made them unreliable, as it was not rare for all my unit tests to pass while the system was not working. I was taking the habit of running my end to end test more and more often. I was also losing a lot of time maintaining the mock setup code in line with the real classes. Mocks also tricked me into the bad practice of keeping a 1 to 1 mapping between code and test files. That again increased my maintenance burden when moving code from one file to another.</p>

<p>It reached a point where I could not take it anymore. All these problems were pointing at mocks, so I tried to remove them from a test file. Here are the techniques I ended up using to remove them mocks :Â </p>

<ul>
<li><a href="https://martinfowler.com/bliki/ValueObject.html">Value Objects</a></li>
<li><a href="http://www.natpryce.com/articles/000714.html">Test Data Builders</a></li>
<li><a href="https://relishapp.com/rspec/rspec-expectations/docs/custom-matchers">Test Matchers</a></li>
<li><a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal architecture</a></li>
<li><a href="https://www.martinfowler.com/articles/mocksArentStubs.html">In-memory fakes</a></li>
<li><a href="https://wincent.com/wiki/Proxy_(test_double">Proxy doubles</a>)</li>
</ul>


<p>The end result was beyond my hopes, as my problems almost magically disappeared. The code got simpler, I became a lot more confident about my unit tests, and they got easier to maintain. As an illustration, here is an excerpts from the diff of a rails controller test file which went through this mock diet.</p>

<p><a href="https://github.com/philou/mes-courses/commit/2c9fce17f9b59d0b3828f309015c07b17cceddf4?diff=split"><img src="../imgs/2018-04-10-careless-mocking-considered-harmful/diff.jpg" alt="A screen capture of a Github diff showing a test file going on a mock diet" /></a></p>

<h2>What&rsquo;s the long term risk ?</h2>

<p>Basically, excessive mocking arms the maintainability of the tests. Here is what would have happened if I&rsquo;d done nothing. Tests would have become so painful to maintain that I would have started to ignore or delete them. As coverage would decrease, more and more code would become untested. That&rsquo;s exactly Michael Feathers' definition of Legacy Code :</p>

<blockquote><p>Legacy Code is code without tests. <a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1523422039&amp;sr=1-1&amp;keywords=legacy+code">Michael Feathers</a></p></blockquote>

<p>To summarize, excessive use of mocks leads to legacy code ! As most of us have learned the hard way, the further a system drifts into legacy, the lower the productivity.</p>

<blockquote><p>ðŸ’¡ Excessive use of mocks leads to legacy code</p></blockquote>

<h2>Next posts</h2>

<p>Others already spoke about the dangers of mocks :</p>

<ul>
<li>Uncle Bob through <a href="http://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html">his blog</a></li>
<li>DHH in the <a href="https://www.google.fr/search?q=is+TDD+dead&amp;safe=active&amp;tbm=vid">&ldquo;Is TDD Dead&rdquo; series</a></li>
</ul>


<p>In <a href="/blog/categories/how-to-avoid-mocks-series/">this series of posts</a>, I&rsquo;ll go through the details of the different techniques I used to remove mocks. Here is my plan :</p>

<ol>
<li><a href="/careless-mocking-considered-harmful/">Careless Mocking considered Harmful</a></li>
<li><a href="/how-immutable-value-objects-fight-mocks/">How Immutable Value Objects fight mocks</a></li>
<li><a href="/immutable-value-objects-vs-mocks-fizz-buzz/">Immutable Value Objects vs Mocks : Fizz Buzz</a></li>
<li>How to use Test Data Builders to avoid mocks and keep your tests clear</li>
<li>One last small scale technique to avoid mocks : Test Matchers</li>
<li>Large scale techniques to avoid mocks</li>
<li>Mocking in special contexts like legacy and dynamically or statically typed languages</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Frequently asked questions about the 20 hours of Code Katas]]></title>
    <link href="http://philippe.bourgau.net/frequently-asked-questions-about-the-20-hours-of-code-katas/"/>
    <updated>2018-04-12T19:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/frequently-asked-questions-about-the-20-hours-of-code-katas</id>
    <content type="html"><![CDATA[<p>In my <a href="/blog/categories/20-hours-code-kata-series/">previous posts</a>, I explained how to use the 20 hours of Code Katas technique to learn new languages. If you did not read these yet, start by <a href="/how-to-learn-a-programming-language-in-just-20-hours/">the beginning</a>.</p>

<p><img src="../imgs/2018-03-26-frequently-asked-questions-about-the-20-hours-of-code-katas/faq-bulb.jpg" alt="A drawing of FAQ in a lightbulb" /></p>

<p>To close <a href="/blog/categories/20-hours-code-kata-series/">this series</a>, here are a few tips and suggestions presented as questions and answers.</p>

<h2>What if you don&rsquo;t know TDD yet ?</h2>

<p>The few <a href="http://codingdojo.org/dojo/ParisDojo/">Parisian guys</a> who invented the Coding Dojo wanted to teach and spread TDD ! You should have no problem to use it to learn TDD yourself !</p>

<blockquote><p>ðŸ’¡ The coding dojo was invented to teach and spread TDD</p></blockquote>

<p>Pick your favorite language, and schedule a kata plan to practice TDD. Watch one or two <a href="https://www.google.fr/search?q=code+kata&amp;tbm=vid">videos</a> to see how gurus are doing it. At first, you&rsquo;ll have to be very careful to stick to baby steps and the red-green-refactor loop. If you need help, check <a href="https://www.meetup.com">meetup.com</a> for local coding dojos where you&rsquo;ll find help.</p>

<h2>Can I apply this technique to learn something else than a new language ?</h2>

<p>As you might have noticed, I used it to refresh my Javascript. I went on to learn different flavors of JS, but also different test libraries. I&rsquo;ve used in to learn more advanced parts of other languages in the past.</p>

<p>Katas also work well to learn programming techniques like <a href="https://en.wikipedia.org/wiki/Code_refactoring">refactoring</a> or <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a>. Some nice people shared <a href="http://kata-log.rocks/refactoring">refactoring katas</a> on the web. To practice DDD, we could repeat katas with the constraint of using <a href="https://en.wikipedia.org/wiki/Entity">Entities</a> and <a href="https://en.wikipedia.org/wiki/Value_object">Value Objects</a> only.</p>

<p>You can even use the technique to learn other things like frameworks or tools, but you&rsquo;ll need to tune it. As I explained before, you need an exercice for deliberate practice and a fast feedback loop. We typically use a Code Katas and TDD for that, but that&rsquo;s not the only options. Whenever you can find a way to deliberately practice with a fast feedback loop, you&rsquo;re ready to go ! These days, we should look for docker images with frameworks and tools pre-installed. Going through tutorials without looking at the solutions is deliberate practice. A small live environment can give us fast enough feedback.</p>

<blockquote><p>ðŸ’¡ Find Deliberate Practice exercices and a fast feedback loop for efficient learning</p></blockquote>

<h2>What if I don&rsquo;t find any kata ?</h2>

<p>Build one yourself ! I&rsquo;m not joking, building a kata, especially one where you start from scratch is not too difficult. Inspiration comes from anything you happen to do in your daily work. Trim down a programming challenge you had to work, and you might have a kata ! Went to a programming interview ? The question you had to answer might do a nice kata.</p>

<p><img src="../imgs/2018-03-26-frequently-asked-questions-about-the-20-hours-of-code-katas/make-things-happen.jpg" alt="&quot;Make things happen&quot; written on a blackboard" /></p>

<p>Once you&rsquo;ve created and tested your kata, share it ! There are online kata repositories where you could get a chance to publish it.</p>

<ul>
<li>Â Â <a href="http://codingdojo.org/">codingdojo.org</a></li>
<li>Â Â <a href="http://cyber-dojo.org/">cyber-dojo.org</a></li>
<li>Â Â <a href="http://kata-log.rocks">kata-log.rocks</a></li>
</ul>


<h2>One last thing</h2>

<p>I just remembered I did not finish <a href="/how-to-learn-a-programming-language-in-just-20-hours/">my story about my Javascript kata plan</a>. For those wondering, here is the end of story. In the end I did not join this team to do Javascript coaching. After thinking through it for a while, I decided to stop the katas there, and move to something else. I was only 6 hours in, and what was the point to study Javascript not to use it straight away ? The day I&rsquo;ll need it, I&rsquo;m likely to have forgotten 80% of it and some of it will be outdated. The knowledge is only another 20 hours away anyway !</p>

<p>That&rsquo;s what we could call &ldquo;Just In Time Learning&rdquo; ! We are drowning in knowledge nowadays. It&rsquo;s better to have a fast and effective way to learn anything than trying to know everything.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why 20 hours of code kata are so effective for learning new languages]]></title>
    <link href="http://philippe.bourgau.net/why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/"/>
    <updated>2018-04-05T08:53:00+02:00</updated>
    <id>http://philippe.bourgau.net/why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages</id>
    <content type="html"><![CDATA[<p>In my <a href="/how-to-learn-a-programming-language-in-just-20-hours/">previous post</a>, I described how I&rsquo;ve been using 20 hours of Code Katas to learn new languages. If you did not read it yet, have a look at it first. Let&rsquo;s now look at why it works so well.</p>

<p>In <a href="https://www.amazon.com/First-20-Hours-Learn-Anything/dp/1591846943/ref=sr_1_2?ie=UTF8&amp;qid=1521785371&amp;sr=8-2&amp;keywords=the+first+20+hours">The First 20 Hours</a> Josh Kaufman explains how he learned <a href="https://www.ruby-lang.org/">Ruby</a> in 20 hours. He did not become a Ruby expert, but he was able to build and maintain a static website generator. For my part, I have succeeded to learn <a href="/how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours/">a bit of machine learning</a> using the 20 hours technique.</p>

<p>The effectiveness of the 20 hours of Code Katas relies a few key points.</p>

<p><img src="../imgs/2018-03-26-why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/why.jpg" alt="Drawing of &quot;Why ?&quot; mixed up with the inside of a clock" /></p>

<h2>Time-boxing</h2>

<p>Time-boxing has 2 main benefits. First, it forces us to stick to what is the most important for us to learn. There is no time to waste slacking around in only 20 hours. Plus it&rsquo;s a lot easier to focus for 20 hours than over a very long period of time.</p>

<p>There&rsquo;s a second great thing about time-boxing. The further you go, the less remains to do, and the less likely you are to drop the effort ! We are a lot less likely to abandon when we know we only need a few hours to finish the goal we had set to ourselves.</p>

<blockquote><p>ðŸ’¡ Time-boxing creates focus</p></blockquote>

<h2>A plan</h2>

<p>Again, the plan helps us to focus. We&rsquo;ll need to choose what gets in a 20 hours plan. Building the plan itself forces us to get a grasp of the learning space. This will help to pick the good stuff to practice.</p>

<h2>Routine</h2>

<p>Routine is a magic trick to get things done. Once we have a routine in place, we don&rsquo;t have to think or do extra efforts to find time to learn. The time is already there, we just have to use it !</p>

<h2>Deliberate practice</h2>

<p>Some exemples from &ldquo;The first 20 hours&rdquo; highlight the benefits of deliberate practice. When learning the <a href="https://en.wikipedia.org/wiki/Colemak">Colemak keyboard</a>, the author went through typing exercices. When studying the game of Go, he did practices specific situation puzzles. In both cases, deliberate practice made him learn faster. Code katas are typical deliberate practice exercices for programmers.</p>

<p><img src="../imgs/2018-03-26-why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/golf-practice.jpg" alt="Picture of a golfer deliberately practicing" /></p>

<h2>Test Driven Development</h2>

<p><a href="http://codingdojo.org/">Coding Dojos</a> are the programmers' deliberate practice. Coding Dojos traditionally rely on <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a>. TDD sets up a fast feedback loop that is key to efficient learning. Think of all the time saved by not having to run and debug a full program every time ! Even dabbling around in the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> cannot beat running 20 or so test cases every few seconds.</p>

<h2>We are already programmers</h2>

<p>One last and obvious little detail : we don&rsquo;t have to learn it all ! When the author learned Ruby in 20 hours, he was starting from scratch ! Unlike us, who already know how to program, but want to extend our knowledge to a few more topics. Most of the times, we don&rsquo;t need to relearn everything, but to transpose what we know in a new context.</p>

<p>For example, if we already know an object oriented language, learning a new one will be easier. It&rsquo;s a bit like with foreign languages, the more you know, and the easier it is to learn the next one. In fact, the more languages, frameworks, patterns and paradigms you know, the more the 20 hours code katas will work for you.</p>

<blockquote><p>ðŸ’¡ The more you know about software, the easier it will be to learn your next programming language.</p></blockquote>

<p>You might have a look at <a href="/how-to-keep-up-with-software-technologies/">this post</a> for advices about evergreen concepts to learn.</p>

<h2>Next part</h2>

<p>This was the second post on this <a href="/blog/categories/20-hours-code-kata-series/">series about the 20 hours of Code Katas technique</a>. The <a href="/frequently-asked-questions-about-the-20-hours-of-code-katas/">next, and last, post</a> will be compilation of answers to frequently asked questions.</p>
]]></content>
  </entry>
  
</feed>
