<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mocking | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/mocking/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-04-26T06:09:35+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Immutable Value Objects fight Mocks]]></title>
    <link href="http://philippe.bourgau.net/how-immutable-value-objects-fight-mocks/"/>
    <updated>2018-04-26T08:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-immutable-value-objects-fight-mocks</id>
    <content type="html"><![CDATA[<p>Excessive use of mocks makes tests very painful to maintain. If we stick painful mocks for too long, we&rsquo;ll end up abandoning unit testing. Eventually, the system will degrade into legacy.Â </p>

<p>There are many techniques to avoid mocks. Some of the most effective involve architecture changes. Unfortunately, there are not the most straightforward to use. Re-architecting involves people and time that you may not dispose of right now. In the following posts, I&rsquo;ll go over techniques that any developer can use in his day to day code to avoid mocks. These battle tested techniques that I&rsquo;ve used on different projects in the past. Check <a href="/careless-mocking-considered-harmful/">the previous post</a> if you&rsquo;re interested to learn how I came to use them.</p>

<p>This is the second post <a href="/blog/categories/how-to-avoid-mocks-series/">of a series about how to avoid mocks</a> in automated tests. If you haven&rsquo;t yet, I recommend you to read my <a href="/careless-mocking-considered-harmful/">first post</a> to understand the perils of mocks in more details.</p>

<p>The first mock fighting small-scale technique I&rsquo;ll go over is <a href="https://martinfowler.com/bliki/ValueObject.html">Immutable Value Objects</a>.</p>

<p><img src="../imgs/2018-04-17-how-immutable-value-objects-fight-mocks/immutable-rock.jpg" alt="A drawing of a rock written &quot;Immutable Value Object&quot;" /></p>

<h2>What are Immutable Value Objects ?</h2>

<p>Behind this weird name is something very simple to understand. Immutable Value Objects :</p>

<ul>
<li>Cannot change their state after construction</li>
<li>Only depend on other Immutable Value Objects</li>
<li>Don&rsquo;t change the state of the whole system in any way</li>
<li>Don&rsquo;t do side effects, like inputs and outputs for example</li>
</ul>


<p>Eric Evans popularized the name in the <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_2?ie=UTF8&amp;qid=1523985269&amp;sr=8-2&amp;keywords=domain+driven+design">Domain-Driven Design Blue Book</a>. Immutable Value Objects have existed for decades in functional languages though. We say these objects are immutable (they cannot change) and pure (they cannot do side effects). Here are 2 interesting properties of Value Objects :</p>

<ul>
<li>you can call a method any number of times with no risk of changing anything to the system</li>
<li>you&rsquo;ll always get the same result every time you call the same method on the same object</li>
</ul>


<p>These by itself, can already be handy when testing.</p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_2?ie=UTF8&amp;qid=1523985269&amp;sr=8-2&amp;keywords=domain+driven+design"><img src="../imgs/2018-04-17-how-immutable-value-objects-fight-mocks/ddd.jpg" alt="Cover of Eric Evans's DDD book" /></a></p>

<h2>How do they prevent mocks ?</h2>

<p>That was a bit theoretical, so let&rsquo;s see how this helps to reduce mocking.</p>

<h3>Simpler &ldquo;init path&rdquo;</h3>

<p>Let&rsquo;s take it the other way round and see how side effects can lead to mocking. Every test starts with setting the state in which to run the test. Side effects make this complicated, as many objects need to collaborate to set this state up. When this becomes too painful, people start hacking around with mocks. This in turn makes the tests more fragile :</p>

<ul>
<li>We are not testing a &ldquo;real&rdquo; situation</li>
<li>We need to keep this setup in line with the real code</li>
</ul>


<blockquote><p>ðŸ’¡ Intricate state initialization encourage people to use mocks.</p></blockquote>

<h3>Isolates parts of the system</h3>

<p>Unfortunately, that is not all the story ! Mutable state also, tricks us into using mocks. As soon as your test deals with mutable state, there is a chance that this state is changed in the &lsquo;real&rsquo; system. This means that some bugs might &lsquo;escape&rsquo; unit tests and appear in end to end tests or in production. That&rsquo;s where the mocks strike ! In order to detect this bug in a fast feedback loop, we&rsquo;re likely to add larger scope tests and use mocks to speed them up &hellip;</p>

<blockquote><p>ðŸ’¡ Mutable state and side effects make unit tests less effective.</p></blockquote>

<h3>Reduces code with side effects</h3>

<p>But there&rsquo;s another reason why Immutable Value Objects help us to avoid mocks. As we&rsquo;ll try to use them more and more for the previous two reasons, we&rsquo;ll need to adapt our programming style. As we&rsquo;ll push more and more code in Immutable Value Objects, the &lsquo;imperative&rsquo; part will shrink. This &lsquo;imperative&rsquo; part is where side-effect happen. This is the part where mocking out IOs makes sense. To summarize, the more Immutable Value Objects we use, the more isolated the IOs are, and the less mocking we need.</p>

<p>Javascript expert Eric Elliot also wrote about the immutability and mocks <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">here</a>.</p>

<h2>Next week</h2>

<p>This was the second post in a <a href="/blog/categories/how-to-avoid-mocks-series/">series about how to prevent mocks</a> in your automated tests. Next post will be an example of using immutable value objects on the <a href="http://codingdojo.org/kata/FizzBuzz/">FizzBuzz kata</a>.</p>

<p><a href="https://feedburner.google.com/fb/a/mailverify?uri=PhilippeBourgau&amp;loc=en_US">Stay tuned !</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Careless Mocking Considered Harmful]]></title>
    <link href="http://philippe.bourgau.net/careless-mocking-considered-harmful/"/>
    <updated>2018-04-19T13:13:00+02:00</updated>
    <id>http://philippe.bourgau.net/careless-mocking-considered-harmful</id>
    <content type="html"><![CDATA[<blockquote><p>ðŸ’¡ Mock hell : when excessive use of test mocks makes <a href="https://en.wikipedia.org/wiki/Code_refactoring">refactoring</a> extremely slow or difficult.</p></blockquote>

<p>A few years ago, I managed to get a side project out of mock hell. Since then, I&rsquo;ve been using what I learned to avoid mocks in all the projects I&rsquo;ve worked on. This is the start of a series of posts about my mock-avoiding techniques.</p>

<p><img src="../imgs/2018-04-10-careless-mocking-considered-harmful/mocks-dont-rock.jpg" alt="A tag &quot;Mocks don't rock !&quot;" /></p>

<h2>Escape from Mock Hell</h2>

<p>Between 2010 and 2014, I was working on a side project I called <a href="https://github.com/philou/mes-courses">http://mes-courses.fr</a>. Which actually means &ldquo;my house shopping&rdquo; in English. I wanted people to be able to do their house shopping in 5 minutes, by using a better UI for online groceries. I was using Ruby, and I had just read <a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;qid=1523422024&amp;sr=8-1&amp;keywords=growing+object-oriented+software+guided+by+tests">Growing Object Oriented Software Guided by Tests</a>. I got a bit too excited with mocking, and was using it way too much.</p>

<p>I&rsquo;d been practicing <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a> for more than 5 years and I was expecting great results with a language like Ruby. After a few months though, I could feel that something was not going as well as it should. The test initialization code was getting longer and longer, as it included a lot of mock setup. This made the tests more complex and less readable. It also made them unreliable, as it was not rare for all my unit tests to pass while the system was not working. I was taking the habit of running my end to end test more and more often. I was also losing a lot of time maintaining the mock setup code in line with the real classes. Mocks also tricked me into the bad practice of keeping a 1 to 1 mapping between code and test files. That again increased my maintenance burden when moving code from one file to another.</p>

<p>It reached a point where I could not take it anymore. All these problems were pointing at mocks, so I tried to remove them from a test file. Here are the techniques I ended up using to remove them mocks :Â </p>

<ul>
<li><a href="https://martinfowler.com/bliki/ValueObject.html">Value Objects</a></li>
<li><a href="http://www.natpryce.com/articles/000714.html">Test Data Builders</a></li>
<li><a href="https://relishapp.com/rspec/rspec-expectations/docs/custom-matchers">Test Matchers</a></li>
<li><a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal architecture</a></li>
<li><a href="https://www.martinfowler.com/articles/mocksArentStubs.html">In-memory fakes</a></li>
<li><a href="https://wincent.com/wiki/Proxy_(test_double">Proxy doubles</a>)</li>
</ul>


<p>The end result was beyond my hopes, as my problems almost magically disappeared. The code got simpler, I became a lot more confident about my unit tests, and they got easier to maintain. As an illustration, here is an excerpts from the diff of a rails controller test file which went through this mock diet.</p>

<p><a href="https://github.com/philou/mes-courses/commit/2c9fce17f9b59d0b3828f309015c07b17cceddf4?diff=split"><img src="../imgs/2018-04-10-careless-mocking-considered-harmful/diff.jpg" alt="A screen capture of a Github diff showing a test file going on a mock diet" /></a></p>

<h2>What&rsquo;s the long term risk ?</h2>

<p>Basically, excessive mocking arms the maintainability of the tests. Here is what would have happened if I&rsquo;d done nothing. Tests would have become so painful to maintain that I would have started to ignore or delete them. As coverage would decrease, more and more code would become untested. That&rsquo;s exactly Michael Feathers' definition of Legacy Code :</p>

<blockquote><p>Legacy Code is code without tests. <a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1523422039&amp;sr=1-1&amp;keywords=legacy+code">Michael Feathers</a></p></blockquote>

<p>To summarize, excessive use of mocks leads to legacy code ! As most of us have learned the hard way, the further a system drifts into legacy, the lower the productivity.</p>

<blockquote><p>ðŸ’¡ Excessive use of mocks leads to legacy code</p></blockquote>

<h2>Next posts</h2>

<p>Others already spoke about the dangers of mocks :</p>

<ul>
<li>Uncle Bob through <a href="http://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html">his blog</a></li>
<li>DHH in the <a href="https://www.google.fr/search?q=is+TDD+dead&amp;safe=active&amp;tbm=vid">&ldquo;Is TDD Dead&rdquo; series</a></li>
</ul>


<p>In <a href="/blog/categories/how-to-avoid-mocks-series/">this series of posts</a>, I&rsquo;ll go through the details of the different techniques I used to remove mocks. Here is my plan :</p>

<ol>
<li><a href="/careless-mocking-considered-harmful/">Careless Mocking considered Harmful</a></li>
<li><a href="/how-immutable-value-objects-fight-mocks/">How Immutable Value Objects fight mocks</a></li>
<li>Immutable Value Objects vs Mocks : Fizz Buzz</li>
<li>Other small scale techniques to avoid mocks : Data Builders and Test Matchers</li>
<li>Large scale techniques to avoid mocks</li>
<li>Mocking in special contexts like legacy and dynamically or statically typed languages</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How NOT to use mocks, my talk at Paris.rb]]></title>
    <link href="http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb/"/>
    <updated>2016-09-13T04:03:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb</id>
    <content type="html"><![CDATA[<p>As I already <a href="/blog/categories/mocking/">wrote about</a>, mocks can be trecherous &hellip; I gave a talk about how to avoid them last tuesday at <a href="http://www.meetup.com/fr-FR/parisrb/">Paris.rb meetup</a>. Here are the <a href="https://docs.google.com/presentation/d/1OH3eBgjyMcpupUnGWsHXm7kQjkckFpnJStYYYqBL6Yk/edit?usp=sharing">slides</a>.</p>

<p>It talks about testing, mocking, but also <a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a> and <a href="https://wincent.com/blog/proxies-with-rr">test proxies Ã  la RR</a> (but for rspec).</p>

<iframe src="https://docs.google.com/presentation/d/1OH3eBgjyMcpupUnGWsHXm7kQjkckFpnJStYYYqBL6Yk/embed?start=false&loop=false&delayms=3000" frameborder="0" width="790" height="470" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>




<p><p/>
Check the speaker&rsquo;s comments for all the details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpecProxies now supports .to receive(xxx)... syntax]]></title>
    <link href="http://philippe.bourgau.net/rspecproxies-now-supports-to-receive-xxx-dot-dot-dot-syntax/"/>
    <updated>2016-08-23T04:47:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspecproxies-now-supports-to-receive-xxx-dot-dot-dot-syntax</id>
    <content type="html"><![CDATA[<p><img class="center" src="/imgs/2016-08-23-rspecproxies-now-supports-to-receive-xxx-dot-dot-dot-syntax/test_probes.jpg" title="Hardware test probes" ></p>

<p>Pure mocks are dangerous. They let defect go through, give a false sense of security and are difficult to maintain.</p>

<p>I&rsquo;ve already talked about it <a href="/hitting-the-middle-ground-between-classicist-and-mockist-tdd/">before</a> but since then, <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">DHH announced that he was quitting TDD</a>, the <a href="http://martinfowler.com/articles/is-tdd-dead/">Is TDD Dead ?</a> debate took place, and the conclusion is that <a href="https://www.thoughtworks.com/insights/blog/mockists-are-dead-long-live-classicists">mockist are dead</a>.</p>

<p>They are still times when mocks feel much simpler than any other things. For example, imagine your process leaks and crashes after 10 hours, the fix is to pass an option to a thirdparty, how would you test this in a fast test ? That&rsquo;s exactly the kind of situation where using test proxies saves you from mocks. A test proxy defers everything to the real object but also features unintrusive hooks and probes that you can use in your test. If you want a code example, check <a href="https://github.com/philou/mes-courses/commit/2c9fce17f9b59d0b3828f309015c07b17cceddf4?diff=split">this commit</a>, where I refactored a rails controller test from mocks to a RSpecProxies (v0.1).</p>

<p>I created RSpecProxies <a href="/my-new-gem-for-creating-rspec-proxies/">a while ago</a>, a while ago, and it&rsquo;s syntax made it alien to the RSpec work, it needed an update. <a href="http://rspec.info">RSpec</a> now supports basic proxying with partial stubs, spies, the <code>and_call_original</code> and the <code>and_wrap_original</code> methods. <a href="https://github.com/philou/rspecproxies">RSpecProxies 1.0</a> is a collection of hooks built on top of these to make proxying easier, with a syntax that will be familiar to RSpec users.</p>

<h2>Before original hook</h2>

<p>This hook is triggered before a call a method. Suppose you want to simulate a bad connection :</p>

<p>```ruby
it &lsquo;can simulate unreliable connection&rsquo; do
  i = 0
  allow(Resource).to receive(:get).and_before_calling_original { |*args|</p>

<pre><code>i += 1
raise RuntimeError.new if i % 3 == 0
</code></pre>

<p>  }</p>

<p>  resources = Resource.get_at_least(10)</p>

<p>  expect(resources.size).to eq(10)
end
```</p>

<h2>After original hooks</h2>

<p>RSpecProxies provides the same kind of hook after the call :</p>

<p>``` ruby
it &lsquo;can check that the correct data is used (using and_after_calling_original&rsquo; do
  user = nil
  allow(User).to receive(:load).and_after_calling_original { |result| user = result }</p>

<p>  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)</p>

<p>  expect(response).to include(user.created_at.to_s)
end
```</p>

<p>Here we are capturing the return value to use it later in the test. For this special purpose, RSpecProxies also provides 2 other helpers :</p>

<p>``` ruby</p>

<h1>Store the latest result in @user of self</h1>

<p>allow(User).to receive(:load).and_capture_result_into(self, :user)</p>

<h1>Collect all results in the users array</h1>

<p>users = []
allow(User).to receive(:load).and_collect_results_into(users)
```</p>

<h2>Proxy chains</h2>

<p>RSpec mocks provides the <code>message_chain</code> feature to do build chains of stubs. RSpecProxy provides a very similar proxy chain concept. The main difference is that it creates proxies along the way, and not pure stubs. Pure stubs assume that you are mocking everything, but as our goal is to mock as little as possible, using proxies makes more sense.</p>

<p>When using a mockist approach, the message chain is a bad smell because it makes your tests very brittle by depending on a lot of implementation. In contrast, proxy chains are meant to be used where they are the simplest way to inject what you need, without creating havoc.</p>

<p>For example, suppose you want to display the progress of a very slow background task. You could mock a lot of your objects to have a fast test, of if you wanted to avoid all the bad side effects of mocking, you could run the background task in your test, and have a slow test &hellip; Or, you could use a chain of proxies :</p>

<p>``` ruby
it &lsquo;can override a deep getter&rsquo; do
  allow(RenderingTask).to proxy_message_chain(&ldquo;load.completion_ratio&rdquo;) { |e| e.and_return(0.2523) }</p>

<p>  controller.show</p>

<p>  expect(response).to include(&lsquo;25%&rsquo;)
end
```</p>

<p>Here the simplest thing to do is just to override a small getter, because from a functionnal point of view, that&rsquo;s exactly what we want to test.</p>

<h2>Last word</h2>

<p>The code is on <a href="https://github.com/philou/rspecproxies">github</a>, v1.0.0 is on <a href="https://rubygems.org/gems/rspecproxies/versions/0.1.0">rubygems</a>, it requires Ruby v2.2.5 and RSpec v3.5, the license is MIT, help in any form are welcome !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My new gem for creating rspec proxies]]></title>
    <link href="http://philippe.bourgau.net/my-new-gem-for-creating-rspec-proxies/"/>
    <updated>2014-05-23T06:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/my-new-gem-for-creating-rspec-proxies</id>
    <content type="html"><![CDATA[<p>I already wrote a lot about test proxies (<a href="/how-to-stub-around-a-call-to-the-original-method-with-rspec/">here</a>, <a href="/hitting-the-middle-ground-between-classicist-and-mockist-tdd/">here</a> and <a href="/my-humble-advices-about-how-to-write-maintainable-tests/">here</a>).</p>

<p>I just took the time to transform my previous gist in a full fledged ruby gem. It&rsquo;s called &ldquo;rspecproxies&rdquo; and it can be found <a href="https://github.com/philou/rspecproxies">on github</a>. It&rsquo;s fully tested, documented and there&rsquo;s a usage section in the readme to help anyone get started.</p>

<p>Here are the pain points proxies try to fix :</p>

<ul>
<li>Without mocks, it is sometimes just awfully painfull to write the test (do you really want to start a background task just to get a completion ratio ?)</li>
<li>With classic stubs, you sometimes have to stub things you are not interested in in your test, you end up with unmaintainable extra long stub setup</li>
</ul>


<p>Let&rsquo;s have a look at a few examples of tests with proxies :</p>

<ul>
<li>Verify actual load count without interfering in any behaviour</li>
</ul>


<p>```ruby
it &lsquo;caches users&rsquo; do
  users = User.capture_results_from(:load)</p>

<p>  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)
  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)</p>

<p>  expect(users).to have_exactly(1).items
end
```</p>

<ul>
<li>Use proxies to stub an object that does not yet exist</li>
</ul>


<p>```ruby
it &lsquo;rounds the completion ratio&rsquo; do
   RenderingTask.proxy_chain(:load, :completion_ratio) {|s| s.and_return(0.2523) }</p>

<p>   renderingController.show</p>

<p>   expect(response).to include(&lsquo;25%&rsquo;)
end
```</p>

<p>I&rsquo;d really love to see more code tested with proxies, it makes the whole testing so much more natural. As with any testing techniques, we get more thorough testing from the ease of writing the test.</p>
]]></content>
  </entry>
  
</feed>
