<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mocking | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/mocking/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2015-04-07T05:18:18+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My new gem for creating rspec proxies]]></title>
    <link href="http://philippe.bourgau.net/my-new-gem-for-creating-rspec-proxies/"/>
    <updated>2014-05-23T06:20:00+00:00</updated>
    <id>http://philippe.bourgau.net/my-new-gem-for-creating-rspec-proxies</id>
    <content type="html"><![CDATA[<p>I already wrote a lot about test proxies (<a href="/how-to-stub-around-a-call-to-the-original-method-with-rspec/">here</a>, <a href="/hitting-the-middle-ground-between-classicist-and-mockist-tdd/">here</a> and <a href="/my-humble-advices-about-how-to-write-maintainable-tests/">here</a>).</p>

<p>I just took the time to transform my previous gist in a full fledged ruby gem. It&rsquo;s called &ldquo;rspecproxies&rdquo; and it can be found <a href="https://github.com/philou/rspecproxies">on github</a>. It&rsquo;s fully tested, documented and there&rsquo;s a usage section in the readme to help anyone get started.</p>

<p>Here are the pain points proxies try to fix :</p>

<ul>
<li>Without mocks, it is sometimes just awfully painfull to write the test (do you really want to start a background task just to get a completion ratio ?)</li>
<li>With classic stubs, you sometimes have to stub things you are not interested in in your test, you end up with unmaintainable extra long stub setup</li>
</ul>


<p>Let&rsquo;s have a look at a few examples of tests with proxies :</p>

<ul>
<li>Verify actual load count without interfering in any behaviour</li>
</ul>


<p>```ruby
it &lsquo;caches users&rsquo; do
  users = User.capture_results_from(:load)</p>

<p>  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)
  controller.login(&lsquo;joe&rsquo;, &lsquo;secret&rsquo;)</p>

<p>  expect(users).to have_exactly(1).items
end
```</p>

<ul>
<li>Use proxies to stub an object that does not yet exist</li>
</ul>


<p>```ruby
it &lsquo;rounds the completion ratio&rsquo; do
   RenderingTask.proxy_chain(:load, :completion_ratio) {|s| s.and_return(0.2523) }</p>

<p>   renderingController.show</p>

<p>   expect(response).to include(&lsquo;25%&rsquo;)
end
```</p>

<p>I&rsquo;d really love to see more code tested with proxies, it makes the whole testing so much more natural. As with any testing techniques, we get more thorough testing from the ease of writing the test.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stub_model and mock_model]]></title>
    <link href="http://philippe.bourgau.net/stubmodel-and-mockmodel/"/>
    <updated>2012-04-16T00:00:00+00:00</updated>
    <id>http://philippe.bourgau.net/stubmodel-and-mockmodel</id>
    <content type="html"><![CDATA[<p>I decided to stop using stub_model and mock_model. I do not use them enough to get fluent with them. Everytime I have to deal with them, something breaks in an unexpected way. I just decided to stand with good old stubs.</p>


<p>I am also thinking of switching to RR (double ruby) and to use proxy objects to get simplify mocking even further. Did you try it ?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to mock an out of process COM server with C#]]></title>
    <link href="http://philippe.bourgau.net/how-to-mock-an-out-of-process-com-server-with/"/>
    <updated>2012-02-14T00:00:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-mock-an-out-of-process-com-server-with</id>
    <content type="html"><![CDATA[<p>I am currently working to replace a legacy command line front end on a COM out of process server.</p>


<p>This server is written in C++ and communicates with the front end through COM. For our new front end project, we wanted a standalone integration test harness to run end to end tests. I thought it would have been great to use a mock library (like <a href="http://code.google.com/p/moq/">moq</a>) to validate the interaction between the front end and the COM server.</p>


<p>After searching the web, I tried ServicedComponent but I did not manage to make it work ... I then found <a href="http://support.microsoft.com/kb/977996">How to develop and out-of-process COM component by using Visual C#</a>&nbsp;in microsoft knowledge base. It is a full blown COM server completly written in C#.</p>


<p>After downloading it, the first thing I tried was to return a mock instead of a concrete object in the class factory</p>


<p>
```c#
   // CSSimpleObject.cs
   internal class CSSimpleObjectClassFactory : IClassFactory
   {
      public int CreateInstance(IntPtr pUnkOuter, ref Guid riid, out IntPtr ppvObject)
      {
         ...
         if (riid == new Guid(CSSimpleObject.ClassId) ||
            riid == new Guid(COMNative.IID_IDispatch) ||
            riid == new Guid(COMNative.IID_IUnknown))
         {
            // Create the instance of the .NET object
            var simpleObject = new Mock&lt;CSSimpleObject&gt; {CallBase = true};
            simpleObject.SetupGet(x =&gt; x.FloatProperty).Returns(666);
            simpleObject.Setup(x =&gt; x.HelloWorld()).Returns("Hello, you got pwned !!!");

            ppvObject = Marshal.GetComInterfaceForObject(
               simpleObject.Object, typeof(ICSSimpleObject));
            }
            ...
```
</p>


<p>Launching&nbsp;CSExeCOMClient.vbs test program told me that it worked.</p>


<p>So here is how I eventually integrated this in our test harness :</p>


<ul>
<li>I ran tlbimp.exe on the real COM server I wanted to mock</li>
<li>In CSSimpleObject.cs, I returned a Mock on the interface of the COM component I wanted to mock</li>
<li>In&nbsp;CSSimpleObject.cs, I removed SimpleObjectsXXX types</li>
<li>To skip registration and to keep access on the returned mock, I started this mock COM server in a new thread at the begining of each test</li>
<li>I tested our new front end in a new process, to make sure we would go through out-of-process COM communication</li>
</ul>


<p>Edit:</p>


<p>We discovered a problem with this technique when we did not manage to implement events correctly. The problem is with COM and not with the mocking framework because it does not work with a real implementation neither</p>

]]></content>
  </entry>
  
</feed>
