<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: technical debt | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/technical-debt/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-09-18T06:55:30+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[5 Effective warning signals that will get you sponsorship for a large scale refactoring]]></title>
    <link href="http://philippe.bourgau.net/effective-warning-signals-to-get-sponsorship-for-a-large-scale-refactoring/"/>
    <updated>2018-09-13T13:01:00+02:00</updated>
    <id>http://philippe.bourgau.net/effective-warning-signals-to-get-sponsorship-for-a-large-scale-refactoring</id>
    <content type="html"><![CDATA[<p>In 2005, professors Bizer and Petty showed something interesting about human behavior. People make more efforts to avoid what they don&rsquo;t want, than to get what they would like. The study itself is interesting, you can have a look at it <a href="https://www.jstor.org/stable/41057679?seq=1#page_scan_tab_contents">here</a>. For example, it explains why political campaigns are getting more and more nasty. There&rsquo;s also a lesson for us, mere developers. We&rsquo;ll get more sponsorship for our refactorings if we highlight the dangers of not doing them !</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-08-27-effective-warning-signals-to-get-sponsorship-for-a-large-scale-refactoring/legacy-monster.jpg" alt="Drawing of a warning panel with legacy code written below an awful monster. Sending effective warning signals is a good way to get sponsorship for large scale refactorings" /></p>

<p>This is the 11th post of a <a href="/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for large scale refactoring</a>. If you haven&rsquo;t already, start by <a href="/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/">the beginning</a>.</p>

<p>From the inside, many systems are in such a messy state that seem like a catastrophe waiting to happen. Unfortunately, this mess is completely invisible to non-developers ! Here are a few techniques to show how close we are from a total breakdown !</p>

<h2>Effective Warning Signal #1 Pranks</h2>

<p>If you have the guts and your company is fun enough, you can try one of <a href="/the-size-of-code/">these pranks</a> ðŸ˜‰.</p>

<p><a href="https://www.flickr.com/photos/kk/18768224"><img src="http://philippe.bourgau.net/imgs/2018-08-27-effective-warning-signals-to-get-sponsorship-for-a-large-scale-refactoring/paper-on-desk.jpg" alt="A photo of a desk littered under paper. As if we had printed the whole source code and dumped in on a non-developer desk. Pranks are a good way to get sponsorship for large scale refactorings" /></a></p>

<div class="image-credits">What if we printed the whole source code and dumped in on non-developers desks ? By <a href="https://www.flickr.com/photos/kk/">Kris KrÃ¼g</a>, <a href="https://creativecommons.org/licenses/by-sa/2.0/" title="Attribution-ShareAlike 2.0 Generic">CC BY-SA 2.0</a>, <a href="https://www.flickr.com/photos/kk/18768224">Link</a></div>


<br>


<p>They&rsquo;re bound to have a big impact &hellip; but they might also get you fired ! We should be creative and find both effective and acceptable pranks. Pranks are a lot more effective than we first think. <a href="https://en.wikipedia.org/wiki/Nonviolent_revolution">Non-Violent Revolution</a> activists have actually used <a href="http://laughtivismgroup5.blogspot.com/2016/04/laughtivism.html">Laughitism</a> to take dictators down ! For a good (and unexpectedly fun) read on the topic, have a look a <a href="https://www.amazon.com/Blueprint-Revolution-Nonviolent-Techniques-Communities/dp/0812995309">Blueprint for a Revolution</a>. It was written by Serb non violent activist <a href="https://en.wikipedia.org/wiki/Sr%C4%91a_Popovi%C4%87_(activist">Srdja Popovic</a>) member of <a href="https://en.wikipedia.org/wiki/Otpor!">OTPOR!,</a> who brought <a href="https://en.wikipedia.org/wiki/Slobodan_Milo%C5%A1evi%C4%87">Millosevic</a> down .</p>

<p><a href="https://www.amazon.com/Blueprint-Revolution-Nonviolent-Techniques-Communities/dp/0812995309"><img src="http://philippe.bourgau.net/imgs/2018-08-27-effective-warning-signals-to-get-sponsorship-for-a-large-scale-refactoring/blueprint-revolution.jpg" alt="Cover of the book Blueprint for Revolution. Laughitism is a non violent technique that we can use against Legacy Code to get sponsorship for large scale refactorings" /></a></p>

<p>Promised, as soon as I manage to use such a prank without getting fired at work, I&rsquo;ll blog about it !</p>

<h2>Effective Warning Signal #2 Dice of Debt Game</h2>

<p>While doing my researches for this article, I found the <a href="https://www.agilealliance.org/dice-of-debt-game/">Dice of Debt</a> game. It&rsquo;s aimed at making business people experience the long term legacy code drag. It has good reviews, have a try at it with your business people and post back your feedback ! I&rsquo;ll do so as soon as I have a chance to test it myself.</p>

<h2>Effective Warning Signal #3 Higher authority</h2>

<p>Appealing to a higher authority works as long as people recognize this authority as so. Knowing the people in front of us, it&rsquo;s our job to bring up the reference in an effective way. Here are</p>

<p>In <a href="https://www.youtube.com/watch?v=xEqRtIeD51k">this talk</a>, <a href="http://docondev.com/">Doc Norton</a>, a recognized technical debt expert, shows the link between technical debt and productivity.</p>

<p><a href="https://www.youtube.com/watch?v=xEqRtIeD51k"><img src="http://philippe.bourgau.net/imgs/2018-08-27-effective-warning-signals-to-get-sponsorship-for-a-large-scale-refactoring/technical-debt-trap.jpg" alt="Slide from Doc Norton's Technical Debt Trap talk. It shows how technical debt impacts the cost of change and can be an effective warning signal for a large scale refactoring" /></a></p>

<p>Showing similarities between our own code metrics and this graph might ring the alarm bell in business people.</p>

<p>Another interesting model out there is <a href="https://www.agilealliance.org/the-agile-alliance-debt-analysis-model/">A2DAM</a>. It was built through the <a href="https://www.agilealliance.org/">Agile Alliance</a>. It can be used to estimate the value of a codebase when buying a company. Maybe business people will listen if we tell them that their software would be worth 0 on the market ?</p>

<h2>Effective Warning Signal #4 Metaphor</h2>

<p>I was recently working with a team that is preparing a pitch to get sponsorship for a refactoring. They want to rework multithreaded code that uses locks and other low level synchronization. The hand written synchronization is becoming difficult to maintain. They would like to refactor it with the <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>. Business people will likely argue that this module is now stable enough and should stay as is. We all know that this is not the case with bogus multithreaded code : the more you use it, the more bugs you find ! They had the idea to use the email vs phone metaphor. No one in the room could have handled all his daily emails with a phone only ! Everyone understood why it was necessary to switch to actors.</p>

<p>In <a href="https://engineering.riotgames.com/news/taxonomy-tech-debt">A Taxonomy of Technical Debt</a>, <a href="https://www.linkedin.com/in/bill-clark-37444a133/">Bill Clark</a> adds another dimension to technical debt. On top of the classic principal and interests he adds contagion. In fact, it&rsquo;s a bit as if he&rsquo;s ditching the <a href="https://martinfowler.com/bliki/TechnicalDebt.html">technical debt metaphor</a> for the disease metaphor ! Disease have a cost to live with, a cost to heal from and a contagion rate. People at the agile alliance also noted this <a href="https://www.agilealliance.org/technical-debt-systemic-problem/">self reinforcing behavior</a>. This metaphor might be better for &ldquo;<a href="https://en.wikipedia.org/wiki/Cruft">cruft</a>&rdquo;. <a href="https://twitter.com/wardcunningham?lang=fr">Ward Cunningham</a>&rsquo;s original metaphor of technical debt only applied to tested code.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/pqeJFYwnkjE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>


<blockquote><p>ðŸ’¡ A disease might be a better metaphor than debt for code cruft.</p></blockquote>

<h2>Effective Warning Signal #5 A horror story</h2>

<p>We said that a successful refactoring story will be useful to frame ours as an opportunity. We can have more impact with the opposite ! We should relate a large software failure, that had impact on the business to bad code. The bigger the impact on the business, the better it is. If you (unluckily) have something like that at your company, it should be a very powerful argument. If you don&rsquo;t, try to find a public story on the internet, or a public conference. For example here is one from <a href="https://www.makeuseof.com/tag/worst-programming-mistakes-in-history/">The 10 Worst Programming Mistakes in History.</a>Â </p>

<blockquote><p>ðŸ’¡ The <a href="https://en.wikipedia.org/wiki/Therac-25">Therac-25</a> (a radiation therapy machine) killed 6 people because it was difficult to perform automated tests !</p></blockquote>

<p>We can draw parallels and forecasts, to highlight the high risk of failure.</p>

<h2>Almost there</h2>

<p>This was the 11th post in a <a href="http://philippe.bourgau.net/blog/categories/large-scale-refactoring-sponsorship-series/">series about how to get sponsorship for large scale refactoring</a>. Unfortunately, presenting refactoring in a good way only brings us so far. If we want to be really convincing, we need to use quantitative data. That&rsquo;s going to be the topic of my <a href="http://eepurl.com/dxKE95">next post</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A coding dojo exercises plan towards refactoring legacy code]]></title>
    <link href="http://philippe.bourgau.net/a-coding-dojo-exercises-plan-towards-refactoring-legacy-code/"/>
    <updated>2018-06-14T06:29:00+02:00</updated>
    <id>http://philippe.bourgau.net/a-coding-dojo-exercises-plan-towards-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>My current job <a href="http://www.murex.com">at work</a> is technical coach. I&rsquo;m available for teams that need help to adopt incremental coding practices.</p>

<h2>Problems with refactoring legacy code</h2>

<p>A few months ago, a team which was struggling with a lot of legacy code asked for help. As you might know if you read my blog, I&rsquo;m a big fan of <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development (TDD)</a> because it has made my <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">life as a developer so much more easy</a>. I&rsquo;m so used to TDD now, that even if I don&rsquo;t have tests yet (as is the case when refactoring legacy code), TDD helps me :</p>

<ul>
<li>To stick to baby steps which are a lot less likely to fail than larges changes.</li>
<li>Write testable code. I know what testable code looks like, and when refactoring, I&rsquo;ll try to change it towards that.</li>
</ul>


<p>That&rsquo;s why we started to run regular, all team, <a href="http://philippe.bourgau.net/blog/categories/team-randori-series/">coding dojo randoris</a>. It was nice for the <a href="/why-you-should-start-a-team-coding-dojo-randori-right-now/">team dynamics</a>, and the people where learning a lot of technical skills. I also got the feedback that they where not able to apply this directly on their day to day job though. After a bit more discussion, I understood that they did not know where this was going, what to expect, and when !</p>

<blockquote><p>ðŸ’¡ Test Driven Development also teaches you what testable code looks like.</p></blockquote>

<h2>The coding dojo exercices</h2>

<p>It turned out that a coding dojo exercises plan was enough to answer their questions. This is what it looks like.</p>

<h3>Drawing</h3>

<p><a href="http://philippe.bourgau.net/imgs/2018-06-04-a-coding-dojo-exercises-plan-towards-refactoring-legacy-code/Coding-Dojo-Hulk.jpg"><img src="http://philippe.bourgau.net/imgs/2018-06-04-a-coding-dojo-exercises-plan-towards-refactoring-legacy-code/Coding-Dojo-Hulk-small.jpg" alt="An illustrated Coding Dojo Exercises plan leading to the mastery of Legacy Code Refactoring" /></a></p>

<h3>Mind Map</h3>

<p>Here is another, more concrete, version, with sample names of katas we can find online.</p>

<p><a href="http://philippe.bourgau.net/imgs/2018-06-04-a-coding-dojo-exercises-plan-towards-refactoring-legacy-code/TDD_Kata_Plan.jpg"><img src="http://philippe.bourgau.net/imgs/2018-06-04-a-coding-dojo-exercises-plan-towards-refactoring-legacy-code/TDD_Kata_Plan-small.jpg" alt="An mind map of Coding Dojo Exercises plan leading to the mastery of Legacy Code Refactoring" /></a></p>

<h3>Text</h3>

<p>It starts with simple greenfield katas :</p>

<ul>
<li><a href="http://codingdojo.org/kata/FizzBuzz/">Fizz Buzz</a></li>
<li><a href="http://codingdojo.org/kata/RomanNumerals/">Roman Numerals</a></li>
<li><a href="http://codingdojo.org/kata/Bowling/">Bowling</a></li>
</ul>


<p>It goes on to intermediate katas, where we can use TDD to do design :</p>

<ul>
<li><a href="http://kata-log.rocks/mars-rover-kata">Mars Rover</a></li>
<li><a href="http://codingdojo.org/kata/PokerHands/">Poker Hands</a></li>
<li><a href="http://codingdojo.org/kata/TradingCardGame/">trading card game</a></li>
</ul>


<p>From then on, it&rsquo;s possible to tackle advanced katas and styles :</p>

<ul>
<li>Refactoring fresh code

<ul>
<li>Continue design katas on 2 or more sessions</li>
<li>Always compile Constraint</li>
</ul>
</li>
<li>Bottom-up TDD

<ul>
<li><a href="http://codingdojo.org/kata/GameOfLife/">Game of Life</a></li>
<li>Median of a list of lists (with no concatenation)</li>
<li><a href="http://codingdojo.org/kata/LangtonAnt/">Langton ant</a></li>
</ul>
</li>
<li>Top-Down TDD

<ul>
<li><a href="http://codingdojo.org/kata/Potter/">Kata Potter</a></li>
<li><a href="http://codingdojo.org/kata/NumberToLCD/">LCD</a></li>
</ul>
</li>
<li>TDD on algorithms

<ul>
<li><a href="http://codingdojo.org/kata/Diamond/">Diamond</a></li>
<li><a href="http://codingdojo.org/kata/Lags/">Kata Lags</a></li>
<li><a href="http://codingdojo.org/kata/Anagram/">anagrams</a></li>
</ul>
</li>
</ul>


<p>All this opens the gate to legacy code refactoring katas :</p>

<ul>
<li><a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose</a></li>
<li><a href="https://github.com/emilybache/Racing-Car-Katas">Race Car Katas</a></li>
<li><a href="https://github.com/jbrains/trivia">Ugly trivia game</a></li>
<li>Others from <a href="http://kata-log.rocks">http://kata-log.rocks</a></li>
</ul>


<p>At that point, the team can <a href="https://en.wikipedia.org/wiki/Mob_programming">mob</a> to refactor production code :</p>

<ul>
<li>Real life, static analysis issue, mob programming session</li>
<li>Real life, code smell, mob programming session</li>
<li>Real life, larger mob Refactoring</li>
</ul>


<h2>What changed in practice ?</h2>

<p>We wanted to split the teamwork and the coding dojos exercises. The team is now doing mob programming sessions on their usual stories twice a week (I&rsquo;ll blog about that someday). But also doing regular coding dojos exercises in pairs.</p>

<p>Even if they did not go through all the TDD katas yet, mobbing on real stories helps the team to take on legacy code.</p>

<blockquote><p>Given enough eyeballs, all bugs are shallow. Linus&rsquo;s Law</p></blockquote>

<p>Working in pairs on the code katas allows them to be more engaged in the exercises. In the end, it brings faster learning.</p>

<blockquote><p>ðŸ’¡ A mix of Coding Dojos in pairs and Mob Programming sessions is a good way to teach TDD in a Legacy Code context.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 things to know that will make you great at refactoring legacy code]]></title>
    <link href="http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/"/>
    <updated>2017-07-28T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>We write tons of <a href="https://en.wikipedia.org/wiki/Legacy_code">legacy code</a> everyday. Experienced developers understand that legacy code is not something special. Legacy code is our daily bread and butter.</p>

<p>Should we abandon all hope as we enter legacy code ? Would that be professional ? In the end, code is only a bunch of bytes, somewhere on a drive. We are the software professionals. We need to deal with that.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/keep-calm-and-take-the-power-back-4.jpg" alt="Keep Calm and Take The Power Back" /></p>

<h2>1. Master non legacy refactoring first</h2>

<p>Please calm down before this &ldquo;Bring &lsquo;em out&rdquo; energy goes to your head.</p>

<p>I did not say that refactoring legacy code is easy. Legacy code can bite &hellip; bad. I&rsquo;ve been in teams which literally spent nights fixing a bad refactoring gone to production &hellip;</p>

<p>Before you can refactor legacy code, you need to be good at refactoring new code. We all learned to swim in the shallow pool, it&rsquo;s the same with refactoring. Mastering green code refactoring will help you when tackling legacy code.</p>

<p>First, you&rsquo;ll know the ideal you&rsquo;d like to get to. Knowing how productive a fast feedback loop is will motivate you to keep on refactoring.</p>

<p>Second, you&rsquo;ll have a better idea of the baby steps to take you through a tricky refactoring.</p>

<p>If you are not yet at ease with greenfield refactoring, have a look at <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">my previous post</a>.</p>

<h2>2. Understand that refactoring legacy code is different</h2>

<p>The next thing to remember is that refactoring legacy code is different. Let&rsquo;s assume <a href="https://stackoverflow.com/questions/4174867/what-is-the-definition-of-legacy-code">Michael Feather&rsquo;s definition of legacy code</a> : &ldquo;Code without tests&rdquo;. Getting rid of legacy code means adding automated tests.</p>

<p>Unfortunately, trying to force push unit tests in legacy code usually results in a mess. It introduces lot&rsquo;s of artificial mocks in a meaningless design. It also creates brittle and unmaintainable tests. More harm than good. This might be an intermediate step, but it is usually not the quickest way to master your legacy code beast.</p>

<p>Here are alternatives I prefer.</p>

<h2>3. Divide and conquer</h2>

<p>This is the most straightforward way to deal with legacy code. It&rsquo;s an iterative process to repeat until you get things under control. Here is how it goes :</p>

<p>(1) Rely on the tests you have, (2) to refactor enough, (3) to test sub-parts in isolation. (4) Repeat until you are happy with the speed of the feedback loop.</p>

<p>Depending on the initial state of your tests, this might take more or less time. Your first tests might even be manual. This is the bulldozer of refactoring. Very effective, but slow.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/bulldozer.jpg" alt="Bulldozer" /></p>

<h2>4. Pair or mob program</h2>

<blockquote><p>Given enough eyeballs, all bugs are shallow.</p>

<p><a href="https://en.wikipedia.org/wiki/Linus%27s_Law">Linus&rsquo;s Law</a></p></blockquote>

<p>Changing legacy code is a lot easier when you team up. First, it creates a motivating &ldquo;we&rsquo;re all in this together&rdquo; mindset. Second, it guards us against silly mistakes.</p>

<p><a href="https://en.wikipedia.org/wiki/Mob_programming">Mob programming</a>, might seem very expensive, so let me explain why it is not. Suppose you want to introduce some tests in a tricky section of code.</p>

<p>With mob programming, all the team gathers for half a day to work on this change. Together, they find and avoid most of the pitfalls. They commit a high quality change, which creates only one bug down the road.</p>

<p>Let&rsquo;s see the alternative.</p>

<p>Using solo programming, a poor programmer tries to tackle the change all by himself. He spends a few days to understand and double check all the traps he can think of. Finally, he commits his change, which results in many bugs later on. Every time a bug pops up, it interrupts someone to fix it ASAP.</p>

<p>The savings in interruptions are greater than up front cost of mob or pair programming.Â </p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/p_pvslS4gEI" frameborder="0" allowfullscreen></iframe>


<h2>5. Seams</h2>

<blockquote><p>A software seam is <em>a place where you can alter behavior in your program without editing in that place.</em></p>

<p><a href="http://wiki.c2.com/?SoftwareSeam">Michael Feathers</a></p></blockquote>

<p>This is one of the many interesting things I learned from Michael&rsquo;s book about legacy code.</p>

<p><a href="https://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=edaadc6370c2c8c9e943348d9fbdafb9"><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/legacy-code.jpg" alt="Cover of Working Effectively with Legacy Code" /></a></p>

<p>Object polymorphism is only one kind of seam. Depending on your language, many other types of seams can be available.Â </p>

<ul>
<li>Type seam for generic languages</li>
<li>Static link seam for static libraries</li>
<li>Dynamic link seam for dynamic libraries</li>
<li>&hellip;</li>
</ul>


<p>Finding seams in your program is something opportunistic. Keep in mind though that testing through seams is not the end goal. It is only a step to bootstrap the test-refactor loop and start your refactoring journey.</p>

<h2>6. Mikado Method</h2>

<p>How do you get to your end then ? How to you refactor only what&rsquo;s useful for your features ? How do you do large refactorings in baby steps ?</p>

<p>Over time, I found that the mikado method is a good answer to all these issues. The goal of the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> is to build a graph of dependent refactoring. It can then use it to perform all these refactorings one by one. Here is the mikado method by the book.</p>

<p>Before anything else, you&rsquo;ll need a large sheet of paper to draw the graph. Then repeat the following :</p>

<ol>
<li>try to do the change you want</li>
<li>If it builds and the tests pass, great, commit and you&rsquo;re done</li>
<li>Otherwise, add a node for the change you wanted to do in your mikado graph</li>
<li>Write down the compilation and test errorsÂ </li>
<li>Revert your change</li>
<li>Recurse from 1 for every compilation or test error</li>
<li>Draw a dependency arrow from the nodes of errors to the node of your initial change</li>
</ol>


<p>Once you built the full graph, tackle the refactorings from the leaves. As leafs have no dependencies, it should be easy to do and commit them.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado.jpg" alt="A Sample Mikado Graph" /></p>

<p>When I first read about the mikado method, it seemed very simple and powerful. Things got more complex when I tried to apply it. For example, the fact that some changes don&rsquo;t compile hide future test failures. That means that very often, the &ldquo;Build the graph&rdquo; and &ldquo;Walk the graph&rdquo; phases overlap. In real life, the graph evolves and changes over time.Â </p>

<p>My advice about the Mikado Method is not to take it to the letter. It&rsquo;s a fantastic communication tool. It helps not to get lost and to avoid a refactoring tunnel. It also helps to tackle refactoring as a team.</p>

<p>It is not a strict algorithm though. Build and tests are not the only way to build the graph. Very often, a bit of thinking and expert knowledge are the best tools at hand.</p>

<p><a href="https://www.amazon.com/gp/product/1617291218/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617291218&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=f7405cd74335b3cbb8b263f1a5c37c1d"><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado-book.jpg" alt="Cover of The Mikado Method book" /></a></p>

<h2>7. Bubble Context</h2>

<p>Refactoring needs to be opportunistic. Sometimes there are shortcuts in your refactoring path.</p>

<p>If you have access to a domain expert, the <a href="http://dddcommunity.org/library/evans_2011_2/2">Bubble Context</a> will cut the amount of refactoring to do. It&rsquo;s also an occasion to get rid of all the features that are in your software but that are not required anymore.Â </p>

<p>The Bubble Context originated from the <a href="http://dddcommunity.org/library/evans_2011_2/">DDD community</a>, as a way to grow a domain in an existing code base. It goes like that :</p>

<ol>
<li>Find a domain expert</li>
<li>(Re)write clean code for a very tiny sub domain</li>
<li>Protect it from the outside with an <a href="https://softwareengineering.stackexchange.com/questions/184464/what-is-an-anti-corruption-layer-and-how-is-it-used">anticorruption layer</a></li>
<li>Grow it little by little</li>
</ol>


<p>I have friends who are fans of the bubble context. It is super effective provided you have a domain expert. It is a method of choice in complex domain software.</p>

<h2>8. Strangler</h2>

<p>Bubble Context works great when refactoring domain specific code, what about the rest ? I had good results with the <a href="https://www.martinfowler.com/bliki/StranglerApplication.html">Strangler pattern</a>.</p>

<p>For example, we had to refactor a rather complex parser for an internal DSL. It was very difficult to incrementally change the old parser, so we started to build a new one aside. It would try to parse, but delegate to the old one when it failed. Little by little, the new parser was handling more and more of the grammar. When it supported all the inputs, we removed the old one.</p>

<p>The strangler is particularly well suited for refactoring technical components. They have more stable interfaces and can be very difficult to change incrementally.</p>

<h2>9. Parallel Run</h2>

<p>This is more of a trick than a long term strategy. The idea is to use the initial (legacy) version of the code as a reference for your refactoring. Run both and check that they are doing the same thing.</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/railroad.jpg" alt="Parallel Railroads" /></p>

<p>Here are some variations around this idea.</p>

<p>If the code you want to refactor is side effect free, it should be easy to duplicate it before refactoring. This enables running both to check that they compute the same thing.</p>

<p>Put this in a unit test to bootstrap a test-refactor loop. You can also run both in production and log any difference. You&rsquo;ll need access to production logs &hellip; Devops teams have a refactoring advantage !</p>

<p>Here is another use of your logs. If the code writes a lot of logs, we can use them as a reference. Capture the logs of the old version, and unit test that the refactored version prints the same logs out. That&rsquo;s an unmaintainable test, but good enough to bootstrap the test-refactor loop.</p>

<p>The <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose kata</a> is a good exercise to practice this last technique.</p>

<h2>10. Dead code is better off dead</h2>

<p>You don&rsquo;t need to refactor dead code ! Again, access to production logs is a great advantage for refactoring.</p>

<p>Add logs to learn how the real code runs. If it&rsquo;s never called, then delete it. If it&rsquo;s only called with some set of values, simplify it.</p>

<h2>No silver bullet</h2>

<p>That was a whirlwind tour of the legacy code refactoring techniques I know. It&rsquo;s no promise that refactoring will become easy or fast. I hope it is a good starting point to set up and walk a refactoring plan.</p>

<p>This was the last post of a series of 3 about how to learn refactoring techniques. If you didn&rsquo;t already, check part 1 <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a> and part 2 <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">How to Start Learning the Tao of Incremental Code Refactoring Today</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A seamless way to keep track of technical debt in your source code]]></title>
    <link href="http://philippe.bourgau.net/a-seamless-way-to-keep-track-of-technical-debt-in-your-source-code/"/>
    <updated>2017-04-12T08:48:00+02:00</updated>
    <id>http://philippe.bourgau.net/a-seamless-way-to-keep-track-of-technical-debt-in-your-source-code</id>
    <content type="html"><![CDATA[<p>I eventually stumbled upon a way to keep track of technical debt in source code that is both straightforward and already built-in most tools : simple <code>TODO</code> comments !</p>

<p><img src="http://philippe.bourgau.net/imgs/2017-04-12-a-seamless-way-to-keep-track-of-technical-debt-in-your-source-code/todo-comment.jpg" alt="Photo of a screen displaying source code with #TODO comments" /></p>

<h2>How it happened ?</h2>

<p>Some time ago, we tried to add <a href="/a-plan-for-technical-debt-lean-software-development-part-7/"><code>@TechnicalDebt</code></a> annotations in our source code. Unfortunately, after a few month, we came to the logical conclusion that it was too complex to be effective :</p>

<ul>
<li>It involved too much ceremony, which frightened people</li>
<li>It made people uneasy to change anything around the annotation instead of sending a call to action</li>
<li>As a result, it was always out of date</li>
</ul>


<p>After a bit of discussion with my colleagues, we decided to replace all these annotations with simple <code>TODO</code> comments.</p>

<p>When the refactoring to do seems fairly obvious (but also premature) we&rsquo;ll use a straightforward <code>//TODO (example) introduce a factory</code> message. Next time a pairs gets to work on this part of the code, they get the silent opinion of their peers to help them decide what to do about this piece of the code. Other times, the code might be smelly, yet without us knowing what to do about it yet, in this case, we agreed to use <code>//TODO SMELL (example) responsibilities are not clear in this class</code> which is still a <code>TODO</code> comment, but not a clear call to action.</p>

<p>When I started my <a href="https://github.com/philou/planning-poker">current side project</a>, I naturally started to use them. They display nicely in <a href="https://codeclimate.com/github/philou/planning-poker/issues">CodeClimate</a>.</p>

<h3>The pros</h3>

<p><img src="http://philippe.bourgau.net/imgs/2017-04-12-a-seamless-way-to-keep-track-of-technical-debt-in-your-source-code/codeclimate.jpg" alt="Screenshot of the CodeClimate issue dashboard displaying TODO comments" /></p>

<p>The great thing about <code>TODO</code> comments is that, as a very old programming trick, they are already supported out of the box by most tools <a href="https://www.jetbrains.com/">IntelliJ</a>, <a href="https://www.sonarqube.org/">SonarQube</a>, <a href="http://rubyonrails.org/">Rails</a>, <a href="https://codeclimate.com">CodeClimate</a> and I guess many others. Only one day after I refactored to <code>TODO</code> comments, a team mate fixed one that had appeared in his IDE&rsquo;s TODO tab !</p>

<h3>The cons</h3>

<p>Some tools, IDEs in particular, tend to assume that you should fix all your <code>TODOs</code> before you commit anything. That&rsquo;s not exactly how we are using them to track lasting technical debt. So that&rsquo;s one thing you need to keep in mind.</p>

<p>Tools like Sonar on the other hand, assign a fixed remediation cost to any <code>TODO</code> you have in the code, which is usually not the case at all !</p>

<h2>How to set it up in your project</h2>

<p>As you might guess, this is pretty easy. Just start adding <code>TODO</code> comments in your code &hellip;</p>

<h3>Teamwise</h3>

<p>It is worth first validating the practice with your colleagues though. There are many ways to do that, depending on your team&rsquo;s work habits :</p>

<ul>
<li>Use your team <a href="https://slack.com/">Slack</a> (or whatever chat room you use) to share a link to this post (for example) and create a yes/no poll</li>
<li>Or if you think you need it, create some wiki page explaining the practice and detailing its rationals in your context, add a yes/no poll, and finally share this page with your team</li>
<li>Eventually, if you think that this topic deserves it, setup a meeting with everyone and discuss the point. It might be worth sharing information about the practice beforehand to make the meeting more efficient. You can end the vote with a <a href="http://www.plays-in-business.com/thumb-voting/">thumb vote</a> (up : yes, down : no, side : whatever)</li>
</ul>


<p><img src="http://philippe.bourgau.net/imgs/2017-04-12-a-seamless-way-to-keep-track-of-technical-debt-in-your-source-code/thumb-vote.jpg" alt="Thumbs voting positions" /><div class="image-credits">Photo from <a href="http://www.plays-in-business.com/thumb-voting/">Plays in Business</a></div></p>

<p>Don&rsquo;t wait for unanimity to start the practice, majority is enough ! Make sure that people who voted the other way will follow the team practice in the end though. Remember that whatever the answer, discussing team practices is good.</p>

<p>Once all the team agreed on using (or not) <code>TODO</code> comments, mention the practice in your team&rsquo;s coding conventions or working agreements (which I strongly recommend to have written somewhere). If you don&rsquo;t have any yet, create some !</p>

<h3>Toolswise</h3>

<p>Most tools will handle <code>TODO</code> out of the box.</p>

<ul>
<li>Rails comes with a <code>rake notes</code> task to list <code>TODO</code> comments.</li>
<li>CodeClimate and SonarQube both lists <code>TODOs</code> as issues in their default config</li>
<li>Most IDEs have a &lsquo;TODO&rsquo; tab which will display the <code>TODO</code> comments in the project</li>
<li>Otherwise, good old grep will very happily find <code>TODO</code> comments in your code</li>
</ul>


<p>Some tools might require small tweaks to improve the experience :</p>

<ul>
<li>In IntelliJ, in the commit window, uncheck the &lsquo;Check TODO&rsquo; checkbox to avoid getting a warning at every commit</li>
</ul>


<p><img src="http://philippe.bourgau.net/imgs/2017-04-12-a-seamless-way-to-keep-track-of-technical-debt-in-your-source-code/intellij-commit.jpg" alt="IntelliJ's commit window, with its 'Check TODO' check box" /></p>

<ul>
<li>SonarQube uses the same fixed remediation cost for every TODO comment. It&rsquo;s up to you to adapt this remediation cost to your context.</li>
</ul>


<h2>What&rsquo;s next ?</h2>

<p><code>TODO</code> comments are a good starting point to track technical debt. Once you start using them, there are a few things you can do :</p>

<p>First, remember to fix some regularly. Very old <code>TODO</code> comments are technical debt of their own ! Using code quality dashboards like SonarQube or CodeClimate help to continuously improve your code.</p>

<p>If your tools allow it, you might consider setting up a simpler <code>//SMELL ...</code> instead of <code>//TODO SMELL ...</code> or whatever other special comment that might be useful in your context.</p>

<p>Finally, there is a lean continuous improvement practice which consists of logging problems as they occur. Doing this could help your team to decide which technical debt hotspots are the most important to fix. When appropriate, link the problems with the <code>TODO</code> comments. After a few weeks of this, walking through all the problems during a retrospective should shed light on what parts of the code are causing the most troubles.</p>

<h2>Edit 2017-04-19</h2>

<p>Thanks a lot for your comments ! People have suggested a ton of great improvements over my basic setup :</p>

<ul>
<li>plugins to other tools that also support <code>TODO</code> comments</li>
<li>activating automatic sync between issues in CodeClimate and your issue tracking system</li>
<li>using custom comments markers</li>
<li>adding an &lsquo;X&rsquo; to your comment every time you are bothered by the technical debt, tools can configured to assign a higher severity to issues with a lot of &lsquo;X&rsquo;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[When the Boy Scout Rule Fails]]></title>
    <link href="http://philippe.bourgau.net/when-the-boy-scout-rule-fails/"/>
    <updated>2016-08-02T05:38:00+02:00</updated>
    <id>http://philippe.bourgau.net/when-the-boy-scout-rule-fails</id>
    <content type="html"><![CDATA[<p><img src="http://philippe.bourgau.net/imgs/2016-08-02-when-the-boy-scout-rule-fails/boy-scout-rule.jpg" alt="An illustration of the boy scout rule" /><div class="image-credits"><a href="http://bit.ly/2osQoyg">Original Tweet</a> by Marteen van Leeuwen</div></p>

<p>Here goes the <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule">boy scout rule</a> :</p>

<blockquote><p>Always check a module in cleaner than when you checked it out.</p></blockquote>

<p>Unfortunately, this alone does not guarantee to keep the technical debt under control. What can we do then ?</p>

<h2>Why the boy scout rule is not enough</h2>

<p>I can easily think of a few issues that are not covered by the boy scout rule.</p>

<h3>It only deals with local problems</h3>

<p>In it&rsquo;s statement, the boy scout rule is local and does not address large scale design or architecture issues. Applying the boy scout rule keeps files well written, using with clear and understandable code. From a larger perspective though, it does very little or slow improvement to the overall design.</p>

<p>These large scale refactorings are very difficult to deal with using the boy scout rule alone. It could be done but would require to share the refactoring goal with all the team, and then track its progress, while at the same time dealing with all the other subjects of the project. That&rsquo;s starting to sound like multitasking to me.</p>

<h3>It&rsquo;s skill dependent</h3>

<p>Another point about the boy scout rule (and to be fair, about any refactoring technique) is that programmers will be able to clean the code only as much as their skills allow them to !</p>

<p>Imagine what would happen when a new master developer arrives in a team of juniors, he&rsquo;d spot a lot of technical debt and would suggest improvements and ways to clean the code. Code that was thought of as very clean would suddenly be downgraded to junk !</p>

<p>The point here is that the boy scout rule cannot guarantee that you have no technical debt, because you don&rsquo;t know how much you have !</p>

<p>That&rsquo;s where the debt metaphor reaches its limits and flips to some productivity investment. By investing time to perform some newly discovered refactoring, you could get a productivity boost !</p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470200818&amp;sr=8-1&amp;keywords=domain+driven+design"><img src="http://philippe.bourgau.net/imgs/2016-08-02-when-the-boy-scout-rule-fails/ddd.jpg" alt="The cover of &quot;Domain Driven Design&quot;" /></a></p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470200818&amp;sr=8-1&amp;keywords=domain+driven+design">Domain-Driven Design: Tackling Complexity in the Heart of Software</a>, Eric Evans calls this knowledge distillation. He means that little by little, the team gains better understanding of the domain, sometimes going through what he calls a &lsquo;breakthrough&rsquo;. These breakthroughs often promote existing code to technical debt &hellip;</p>

<h3>It&rsquo;s context dependent</h3>

<p>Developers alone are not the only one responsible for creating technical debt. Changes to the environment also do.</p>

<p>For example, if the market conditions change, and that new expectations for the product are slowly becoming the norm, your old perfectly working system becomes legacy and technical debt. As an example, let&rsquo;s examine what happened to the capital markets software industry in response to the 2008 crisis.</p>

<ul>
<li>The sector became a lot more regulated</li>
<li>Risk control is moving from nightly batches to real time</li>
<li>The demand for complex (and risky) contracts decreased</li>
<li>As a consequence, trading on simpler contracts exploded</li>
</ul>


<p>All these elements combined invalidated existing architectures !</p>

<p>New technologies also create technical debt. Think the switch from mainframe to the web.</p>

<h2>What do we need then ?</h2>

<p>Should we stop using the boy scout rule ? Surely not, it would be a total non-sense. Submitting clean and readable code is a must.</p>

<p>But it is not enough. If you have spotted some large scale refactoring that could bring some improvement, we should do what a fund manager would do :</p>

<ol>
<li>Estimate the return on investment</li>
<li>If it is good enough, do it now</li>
</ol>


<p>Obviously, large refactorings should also be split into smaller <del>value adding</del> cost reducing items. But then what ?</p>

<p><a href="https://www.amazon.com/Nature-Software-Development-Simple-Valuable/dp/1941222374/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470290668&amp;sr=8-1&amp;keywords=the+nature+of+software+development"><img src="http://philippe.bourgau.net/imgs/2016-08-02-when-the-boy-scout-rule-fails/nature-of-software.jpg" alt="The cover of &quot;The Nature of Software Development&quot;" /></a></p>

<p>In <a href="https://www.amazon.com/Nature-Software-Development-Simple-Valuable/dp/1941222374/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1470290668&amp;sr=8-1&amp;keywords=the+nature+of+software+development">The Nature of Software Development</a> Ron Jefferies says that we need a unique value-based prioritization strategy for everything, including technical improvements. Once you&rsquo;ve got that, there&rsquo;s no sense in splitting and embedding your refactoring in other tasks, this will just increase your work in progress, reducing your throughput and cycle time.</p>

<p>Frankly, I think that&rsquo;s easier said than done. I can <em>think</em> of two ways :</p>

<ul>
<li>As Ron Jefferies tends to say, have a jelled-cross-functional team discuss and prioritize collectively</li>
<li>As <a href="http://reinertsenassociates.com/technical-debt-adding-math-metaphor/">Don Reintersen</a> advocates, use an <a href="/a-plan-for-technical-debt-lean-software-development-part-7/">economical framework</a> to estimate the return on investment</li>
</ul>


<p>At least that&rsquo;s a starting point !</p>
]]></content>
  </entry>
  
</feed>
