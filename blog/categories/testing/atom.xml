<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Philippe Bourgau's blog]]></title>
  <link href="http://philou.github.com/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://philou.github.com/"/>
  <updated>2013-04-07T08:41:44+02:00</updated>
  <id>http://philou.github.com/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The poor man's memory profiling]]></title>
    <link href="http://philou.github.com/the-poor-mans-memory-profiling"/>
    <updated>2013-02-01T00:00:00+01:00</updated>
    <id>http://philou.github.com/the-poor-mans-memory-profiling</id>
    <content type="html"><![CDATA[<p>While working on <a href="http://www.mes-courses.fr">www.mes-courses.fr</a>, a background scheduled task that was running fine on heroku started to fail with out of memory errors. After searching a bit, I discovered that the inputs had changed, and that the memory consumption of my task was linearly correlated to the size of the inputs.</p>


<p>So I tried to setup an automatic test to verify that the memory consumption of my task would remain small enough for it to run on <a href="http://www.heroku.com">heroku</a>. This is what I wanted to do :</p>


<ul>
<li>write a unit test for this</li>
<li>run the task once to warm up the memory</li>
<li>run the task once for some small sample input and note the peak memory usage</li>
<li>run the task once for some large sample input and note the peak memory usage</li>
<li>check that the memory usages are very close, whatever the size of the inputs</li>
</ul>


<p>Everything there is quite straightforward, appart from "note the peak memory usage". Here is what I came up with</p>


<ul>
<li>note the initial memory usage</li>
<li>start a thread that garbage collects and notes the memory usage every 10 ms</li>
<li>process the data</li>
<li>tell the thread to stop</li>
<li>memory usage is the difference between the maximum and initial memory usages</li>
</ul>


<p>Here is the code in ruby, but it can be easily translated to any language (I did it for C# once)</p>


<p>
<script src="https://gist.github.com/4696311.js"></script>
</p>


<p>Unfortunately in ruby, memory usage is not directly available without <a href="http://philippe.bourgau.net/how-to-install-a-patched-ruby-interpreter-wit">patching and rebuilding the interpreter</a>, but allocated objects count is available, and it's actually enough for our purpose.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows licker like with C#]]></title>
    <link href="http://philou.github.com/windows-licker-like-with-c"/>
    <updated>2012-11-07T00:00:00+01:00</updated>
    <id>http://philou.github.com/windows-licker-like-with-c</id>
    <content type="html"><![CDATA[<p>In <a href="http://www.growing-object-oriented-software.com/">Growing object-oriented software guided by tests</a>&nbsp;they use a java library called <a href="http://code.google.com/p/windowlicker/">Window Licker</a>&nbsp;to pilot a gui running in&nbsp;test thread. Next time I started a new project, I&nbsp;wanted to apply the techniques I had learned in the book. As the project was in C#, I searched for a C# equivalent of Window Licker. I did not find any, but it turned out to be really simple to create an equivalent.</p>


<p>Here is the user test code I wanted to be able to write (inside a <a href="http://www.specflow.org">SpecFlow</a> step) :</p>


<p>
```c#
[Given(@"TheUserEntersHisEmail""(.*)""")]
public void GivenTheUserEntersHisEmail(string email)
{
  User.Enters(ScenarioContext.Current.UserForm().EmailTextBox, email);
}
```
</p>


<p>Here UserForm is an extension method I added to the ScenarioContext that is responsible for returning the current user form.</p>


<p>As you have noticed, the various gui components must be&nbsp;exposed through some kind of public api. What I did was to expose the main gui window as a property on the application top level object, and then have properties to access all the sub windows and the controls that the tests needed to access. It kind of breaks encapsulation, but it allows to keep the tests working during refactoring !</p>


<p>Eventually, I had to write the User class, and it turned out to be really simple :</p>


<p>
```c#
static class User
{
  internal static void Enters(TextBox textBox, string text)
  {
    textBox.Invoke(new MethodInvoker(() => textBox.Text = text));
  }
}
```
</p>


<p>That's it, all that was needed was to ask the thread of the control to update the text !</p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[stub_model and mock_model]]></title>
    <link href="http://philou.github.com/stubmodel-and-mockmodel"/>
    <updated>2012-04-16T00:00:00+02:00</updated>
    <id>http://philou.github.com/stubmodel-and-mockmodel</id>
    <content type="html"><![CDATA[<p>I decided to stop using stub_model and mock_model. I do not use them enough to get fluent with them. Everytime I have to deal with them, something breaks in an unexpected way. I just decided to stand with good old stubs.</p>


<p>I am also thinking of switching to RR (double ruby) and to use proxy objects to get simplify mocking even further. Did you try it ?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to test a class using an implementation helper ?]]></title>
    <link href="http://philou.github.com/how-to-test-a-class-using-an-implementation-h"/>
    <updated>2011-12-14T00:00:00+01:00</updated>
    <id>http://philou.github.com/how-to-test-a-class-using-an-implementation-h</id>
    <content type="html"><![CDATA[<p>Suppose you have some duplicated code in the Foo &amp; Bar classes. You managed to extracted this code in an helper class. Fine, the helper class can now be tested on its own, but how do I get rid of duplication in FooTest and BarTest ?<p />I though of injecting a mock on the helper class in Foo &amp; Bar when testing, to make sure the helper instance is correctly used, but sometimes, it just feel as if testing an implementation ...<p />Here is what we eventually did at work : create an abstract base class to test the api of the helper class. Implement this abstract class once to test the helper class itself, and then implement it once each time it is reused.<p />Here is an exemple with a ListBuilder helper class that wraps a list and returns a copy of it each time it is asked for.<p />
```c#
public class ListBuilder<T>
{
  private readonly List<T> _internalList = new List<T>();
  private List<T> _listSnapshot = new List<T>();
  private readonly object _locker = new object();

  public List<T> ListSnapshot()
  {
    lock (_locker)
    {
      if (_listSnapshot.Count != _internalList.Count)
      {
        _listSnapshot = new List<T>(_internalList);
      }
    }

    return _listSnapshot;
  }

  public void Add(T newItem)
  {
    lock (_locker)
    {
      _internalList.Add(newItem);
    }
  }
}

```
<p />Here is the tests for ListBuilder class itself<p />
```
public abstract class ListBuilderContractTest<T>
{
  protected abstract void AddAnItem();
  protected abstract void VerifyAddedItem(T addedItem);
  protected abstract List<T> ListCopy();

  [Test]
  public void TheDefaultListShouldBeEmpty()
  {
    Assert.AreEqual(0, ListCopy().Count);
  }

  [Test]
  public void AddShouldAddItemInList()
  {
    AddAnItem();
    VerifyItemWasAdded();
  }

  protected void VerifyItemWasAdded()
  {
    var copy = ListCopy();
    Assert.AreEqual(1, copy.Count);
    VerifyAddedItem(copy[0]);
  }

  [Test]
  public void WhenOfSameSizeNewListCopyShoulReturnSameList()
  {
    AddAnItem();
    Assert.AreSame(ListCopy(), ListCopy());
  }

  [Test]
  public void CopiesShouldBeSnapshots()
  {
    var copy = ListCopy();

    AssertExecution.Of(AddAnItem)
      .ShouldNotChange(() => copy.Count);
  }
}

[TestFixture]
public class ListBuilderTest : ListBuilderContractTest<string>
{
  private const string ADDED_ITEM = "toto";

  private ListBuilder<string> _appender;

  [SetUp]
  public void SetUp()
  {
    _appender = new ListBuilder<string>();
  }

  protected override void AddAnItem()
  {
    _appender.Add(ADDED_ITEM);
  }
  protected override void VerifyAddedItem(string addedItem)
  {
    Assert.AreEqual(ADDED_ITEM, addedItem);
  }

  protected override List<string> ListCopy()
  {
    return _appender.ListSnapshot();
  }
}

```
<p />And here are tests for other class using it. First a simple one :<p />
```c#
[TestFixture]
public class OrderPresenterAsExecListBuilderTest : ListBuilderContractTest<IExecRowPresenter>
{
  private OrderPresenter _presenter;
  private Mock<IExec> _exec;

  [SetUp]
  public void SetUp()
  {
    _exec = new Mock<IExec>();
    _exec.Setup(x => x.Id).Returns("an exec");
    _exec.Setup(x => x.Price).Returns(123.456);
    _exec.Setup(x => x.Quantity).Returns(36);

    _presenter = new OrderPresenter();
  }

  protected override void AddAnItem()
  {
    _presenter.AddExec(_exec.Object);
  }

  protected override void VerifyAddedItem(IExecRowPresenter addedItem)
  {
    Assert.AreEqual(_exec.Object.Id, addedItem.Id);
    Assert.AreEqual(_exec.Object.Price, addedItem.Price);
    Assert.AreEqual(_exec.Object.Quantity, addedItem.Quantity);
  }

  protected override List<IExecRowPresenter> ListSnapshot()
  {
    return _presenter.GraphicalExecs;
  }
}

```
<p />Then a more complex one :<p />
```c#
[TestFixture]
public class StrategyPresenterAsOrderPresenterListBuilderTest : ListBuilderContractTest<IOrderPresenter>
{
  private StrategyPresenter _presenter;
  private Mock<IStrategy> _strategy;
  private Mock<IOrder> _order;

  [SetUp]
  public void SetUp()
  {
    _strategy= new Mock<IStrategy> { DefaultValue = DefaultValue.Mock };

    _order = new Mock<IOrder>();
    _order.Setup(x => x.Id).Returns(123);

    _presenter = new StrategyPresenter(_strategy.Object);
  }

  protected override void AddAnItem()
  {
    _strategy.Raise(x => x.SentQuantityChanged += null, new SentQuantityChangedEventArgs {Origin = _order.Object});
  }

  protected override void VerifyAddedItem(IOrderPresenter addedItem)
  {
    Assert.AreEqual(_order.Object.Id, addedItem.Id);
  }

  protected override List<IOrderPresenter> ListSnapshot()
  {
    return _presenter.GraphicalOrderList;
  }


  [Test]
  public void ExecutedQuantityChangedShouldAddAnItem()
  {
    _strategy.Raise(x => x.ExecutedQuantityChanged += null, new ExecutedQuantityChangedEventArgs {Origin = _order.Object});

    VerifyItemWasAdded();
  }
}
```
<p />The solution really pleases me :<p />&nbsp;&nbsp;&nbsp; No code duplication<br />&nbsp;&nbsp;&nbsp; Robust tests<br />&nbsp;&nbsp;&nbsp; No artificial mocking<p /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automaticaly rollback static overrides when testing legacy code]]></title>
    <link href="http://philou.github.com/75417332"/>
    <updated>2011-10-14T00:00:00+02:00</updated>
    <id>http://philou.github.com/75417332</id>
    <content type="html"><![CDATA[<p>When working with legacy code, writing tests requires to exploit seams to -hack- inject custom behaviour. In his <a href="http://www.amazon.co.uk/Working-Effectively-Legacy-Robert-Martin/dp/0131177052/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1245554188&amp;sr=8-1" title="Great book about testing legacy code">book</a> Michael Feathers explains that singleton (the anti pattern) are often good starting seams. The idea is as follow :</p>


<ol>
<li>create a public method to override the singleton value</li>
<li>make this method deprecated, obsolete or use a TEST_ONLY_ name prefix so that it is not called elsewhere in the code</li>
<li>Call this method from your test code to inject a mock or whatever so that you can test in isolation</li>
</ol>


<p>This works fine ... until you end up with an unexpected failing test [long debugging session]&nbsp;that is in fact the result of a test not restoring a singleton it had overriden. You can try hard not to forget, or you can use some kind of auto restore test class. Here is how it could look like in C#</p>


<p>
```c#
using System;
using System.Collections.Generic;
using NUnit.Framework;

namespace Test.Utils
{
  public class CleanOverridesTest
  {
    private class StaticOverrider&lt;T&gt; : IDisposable
    {
      private readonly T _initialValue;
      private readonly Action&lt;T&gt; _setter;

      public StaticOverrider(T initialValue, Action&lt;T&gt; setter, T newValue)
      {
        _initialValue = initialValue;
        _setter = setter;

        _setter(newValue);
      }

      public void Dispose()
      {
        _setter(_initialValue);
      }
    }

    private List&lt;IDisposable&gt; _toDisposeAfterEachTest;
    private List&lt;IDisposable&gt; ToDisposeAfterEachTest
    {
      get
      {
        // NUnit enforces a single SetUp method, so we have to make sure the base SetUp method was called by subclasses
        Assert.IsTrue(BaseSetUpCalled, "Override SetUp and TearDown, and call base implementation.");
        return _toDisposeAfterEachTest;
      }
    }


    [SetUp]
    public virtual void SetUp()
    {
      _toDisposeAfterEachTest = new List&lt;IDisposable&gt;();
    }
    private bool BaseSetUpCalled
    {
      get { return _toDisposeAfterEachTest != null; }
    }

    [TearDown]
    public virtual void TearDown()
    {
      // Overides and restores should be done in reverse order
      ToDisposeAfterEachTest.Reverse();
      foreach(var disposable in ToDisposeAfterEachTest)
      {
        try
        {
          disposable.Dispose();
        }
        catch (Exception)
        { }

      }
      ToDisposeAfterEachTest.Clear();
    }

    protected void OverrideStatic&lt;T&gt;(T initialValue, Action&lt;T&gt; setter, T newValue)
    {
      ToDisposeAfterEachTest.Add(new StaticOverrider&lt;T&gt;(initialValue, setter, newValue));
    }
  }
}
```
</p>


<p>Later in an actual test :</p>


<p>
```c#
[TestFixture]
public class LegacyTest : CleanOverridesTest
{
  [Test]
  public void LegacyShouldWorkWhenZingAndZang()
  {
    OverrideStatic(BigManager.Instance, BigManager.TestOnlySetInstance, new BigInstanceMock());

    ...
  }
}
```
</p>


<p>The singleton is automaticaly restored in the TearDown method of the base class. In C#, we are luky enough to have delegates so that we can pass the injection setter directly. In language without this feature, you could use reflection or anonymous class.</p>


<p>Of course, when the code is more reliably tested, you should try to move away from all this hack ...</p>

]]></content>
  </entry>
  
</feed>
