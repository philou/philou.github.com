<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2013-07-25T07:34:11+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jasmine and coffeescript setup for rails]]></title>
    <link href="http://philippe.bourgau.net/jasmine-and-coffeescript-setup-for-rails/"/>
    <updated>2013-07-04T07:44:00+02:00</updated>
    <id>http://philippe.bourgau.net/jasmine-and-coffeescript-setup-for-rails</id>
    <content type="html"><![CDATA[<p>As I started to write more javascript code in my <a href="https://www.mes-courses.fr">rails app</a>, it became obvious that I should be testing it ! I wanted to use <a href="http://pivotal.github.io/jasmine/">jasmine</a> and <a href="http://coffeescript.org">coffeescript</a>. I searched a long time to find out what was the most common and supported setup for a rails app, so now I recommand</p>

<p><code>ruby
gem 'jasmine'
gem 'jasminerice'
gem 'guard-jasmine'
</code></p>

<ul>
<li>The <a href="https://github.com/pivotal/jasmine-gem">jasmine gem</a> is by far the most common jasmine gem, it is supported by <a href="http://pivotallabs.com">Pivotal Labs</a> so there is no fear of it being droped soon.</li>
<li>The <a href="https://github.com/netzpirat/guard-jasmine">guard-jasmin gem</a> is supported by <a href="https://mksoft.ch">MKSoft</a>, and is not only handling continuous <a href="http://phantomjs.org/">phantomjs</a> headless jasmine testing through guard, but it also provides command line and rake tools to run your jasmine specs during continuous integration.</li>
<li>Eventually, the <a href="https://github.com/bradphelan/jasminerice">jasminerice gem</a> makes it easy to write your jasmine specs with coffeescript. It also wraps a version of <a href="https://github.com/velesin/jasmine-jquery">jasmine-jquery</a> to assist client javascript testing. Although there is a &ldquo;looking for maintainer&rdquo; message on the README page, there are some recent commits, so it seems that pull requests are still being merged even if the project is not actively developpped anymore &hellip; I belive volunteers are welcome.</li>
</ul>


<p>All 3 have detailed and up to date setup and usage instructions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ditching autotest for guard]]></title>
    <link href="http://philippe.bourgau.net/ditching-autotest-for-guard/"/>
    <updated>2013-07-03T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/ditching-autotest-for-guard</id>
    <content type="html"><![CDATA[<p>I have been using <a href="https://github.com/grosser/autotest">autotest</a> for 2 years, and it&rsquo;s been great ! The first time I ran it I thought &ldquo;This rocks !&rdquo; and I have always been using it since &hellip;</p>

<p>A little later I read the book <a href="http://pragprog.com/book/rcctr/continuous-testing">Continuous Testing: with Ruby, Rails and JavaScript</a> and it suggested to use <a href="https://github.com/mynyml/watchr">watchr</a> instead. I never switched, partly because I did not take the time, and partly because watchr seemed to need quite a bit of manual configuration. Then, while contributing to other gems, I stumbled upon <a href="https://github.com/guard/guard">guard</a> and this one seemed great.</p>

<p>Switching to guard was in fact very simple, It took about 15 minutes, a lot less than the time I had spent configuring or tweaking autotest. I simply added these to my Gemfile
<code>ruby
gem 'guard'
gem 'guard-rspec'
gem 'guard-cucumber'
</code>
I ran the install steps, and everything was working ! It&rsquo;s a shame I did not do the change earlier.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Be careful not to bundle FakeWeb in production]]></title>
    <link href="http://philippe.bourgau.net/be-careful-not-to-bundle-fakeweb-in-production/"/>
    <updated>2013-07-03T06:31:00+02:00</updated>
    <id>http://philippe.bourgau.net/be-careful-not-to-bundle-fakeweb-in-production</id>
    <content type="html"><![CDATA[<p>For testing purpose, I added <a href="https://github.com/chrisk/fakeweb">FakeWeb</a> to my app. Later, I deployed it to a staging env on heroku to find out that my scrapper started to fail with some strange Net::HTTPForbidden were occuring after about 90 minutes of scrapping, with no clear reason. It turned that I had mistakenly added FakeWeb to all environments, and that just removing it fixed the issue !</p>

<p>As it is working now, I didn&rsquo;t take the time to dig deeper into it &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matching meta tags with Capybara 2]]></title>
    <link href="http://philippe.bourgau.net/matching-meta-tags-with-capybara-2/"/>
    <updated>2013-07-01T20:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/matching-meta-tags-with-capybara-2</id>
    <content type="html"><![CDATA[<p>As I updated my bundle, some capybara have_selector(&hellip;) matches started to fail. Here was the message :</p>

<p><code>
expected to find xpath "//meta[@http-equiv='refresh']" but there were no matches. Also found "", which matched the selector but not all filters. (Capybara::ExpectationNotMet)
</code></p>

<p>After some searching, I eventually understood that it was a modification in the behaviour of Capybara 2 that only matches elements in the html body, and not in the head anymore. If trying to match the title, <a href="http://stackoverflow.com/questions/13573525/rspec-capybara-2-0-tripping-up-my-have-selector-tests">stackoverflow suggests</a> to use :
<code>ruby
expect(response).to have_title('My page')
</code></p>

<p>To match meta tags, I had to resort to the following :
<code>ruby
meta_refresh_tags = Nokogiri::HTML(page.source).xpath("//meta[@http-equiv='refresh']")
expect(meta_refresh_tags).not_to(be_empty, 'could not find a meta refresh tag')
</code></p>

<p>I could do with something nicer, but it&rsquo;s ok for the moment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hitting the middle ground between classicist and mockist TDD]]></title>
    <link href="http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd/"/>
    <updated>2013-06-18T08:55:00+02:00</updated>
    <id>http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd</id>
    <content type="html"><![CDATA[<p>From <a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler&rsquo;s point of view</a>, I must have been a mockist. With using mocks extensively comes quite a few advantages :</p>

<ul>
<li>test failures often pinpoint the falsy code</li>
<li>easier test organisation mimicking that of the code</li>
<li>faster tests</li>
<li>simpler test initialization</li>
</ul>


<p>Mocks also have their own problems, but mostly :</p>

<ul>
<li>especialy with dynamicaly typed languages, a mock for class A might not implement the same methods than the real class A, but the test might be passing though ! This ampers refactoring with a longer feedback loop and mock setup rewriting</li>
</ul>


<p>That&rsquo;s what always bothered me. Eventually I tried a combinaison of techniques that seem to work well together and provides most of the best of both worlds.</p>

<ul>
<li>extensive use of factories (with <a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a>) to simplify setup</li>
<li>use of an <a href="http://www.sqlite.org/inmemorydb.html">in memory sqlite database</a> to get a fast full working db</li>
<li>implement fully functional fakes for some parts of the system</li>
<li>carefull use of mocks, inspired from <a href="http://blog.rubybestpractices.com/posts/gregory/052-issue-20-thoughts-on-mocking.html">Gregory Brown&rsquo;s thoughts on mocks</a>

<ul>
<li>when a test is too slow</li>
<li>to cut off a dependency to a subsystem that is not available in a unit test</li>
<li>to simplify overly long test data setup</li>
</ul>
</li>
<li>use of test proxies (as in <a href="https://github.com/rr/rr">rr</a>) to inject specific behaviour or to perform specific checks without modifying the rest of the program.</li>
</ul>


<p>Here is how I implemented this with rspec :</p>

<script src="https://gist.github.com/philou/5894144.js"></script>


<p>With all this in place, it is most of the time possible to write straightforward tests. For example here, only real objects are used. @order gets its value when Order.create! is called.</p>

<p>```ruby
it &ldquo;should create an order with the cart&rdquo; do
  capture_result_from(Order, :create!, into: :order)</p>

<p>  check_in_cart</p>

<p>  @order.should_not be_nil
  @order.cart.should == @cart
end
```</p>

<p>Maybe I should swith to rr &hellip;</p>
]]></content>
  </entry>
  
</feed>
