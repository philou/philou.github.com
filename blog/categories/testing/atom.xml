<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2014-03-22T08:19:39+01:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[My humble advices about how to write maintainable tests]]></title>
    <link href="http://philippe.bourgau.net/my-humble-advices-about-how-to-write-maintainable-tests/"/>
    <updated>2014-02-04T06:10:00+01:00</updated>
    <id>http://philippe.bourgau.net/my-humble-advices-about-how-to-write-maintainable-tests</id>
    <content type="html"><![CDATA[<p>I love writing automated tests &hellip; or rather, I hate having to work in untested code. I find it makes my life unnecessarily stressful. On the other hand, the cost of maintaining badly written tests can sometimes outweigh their benefits. This is usually the moment where the team resorts to manual testing, and gets back to the ways of &lsquo;the good old days&rsquo;. Personally, I don&rsquo;t like the good old days when we had to stay up all night <del>to add even more mess</del> to fix something for an important deadline.</p>

<p>Here is how I try to make my tests as maintainable as possible :</p>

<ul>
<li>Write the tests before the code, it gets a (short) time to get used to, but after that, it&rsquo;s just a lot more fun. Just try it for a while</li>
<li>Write tests with no side effects, otherwise, it will not be possible to run your tests alone, or in a different order ! So don&rsquo;t use globals</li>
<li>Write readable tests : did you ever had to fix a test that you cannot figure out the intent ? A lot of the other points just help writing more readable tests</li>
<li>Write small tests : they are usually faster to run, allow you to test more edge cases, and make a better job at pinpointing the actual faulty code. The receipe for writing short tests is to follow the given-when-then pattern :

<ul>
<li>start your test by setting the context (given)</li>
<li>do the thing you actually want to test (when)</li>
<li>verify that it did what you wanted (then)</li>
</ul>
</li>
<li>Remove code duplication from your tests, in the same way as you would in production code. This will help you when you&rsquo;ll want to modify that constructor that is used in 764 test files &hellip;</li>
<li>Use test data builders. This will avoid duplicated and long context setup at the beginning of every test. Don&rsquo;t use factory methods or the object mother pattern, it just does not scale. In java, this usually means <a href="http://www.natpryce.com/articles/000714.html">rollying your own</a>, in ruby, just use <a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a></li>
<li>Use custom assertion objects. This will avoid duplicated and complicated verification code at the end of every test. It will also help to improve assertion messages. In ruby, this comes built in <a href="http://rspec.info/">rspec</a> and its <a href="https://www.relishapp.com/rspec/rspec-expectations/v/2-0/docs/matchers/define-matcher">matcher dsl</a>. Lately, in Java I have been using <a href="https://github.com/alexruiz/fest-assert-2.x">Fest Assert</a></li>
<li>Use the extended red &ndash;> red with explicit error message &ndash;> green &ndash;> refactor in place of the shorter red &ndash;> green &ndash;> refactor. By spending some time to improve your assertion messages, you&rsquo;ll eventually save time to understand what broke when the test fails</li>
<li>As <a href="http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd/">I already wrote about</a>, only use mocks to

<ul>
<li>speed up a test that is too slow</li>
<li>cut off a dependency to an unavailable subsystem</li>
<li>simplify an overly complex test setup</li>
</ul>
</li>
<li>Use constructor based dependency injection. It&rsquo;s straightforward, low tech, and simplifies test setup</li>
<li>As there is no need to mock immutable data structures, I found that using immutable classes for values simplifies tests</li>
<li>Usually use hand coded mocks. Hand coded mocks become difficult to maintain when the code becomes too tangled, they can help me to know that I am doing something wrong (not mocking at the correct place, testing implementation, not doing enough refactoring &hellip;). On the contrary, mock framework make this so easy that I usually miss the issue completely until it is too late</li>
<li>Except when your mocking framework provides object proxing and automatic unmocking. Ruby&rsquo;s <a href="http://rr.github.io/rr/">RR</a> provides this. Both features can be really useful when needed.</li>
<li>Use existing mocks when possible. For example, <a href="http://www.sqlite.org/">Sqlite</a> in memory database : it speeds up the tests, removes the need for any environment setup, and is usually very simple to setup</li>
<li>Last of all, listen to your tests : if they get difficult to write, they might be a design improvement opportunity lying somewhere</li>
</ul>


<p>All in all there is nothing new here. A lot of things come from <a href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?ie=UTF8&amp;qid=1391579113&amp;sr=8-1&amp;keywords=growing+object-oriented+software+guided+by+tests">GOOS</a> others from <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_bxgy_b_text_y">Clean Code</a>, the mocking &lsquo;requirements&rsquo; come from <a href="http://blog.rubybestpractices.com/posts/gregory/052-issue-20-thoughts-on-mocking.html">an article from Gregory Brown</a>, I found others from my own experience and from a lot of other sources I cannot remember now &hellip;</p>

<p>Happy testing !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I organized my javascript assets in Rails]]></title>
    <link href="http://philippe.bourgau.net/how-i-organized-my-javascript-assets-in-rails/"/>
    <updated>2013-11-27T05:56:00+01:00</updated>
    <id>http://philippe.bourgau.net/how-i-organized-my-javascript-assets-in-rails</id>
    <content type="html"><![CDATA[<p><a href="/jasmine-and-coffeescript-setup-for-rails/">Lately</a>, I have been introducing javascript and coffeescript in <a href="http://www.mes-courses.com">www.mes-courses.fr</a> (with structural architecture issues as a side effect, but that&rsquo;s another story &hellip;).</p>

<p>Here are the general goals I had when using the rails asset pipeline :</p>

<ul>
<li>most of js compiled in a single file</li>
<li>no js code in your html files : I want to use unintrusive javascript techniques, and have some outside js hook code that will wire js and html together</li>
<li>sometimes, I want some js code to be only explicitly included by some particular pages (example: hooking a timer on the document ready event of a particular html page). This means that I cannot simply compile all js code in a single minified file</li>
<li>In unit tests, I want to be able to manually set up and tear down the js hooks</li>
</ul>


<p>So, here is how I eventually organized my js code :</p>

<ul>
<li>I create a specific dependencies.js file that will require all outside dependencies</li>
<li>I split my js code under 3 subdirectories :

<ul>
<li>explicit : hooks that will be explicitly included</li>
<li>hooks : all the other hooks</li>
<li>application : all the real code</li>
</ul>
</li>
<li>In my application.js, I include dependencies and all files under application and hooks. Here is my app/assets/javascript/application.js</li>
</ul>


<p><code>javascript
//= require dependencies.js
//= require_tree ./application
//= require_tree ./hooks
</code></p>

<ul>
<li>In my tests, I only load dependencies and files from the application directory. Here is my spec/javascript/spec.js.coffee</li>
</ul>


<p>```coffeescript</p>

<h1>= require ../../app/assets/javascripts/dependencies.js</h1>

<h1>= require_tree ../../app/assets/javascripts/application</h1>

<h1>= require_tree ./</h1>

<p>```</p>

<ul>
<li>Hook code only consists of calling a setup function from the &lsquo;real&rsquo; code. For example, here is my app/assets/javascript/hooks/cart_lines/index.coffee file</li>
</ul>


<p><code>coffeescript
$(document).ready(window.mesCourses.cartLines.index.setUp)
</code></p>

<p>this setUp function is defined in the app/assets/javascript/application/cart_lines/index.coffee file</p>

<ul>
<li>This way, from the unit tests, I can explicitly call this setUp function, here is the beginning of my spec/javascript/application/cart_lines/index_spec.coffee file</li>
</ul>


<p>```coffeescript
describe &lsquo;mesCourses.cartLines.index&rsquo;, &ndash;></p>

<p>  beforeEach &ndash;></p>

<pre><code>window.mesCourses.cartLines.index.setUp()
</code></pre>

<p>  &hellip;
```</p>

<p>And you, how are you organizing your javacript assets ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec Matchers Combinators 2 : spec_combos gem]]></title>
    <link href="http://philippe.bourgau.net/rspec-matchers-combinators-2-spec-combos-gem/"/>
    <updated>2013-09-25T21:29:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-matchers-combinators-2-spec-combos-gem</id>
    <content type="html"><![CDATA[<p>I already wrote about my <a href="/rspec-matchers-combinators/">RSpec Matchers Combinators</a>, I decided to extract them into the <a href="https://github.com/philou/spec_combos">spec_combos</a> gem.</p>

<p>To use it, just add the following to your Gemfile :</p>

<p><code>ruby
gem 'spec_combos', :group =&gt; 'test'
</code></p>

<p>Compared to the first version of the matchers, I added better error messages. For example, consider the following complex nested assertion :</p>

<p><code>ruby
expect([1,2,3]).to all_{and_(be_odd, be_instance_of(Fixnum))}
</code></p>

<p>It outputs the following error :</p>

<p>```text
Failure/Error: expect([1,2,3]).to all<em>{and</em>(be_odd, be_instance_of(Fixnum))}
  expected [1, 2, 3] to all be odd and be an instance of Fixnum, but the following were not:</p>

<pre><code>[1] (2): expected 2 to be odd and be an instance of Fixnum, but:
  expected odd? to return true, got false
</code></pre>

<p>```</p>

<p>I hope this might help !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSpec matchers combinators]]></title>
    <link href="http://philippe.bourgau.net/rspec-matchers-combinators/"/>
    <updated>2013-09-11T12:23:00+02:00</updated>
    <id>http://philippe.bourgau.net/rspec-matchers-combinators</id>
    <content type="html"><![CDATA[<p><a href="http://rubydoc.info/gems/rspec-expectations">Rspec matchers</a> are a lot like predicates. Predicates that can talk &hellip; The good thing about predicates, as anybody who has done a bit of functional programming will tell you, is that they are easy to combine together into bigger predicates. I was really suprised to see that rspec does not come with such simple combinators as &lsquo;and&rsquo; or &lsquo;or&rsquo;.</p>

<p>Here is a gist where I define simple combinators :</p>

<script src="https://gist.github.com/philou/6521797.js"></script>


<p>With this and the <a href="https://github.com/bmabey/email-spec">email_spec</a> matchers, it is possible to write something like this to find if an email was sent by rails :</p>

<p>```ruby
expect(all_emails).to have_any_that(and_(deliver_to(receiver),</p>

<pre><code>                                     have_subject(subject),
                                     have_body_text(body)))
</code></pre>

<p>```</p>

<p>It enables expressive test code and high reusability.</p>

<p>Using the &lsquo;all&rsquo; combinator it is possible to write things like that :</p>

<p><code>ruby
expect(sample_items_attributes).to all_ have_key(:price)
</code></p>

<p>I had to prepend &lsquo;all&rsquo; and &lsquo;and&rsquo; with an underscore because I would otherwise get conflicts&hellip; I&rsquo;m not overly satisfied with this, but it will do for the moment.</p>

<p>I was happily supprised by the readability of error messages when the mach fails. Rspec does a very good job about this. I think it would be possible to get even better error messages by explicity using the sub matchers messages though. If anyone is interested, help yourself !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spork alternative compatible with cucumber]]></title>
    <link href="http://philippe.bourgau.net/spork-alternative-compatible-with-cucumber/"/>
    <updated>2013-08-03T08:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/spork-alternative-compatible-with-cucumber</id>
    <content type="html"><![CDATA[<p>Version 1.3.0 of <a href="http://cukes.info/">Cucumber</a> droped spork support, so I had to find something else. I am using <a href="https://github.com/guard/guard">Guard</a> setup with <a href="http://rspec.info/">rspec</a> and Cucumber for my <a href="http://rubyonrails.org/">Rails</a> app.</p>

<p>I first tried <a href="https://github.com/burke/zeus">Zeus</a> with <a href="https://github.com/qnm/guard-zeus">guard-zeus</a>, it kind of worked, but it ruined my Guard console with the Zeus server status, and it left zombie processes on guard exit &hellip;</p>

<p>Eventually, I tried <a href="https://github.com/jonleighton/spring">Spring</a>, and once I made sure <a href="/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db/">rspec and cucumber both ran on the test environment</a>, it worked fine with minimal configuration. Here is what I had to do to get it working</p>

<ul>
<li>remove spork from your Gemfile</li>
<li>remove require &lsquo;spork&rsquo;, Spork.prefork and Spork.each_run calls from spec/spec_helper.rb and features/support/env.rb</li>
<li>install spring</li>
</ul>


<p><code>
gem install spring
</code></p>

<ul>
<li>add spring to your Gemfile ! Also <a href="https://github.com/jonleighton/spring/blob/master/README.md">they say it is not required</a> I later had an error complaining it wasn&rsquo;t.</li>
</ul>


<p><code>ruby
group :test, :development do
  ...
  gem 'spring'
  ...
group
</code></p>

<ul>
<li>update your Guardfile example :</li>
</ul>


<p>```ruby
guard :rspec, cli: &ldquo;&mdash;tag ~@slow&rdquo;, all_after_pass: true, all_on_start: false, keep_failed: true, spring: true, bundler: false do
  &hellip;
end</p>

<p>guard &lsquo;cucumber&rsquo;, all_on_start: false, cli: &lsquo;&mdash;format progress &mdash;no-profile&rsquo;, command_prefix: &lsquo;spring&rsquo;, bundler: false do
  &hellip;
end
```</p>

<ul>
<li>add a .spring.rb file to automaticaly restart Spring on main file changes. I think I&rsquo;ll have to update this file when I discover that a test failed because spring needs to be restarted</li>
</ul>


<p>```ruby
Spring.watch &ldquo;.spring.rb&rdquo;
Spring.watch &ldquo;spec/factories&rdquo;
Spring.watch &ldquo;features/env.rb&rdquo;</p>

<p>Spring.watch_method = :listen
```</p>
]]></content>
  </entry>
  
</feed>
