<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2013-07-01T20:32:15+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Matching meta tags with Capybara 2]]></title>
    <link href="http://philippe.bourgau.net/matching-meta-tags-with-capybara-2/"/>
    <updated>2013-07-01T20:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/matching-meta-tags-with-capybara-2</id>
    <content type="html"><![CDATA[<p>As I updated my bundle, some capybara have_selector(...) matches started to fail. Here was the message :</p>

<p><code>
expected to find xpath "//meta[@http-equiv='refresh']" but there were no matches. Also found "", which matched the selector but not all filters. (Capybara::ExpectationNotMet)
</code></p>

<p>After some searching, I eventually understood that it was a modification in the behaviour of Capybara 2 that only matches elements in the html body, and not in the head anymore. If trying to match the title, <a href="http://stackoverflow.com/questions/13573525/rspec-capybara-2-0-tripping-up-my-have-selector-tests">stackoverflow suggests</a> to use :
<code>ruby
expect(response).to have_title('My page')
</code></p>

<p>To match meta tags, I had to resort to the following :
<code>ruby
meta_refresh_tags = Nokogiri::HTML(page.source).xpath("//meta[@http-equiv='refresh']")
expect(meta_refresh_tags).not_to(be_empty, 'could not find a meta refresh tag')
</code></p>

<p>I could do with something nicer, but it's ok for the moment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hitting the middle ground between classicist and mockist TDD]]></title>
    <link href="http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd/"/>
    <updated>2013-06-18T08:55:00+02:00</updated>
    <id>http://philippe.bourgau.net/hitting-the-middle-ground-between-classicist-and-mockist-tdd</id>
    <content type="html"><![CDATA[<p>From <a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler's point of view</a>, I must have been a mockist. With using mocks extensively comes quite a few advantages :</p>

<ul>
<li>test failures often pinpoint the falsy code</li>
<li>easier test organisation mimicking that of the code</li>
<li>faster tests</li>
<li>simpler test initialization</li>
</ul>


<p>Mocks also have their own problems, but mostly :</p>

<ul>
<li>especialy with dynamicaly typed languages, a mock for class A might not implement the same methods than the real class A, but the test might be passing though ! This ampers refactoring with a longer feedback loop and mock setup rewriting</li>
</ul>


<p>That's what always bothered me. Eventually I tried a combinaison of techniques that seem to work well together and provides most of the best of both worlds.</p>

<ul>
<li>extensive use of factories (with <a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a>) to simplify setup</li>
<li>use of an <a href="http://www.sqlite.org/inmemorydb.html">in memory sqlite database</a> to get a fast full working db</li>
<li>implement fully functional fakes for some parts of the system</li>
<li>carefull use of mocks, inspired from <a href="http://blog.rubybestpractices.com/posts/gregory/052-issue-20-thoughts-on-mocking.html">Gregory Brown's thoughts on mocks</a>

<ul>
<li>when a test is too slow</li>
<li>to cut off a dependency to a subsystem that is not available in a unit test</li>
<li>to simplify overly long test data setup</li>
</ul>
</li>
<li>use of test proxies (as in <a href="https://github.com/rr/rr">rr</a>) to inject specific behaviour or to perform specific checks without modifying the rest of the program.</li>
</ul>


<p>Here is how I implemented this with rspec :</p>

<script src="https://gist.github.com/philou/5894144.js"></script>


<p>With all this in place, it is most of the time possible to write straightforward tests. For example here, only real objects are used. @order gets its value when Order.create! is called.</p>

<p>```ruby
it "should create an order with the cart" do
  capture_result_from(Order, :create!, into: :order)</p>

<p>  check_in_cart</p>

<p>  @order.should_not be_nil
  @order.cart.should == @cart
end
```</p>

<p>Maybe I should swith to rr ...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Display full backtraces in rspec]]></title>
    <link href="http://philippe.bourgau.net/display-full-backtraces-in-rspec/"/>
    <updated>2013-06-07T06:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/display-full-backtraces-in-rspec</id>
    <content type="html"><![CDATA[<p>I use <a href="http://rspec.info/">rspec</a> a lot. I thinks it's a great testing framework.</p>

<p>In order to get shorter error output, rspec cleans backtraces from outside code. Here are all the patterns that are removed from the full backtrace :</p>

<p><code>ruby
DEFAULT_BACKTRACE_PATTERNS = [
  /\/lib\d*\/ruby\//,
  /org\/jruby\//,
  /bin\//,
  %r|/gems/|,
  /spec\/spec_helper\.rb/,
  /lib\/rspec\/(core|expectations|matchers|mocks)/
]
</code></p>

<p>Most of the time, that's great. Sometimes though, we get messages that seem completly unrelated to the code. Even worse, we might get misleading messages, such as "method called with unexpected number of arguments" that does not refer to the code in the backtrace, but to some other library code ...</p>

<p>I thought it would be nice if we could switch this cleaning off sometimes. Here is how I did this :</p>

<p>```ruby
RSpec.configure do |config|</p>

<p>  # RSpec automatically cleans stuff out of backtraces;
  # sometimes this is annoying when trying to debug something e.g. a gem
  if ENV['FULLBACKTRACES'] == 'true'</p>

<pre><code>config.backtrace_clean_patterns = []
</code></pre>

<p>  end</p>

<p>  # some other configuration here</p>

<p>end
```</p>

<p>This way, it is still possible to call rspec as before to get the standard behaviour, but it is now possible to specify the FULLBACKTRACES variable to get full backtraces.</p>

<p><code>
FULLBACKTRACES=true bundle exec rspec spec
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't repeat names in cucumber scenarios]]></title>
    <link href="http://philippe.bourgau.net/dont-repeat-names-in-cucumber-scenarios/"/>
    <updated>2013-05-09T08:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/dont-repeat-names-in-cucumber-scenarios</id>
    <content type="html"><![CDATA[<p>When the same name is repeated all over the place in a cucumber scenario, it can be difficult to read.
<code>gherkin
Scenario: Withdrawing some cash
  Given a deposit account with 1000€
  When I withdraw 100€ from the deposit account
  Then there should be 900€ on the deposit account
</code>
It would be better if we could write it like that
<code>gherkin
Scenario: Withdrawing some cash
  Given a deposit account with 1000€
  When I withdraw 100€ from the account
  Then there should be 900€ on the account
</code>
Sometimes we actually want to repeat the names though, either for clarity, or if we are dealing with many accounts within the same scenario.</p>

<p>To make both my scenarios more readable and my steps more versatile, I created special main_account_name accessors and a custom transform.
```ruby
def main_account_name
  @main_account_name ||= "credit"
end
def main_account_name=(account_name)
  @main_account_name ||= account_name
end</p>

<p>CAPTURE_ACCOUNT_NAME = Tranform(/<sup>(a|an|the)</sup> <em>(.</em>) account$/) do |_prefix, account_name|
  if account_name == ""</p>

<pre><code>main_account_name
</code></pre>

<p>  else</p>

<pre><code>account_name
</code></pre>

<p>  end
end
<code>
When creating the account, I added some code to set the main_account_name
</code>ruby
Given(/<sup>(#{CAPTURE_ACCOUNT_NAME})</sup> with (\d+)€$/) do |account_name, amount|
  ...
  self.main_account_name= account_name
end
<code>
It is then possible to write steps like
</code>
When(/<sup>I</sup> withdraw (\d+)€ from (#{CAPTURE_ACCOUNT_NAME})$/) do |amount, account_name|
  ...
end
```
that will match both "the deposit account" and "the account" depending on context.</p>

<p>It would be really nice to be able to write things like
<code>gherkin
  Then there should be 900€ on it
</code>
but because of the <a href="/if-new-cucumber-transform-breaks-everyhing-dot-dot-dot/">way cucumber handles transforms</a>, the only way I know to do that is to write a new step definition.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If new cucumber transform breaks everyhing ...]]></title>
    <link href="http://philippe.bourgau.net/if-new-cucumber-transform-breaks-everyhing-dot-dot-dot/"/>
    <updated>2013-05-08T08:36:00+02:00</updated>
    <id>http://philippe.bourgau.net/if-new-cucumber-transform-breaks-everyhing-dot-dot-dot</id>
    <content type="html"><![CDATA[<p>After reading <a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The cucumber book</a> I decided to add clever cucumber transforms but steps started to fail all over the place ... Even completly unrelated scenarios were failing ...</p>

<p>I should have read the <a href="https://github.com/cucumber/cucumber/wiki/Step-Argument-Transforms">Cucumber transforms doc page</a> and particularly the "Transforms wisdom" section before anything, it would have been a real time saver. To summarise, when a step is executed, all transforms regexps are tried on the step captures, and the first matching transform is applied ! Inlining the transform global inside the step regex removes duplication, but in no way does it imply which transform will be applied !</p>

<p>For example</p>

<p>```ruby
CAPTURE_NUMBER = Transform /<sup>.*$/</sup> do |digits|
  Float(digits)
end</p>

<p>When /<sup>I</sup> withdraw (#{CAPTURE_NUMBER}) from "([<sup>"]+)"$/</sup> do |amount, bank_name|
  bank = Bank.find_by_name(bank_name)
  bank.withdraw(amount)
end
```</p>

<p>will match the bank name with CAPTURE_NUMBER, and you'll get an "invalid value for Float" error.</p>
]]></content>
  </entry>
  
</feed>
