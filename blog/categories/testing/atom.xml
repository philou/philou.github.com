<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2013-08-03T08:31:04+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simplest way to speed up rspec with in memory sqlite db]]></title>
    <link href="http://philippe.bourgau.net/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db/"/>
    <updated>2013-08-02T09:16:00+02:00</updated>
    <id>http://philippe.bourgau.net/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db</id>
    <content type="html"><![CDATA[<p>There are already a lot of articles explaining how to setup an in memory <a href="http://www.sqlite.org/">SQLite</a> database to speed up <a href="http://rubyonrails.org/">Rails</a> specs or unit tests. Most of them explain how to change your database.yml and to run setup your schema before running the tests. It works fine.</p>

<p>There&rsquo;s a catch though : suppose you are using <a href="http://cukes.info/">cucumber</a>, it&rsquo;s likely you&rsquo;d rather run cucumber on a real database (<a href="http://www.postgresql.org/">PostgreSQL</a>, <a href="http://www.mysql.com/">MySQL</a> or whatever). Most gems expect cucumber and <a href="http://rspec.info/">rspec</a> to both run in the test environment &hellip; Every time I updated my bundle or that I wanted to use a new test gem, I would hit an issue about cucumber being run in its own &lsquo;cucumber&rsquo; environment : unexpected warnings and things not working out of the box.</p>

<p>Eventually, I ditched the cucumber env, setup a PostgreSQL db on the test env, and injected the in memory sqlite database right inside spec_helper.rb :</p>

<p>In database.yml :</p>

<p><code>yaml
test:
  adapter: postgresql
  database: mes_courses_test
  encoding: utf8
  pool: 5
  timeout: 5000
  username: mes_courses
  password: secret
  host: localhost
  port: 5433
</code></p>

<p>At the bottom of spec_helper.rb</p>

<p>```ruby
setup_sqlite_db = lambda do
  ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)</p>

<p>  load &ldquo;#{Rails.root.to_s}/db/schema.rb&rdquo; # use db agnostic schema by default
  # ActiveRecord::Migrator.up(&lsquo;db/migrate&rsquo;) # use migrations
end
silence_stream(STDOUT, &amp;setup_sqlite_db)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jasmine and coffeescript setup for rails]]></title>
    <link href="http://philippe.bourgau.net/jasmine-and-coffeescript-setup-for-rails/"/>
    <updated>2013-07-04T07:44:00+02:00</updated>
    <id>http://philippe.bourgau.net/jasmine-and-coffeescript-setup-for-rails</id>
    <content type="html"><![CDATA[<p>As I started to write more javascript code in my <a href="https://www.mes-courses.fr">rails app</a>, it became obvious that I should be testing it ! I wanted to use <a href="http://pivotal.github.io/jasmine/">jasmine</a> and <a href="http://coffeescript.org">coffeescript</a>. I searched a long time to find out what was the most common and supported setup for a rails app, so now I recommand</p>

<p><code>ruby
gem 'jasmine'
gem 'jasminerice'
gem 'guard-jasmine'
</code></p>

<ul>
<li>The <a href="https://github.com/pivotal/jasmine-gem">jasmine gem</a> is by far the most common jasmine gem, it is supported by <a href="http://pivotallabs.com">Pivotal Labs</a> so there is no fear of it being droped soon.</li>
<li>The <a href="https://github.com/netzpirat/guard-jasmine">guard-jasmin gem</a> is supported by <a href="https://mksoft.ch">MKSoft</a>, and is not only handling continuous <a href="http://phantomjs.org/">phantomjs</a> headless jasmine testing through guard, but it also provides command line and rake tools to run your jasmine specs during continuous integration.</li>
<li>Eventually, the <a href="https://github.com/bradphelan/jasminerice">jasminerice gem</a> makes it easy to write your jasmine specs with coffeescript. It also wraps a version of <a href="https://github.com/velesin/jasmine-jquery">jasmine-jquery</a> to assist client javascript testing. Although there is a &ldquo;looking for maintainer&rdquo; message on the README page, there are some recent commits, so it seems that pull requests are still being merged even if the project is not actively developpped anymore &hellip; I belive volunteers are welcome.</li>
</ul>


<p>All 3 have detailed and up to date setup and usage instructions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ditching autotest for guard]]></title>
    <link href="http://philippe.bourgau.net/ditching-autotest-for-guard/"/>
    <updated>2013-07-03T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/ditching-autotest-for-guard</id>
    <content type="html"><![CDATA[<p>I have been using <a href="https://github.com/grosser/autotest">autotest</a> for 2 years, and it&rsquo;s been great ! The first time I ran it I thought &ldquo;This rocks !&rdquo; and I have always been using it since &hellip;</p>

<p>A little later I read the book <a href="http://pragprog.com/book/rcctr/continuous-testing">Continuous Testing: with Ruby, Rails and JavaScript</a> and it suggested to use <a href="https://github.com/mynyml/watchr">watchr</a> instead. I never switched, partly because I did not take the time, and partly because watchr seemed to need quite a bit of manual configuration. Then, while contributing to other gems, I stumbled upon <a href="https://github.com/guard/guard">guard</a> and this one seemed great.</p>

<p>Switching to guard was in fact very simple, It took about 15 minutes, a lot less than the time I had spent configuring or tweaking autotest. I simply added these to my Gemfile
<code>ruby
gem 'guard'
gem 'guard-rspec'
gem 'guard-cucumber'
</code>
I ran the install steps, and everything was working ! It&rsquo;s a shame I did not do the change earlier.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Be careful not to bundle FakeWeb in production]]></title>
    <link href="http://philippe.bourgau.net/be-careful-not-to-bundle-fakeweb-in-production/"/>
    <updated>2013-07-03T06:31:00+02:00</updated>
    <id>http://philippe.bourgau.net/be-careful-not-to-bundle-fakeweb-in-production</id>
    <content type="html"><![CDATA[<p>For testing purpose, I added <a href="https://github.com/chrisk/fakeweb">FakeWeb</a> to my app. Later, I deployed it to a staging env on heroku to find out that my scrapper started to fail with some strange Net::HTTPForbidden were occuring after about 90 minutes of scrapping, with no clear reason. It turned that I had mistakenly added FakeWeb to all environments, and that just removing it fixed the issue !</p>

<p>As it is working now, I didn&rsquo;t take the time to dig deeper into it &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matching meta tags with Capybara 2]]></title>
    <link href="http://philippe.bourgau.net/matching-meta-tags-with-capybara-2/"/>
    <updated>2013-07-01T20:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/matching-meta-tags-with-capybara-2</id>
    <content type="html"><![CDATA[<p>As I updated my bundle, some capybara have_selector(&hellip;) matches started to fail. Here was the message :</p>

<p><code>
expected to find xpath "//meta[@http-equiv='refresh']" but there were no matches. Also found "", which matched the selector but not all filters. (Capybara::ExpectationNotMet)
</code></p>

<p>After some searching, I eventually understood that it was a modification in the behaviour of Capybara 2 that only matches elements in the html body, and not in the head anymore. If trying to match the title, <a href="http://stackoverflow.com/questions/13573525/rspec-capybara-2-0-tripping-up-my-have-selector-tests">stackoverflow suggests</a> to use :
<code>ruby
expect(response).to have_title('My page')
</code></p>

<p>To match meta tags, I had to resort to the following :
<code>ruby
meta_refresh_tags = Nokogiri::HTML(page.source).xpath("//meta[@http-equiv='refresh']")
expect(meta_refresh_tags).not_to(be_empty, 'could not find a meta refresh tag')
</code></p>

<p>I could do with something nicer, but it&rsquo;s ok for the moment.</p>
]]></content>
  </entry>
  
</feed>
