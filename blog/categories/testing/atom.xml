<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2017-11-10T06:39:27+01:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What Rails teaches us about building platforms and frameworks]]></title>
    <link href="http://philippe.bourgau.net/what-rails-teaches-us-about-building-platforms-and-frameworks/"/>
    <updated>2017-10-09T09:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/what-rails-teaches-us-about-building-platforms-and-frameworks</id>
    <content type="html"><![CDATA[<p>More than ever, the cheapest way to build a framework is to refactor it out of a specific app.</p>

<p><a href="http://rubyonrails.org/">Rails</a> is a web development server side framework built in <a href="https://www.ruby-lang.org/">Ruby</a>. It&rsquo;s been and remains very popular. It set the tone for all the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> web frameworks that followed. People have ported it to many other languages. Rails is now in it&rsquo;s 5th version, what is less known is how it was built in the first place.</p>

<p><img src="../imgs/2017-10-09-what-rails-teaches-us-about-building-platforms-and-frameworks/train-and-rails.jpg" alt="Drawing of a train being detached from its rails" /></p>

<h2>The story of Rails</h2>

<p><a href="http://david.heinemeierhansson.com/">David Heinemeier Hansson</a>, the creator of Rails, is a cult in the Ruby community. You can find the history of Rails at many places. If you have a bit of time, read <a href="https://www.wired.com/2008/02/mf-signals/?currentPage=all">this great article</a> from Wired. If you don&rsquo;t have a lot of time, here is a summary.</p>

<p><a href="https://twitter.com/jasonfried?lang=fr">Jason Fried</a> and DHH were working at <a href="https://37signals.com/">37signals</a>. They were working on project management app for small businesses called <a href="https://basecamp.com/">Basecamp</a>. After releasing the first version of Basecamp, DHH extracted and open sourced Rails out of it.</p>

<p>37signals later then re-used Rails to build other apps like Campfire, Highrise and Backpack.</p>

<p>We all know the end of the story, Rails adoption exploded. Many successful companies like <a href="https://github.com/">Github</a>, <a href="https://www.airbnb.com/">Airbnb</a>, <a href="https://twitter.com">Twitter</a> &amp; <a href="https://www.shopify.com">Shopify</a> have used it. It evolved a lot, through the darwinism of open source. Today, Rails might not be the latest and coolest web framework, but it is still very productive and popular.</p>

<p><img src="../imgs/2017-10-09-what-rails-teaches-us-about-building-platforms-and-frameworks/rails-logo.jpg" alt="The Rails logo" /></p>

<h2>Economic sense</h2>

<p>To summarize, here is how they did it :</p>

<ol>
<li>Built a specific app, and monetized it</li>
<li>Extracted an open source framework from it</li>
<li>Built other apps on the framework</li>
</ol>


<p>If you are not a programmers, you&rsquo;re likely to assume that the cost of reusing software is negligible. If you are a programmer, I&rsquo;ll ask you to assume that it is for a while. Â Under this hypothesis, all they did makes a lot of business sense :</p>

<ul>
<li>Building a specific app first is the fastest path to paying customers. Building a framework first would need more work.</li>
<li>Once you have paying customers, you&rsquo;ve got money to fuel further work.</li>
<li>In particular, you have money to finance the extraction of an open source framework.</li>
<li>Putting the framework open source increases its reusability through bug reports and contributions.</li>
<li>Building the next app is even easier thanks to a mature framework and the revenues from the original app</li>
</ul>


<blockquote><p>ðŸ’¡ Once you have paying customers, you&rsquo;ve got money to fuel further work.</p></blockquote>

<h2>How can it work ?</h2>

<p><a href="https://www.amazon.com/Rework-Jason-Fried/dp/0307463745/ref=sr_1_1?ie=UTF8&amp;qid=1507610064&amp;sr=8-1&amp;keywords=rework"><img src="../imgs/2017-10-09-what-rails-teaches-us-about-building-platforms-and-frameworks/rework-cover.jpg" alt="Cover of Rework book" /></a></p>

<p>Ok, enough for common sense. Let&rsquo;s see what happens when you take into account the real cost of changing software ? All software developers know that changing software is far from cheap. Very often, it&rsquo;s more expensive to adapt than to rebuild</p>

<p>So how did the Rails guys manage it ? Rails has 3 specificities that explain that :</p>

<ul>
<li>Rails has automated testing built in and out</li>
<li>Basecamp guys are agile with a lower &lsquo;a&rsquo;. They don&rsquo;t follow Scrum or any method. Read <a href="https://basecamp.com/about/books">their books</a> and you&rsquo;ll understand how agile they are. They follow principles like KISS, YAGNI, Lean startup discovery &hellip;</li>
<li>Finally, it was open sourced !</li>
</ul>


<p>Agile principles and technical practices is what allowed them to take the common-sense path.</p>

<blockquote><p>ðŸ’¡ Thanks to agile practices, the cheapest way to build a framework is to extract it from a specific app.</p></blockquote>

<h2>Open question</h2>

<p>If it is possible to do the thing that makes the most economic sense, why isn&rsquo;t it the default way ? Why are so many of us still losing a ton of money writing large frameworks and platforms up-front ? How could we get large companies to adopt the more nimble &lsquo;basecamp&rsquo; way ?</p>

<p><em>If you have remarks, answers or different point of views, I&rsquo;d love to read your comment !</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lessons learned from running our first improvement kata]]></title>
    <link href="http://philippe.bourgau.net/lessons-learned-from-running-our-first-improvement-kata/"/>
    <updated>2017-09-29T06:15:00+02:00</updated>
    <id>http://philippe.bourgau.net/lessons-learned-from-running-our-first-improvement-kata</id>
    <content type="html"><![CDATA[<p>During the past few weeks, I blogged the <a href="/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-1/">story of our first improvement kata</a>.</p>

<p>Doing this first <a href="http://www-personal.umich.edu/~mrother/The_Improvement_Kata.html">improvement kata</a> taught us many lessons. We re-discovered best practices of the software industry. We also learned more general things about the improvement kata itself.</p>

<p><img src="../imgs/2017-09-29-lessons-learned-from-running-our-first-improvement-kata/lessons.jpg" alt="Drawing of books" /></p>

<h2>Rediscovered best practices</h2>

<p>As we went through the kata, we &lsquo;proved&rsquo; many known best practices. We did not have to <em>believe</em> them, we had data explaining that they worked. For example :</p>

<ul>
<li><a href="https://twitter.com/hashtag/noestimates">#NoEstimate</a> works. Back in <a href="/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-3/">part 3</a> we saw that the story point and story count curves were very similar, almost identical</li>
<li><a href="https://www.infoq.com/articles/0-bugs-policy">#NoBug policy</a> was part of the solution to our problem</li>
<li>Doing more exploratory testing resulted in less bug fixing and increased our productivity. This proves principles like &ldquo;<a href="http://deming14points.com/quotes/build-quality-in/">Build quality in"</a> and <a href="https://en.wikiquote.org/wiki/Tom_DeMarco">&ldquo;Quality is free&rdquo;</a></li>
</ul>


<p>We also pushed the #NoBug policy further than it is usually done. We defined a clear definition for bugs that anyone could use. Doing so, we removed the product owner (or on-site customer) from the picture. Very often, the PO is the only one who can sort stories from bugs out. We created what <a href="http://reinertsenassociates.com/category/tips/">Donald Reinertsen</a> calls a distributed rule in the <a href="https://www.amazon.fr/Principles-Product-Development-Flow-Generation/dp/1935401009">flow book</a>. It increased empowerment, removes bottlenecks, while ensuring alignment.</p>

<p><a href="https://www.amazon.fr/Principles-Product-Development-Flow-Generation/dp/1935401009"><img src="../imgs/2017-09-29-lessons-learned-from-running-our-first-improvement-kata/flow-book-cover.jpg" alt="The 'Flow' book cover" /></a></p>

<h2>The improvement kata</h2>

<p>The first general lesson that we learned is that the improvement kata works !</p>

<p>At the beginning, we were very uneasy not to have perfect data. Remember how we had to resort to velocity as a proxy measure for productivity. In the end, that was not a severe problem. It still allowed us to understand what was going on.</p>

<p>We also learned that <a href="http://philippe.bourgau.net/blog/categories/retrospectives/">retrospective</a> is not the only road to continuous improvement. In fact, the improvement kata and retrospectives are very different :</p>

<ul>
<li>The time frame is different. A retrospective lasts for 1 or 2 hours and yield immediate results. An improvement kata is a background task that could take months in theory !</li>
<li>But the improvement kata also digs a lot deeper in the topic and brings true understanding. In our case, it fixed a problem that retrospectives where failing to address.</li>
<li>Ownership is also different. Retrospectives are a team activity. The improvement kata needs one or a few owners. It would be very difficult to align everyone on the same path of thoughts if we did it as a group activity.</li>
<li>Being a team activity, retrospectives have built-in alignment. The conclusions of the improvement kata must explained and agreed for a team to act on them. A good practice is to have regular (short) team meetings to share the current state of an improvement kata.</li>
<li>As the improvement kata is a more individual activity, it is more remote friendly. Team members can run the kata on their side, sharing everything through a wiki, or a blog for example.</li>
</ul>


<p>Keep in mind that this was our first try at the kata. Some of our difficulties might disappear with a bit of practice !</p>

<h2>What&rsquo;s next ?</h2>

<h3>Hybrid continuous improvement</h3>

<p>I clarified the differences between the improvement kata and retrospectives. That&rsquo;s not the end of it. I&rsquo;m sure a mixed format could be very interesting ! Start with a retrospective to collect the team&rsquo;s problems, and vote on the more important. Add a corresponding improvement kata task to the backlog. Someone would then handle this improvement task, sharing with the team along the way.</p>

<p>This might be a great opportunity to reduce meeting time with shorter retrospectives.</p>

<blockquote><p>ðŸ’¡ Reduce meeting time with mixed retrospective &amp; improvement kata</p></blockquote>

<h3>Data science for software</h3>

<p>Going through this improvement kata made me realize something else. It is very difficult to get quality data to investigate. We had to resort to what was available all the way.</p>

<p>What&rsquo;s striking is that we use software tool for all our work ! These tools have logs and could record usage data somewhere. Imagine all we could learn by mining all this data ! Our IDEs, CI servers, quality monitors, test tools, version control and project management tools should store everything we do at the same place !</p>

<p>With all this data, could we improve our estimations ? Could we find creative ways to be more productive ? Could we estimate the speed up that fixing some technical debt would bring ?</p>

<blockquote><p>ðŸ’¡ What are we waiting to apply data science to the development process ?</p></blockquote>

<p>As the saying goes, &ldquo;The cobbler&rsquo;s children go barefoot&rdquo;. We are building such systems for others, but not for ourselves.</p>

<p>Hopefully, new tools like <a href="https://codescene.io/">CodeScene</a> are emerging to fill this gap. You can learn more about CodeScene on their <a href="https://codescene.io/">website</a>, or from the <a href="https://www.amazon.com/Your-Code-Crime-Scene-Bottlenecks/dp/1680500384">founder&rsquo;s book</a>. It analyses the version control history to find hot spots and other things in your code.</p>

<p><a href="https://www.amazon.com/Your-Code-Crime-Scene-Bottlenecks/dp/1680500384"><img src="../imgs/2017-09-29-lessons-learned-from-running-our-first-improvement-kata/code-as-crime-scene.jpg" alt="The 'Code as a Crime Scene' book cover" /></a></p>

<p>While we keep dreaming of such tool, I&rsquo;ll continue to blog. Next week, I will write a short guide of <a href="/how-to-run-your-first-improvement-kata/">how to run your first improvement kata</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How we used the improvement kata to gain 25% of productivity - Part 5]]></title>
    <link href="http://philippe.bourgau.net/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5/"/>
    <updated>2017-09-27T07:00:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5</id>
    <content type="html"><![CDATA[<p>This is the fifth (and last) post of a <a href="/blog/categories/first-improvement-kata-series/">series of 5</a> about the improvement kata. If you haven&rsquo;t read the beginning of the story, I recommend you start from <a href="/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-1/">part 1</a>.</p>

<p>In the <a href="/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-4/">previous post</a>, we decided to adjust our definition of a bug to limit the time lost on nice-to-have bug fixes.</p>

<p>It would take a while to know if adjusting the definition of a bug would help us or not. At the same time, we knew it would not help us to reduce the number of bugs we escaped to other teams.</p>

<p><img src="../imgs/2017-09-27-how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5/success-banner.jpg" alt="A 'SUCCESS' banner in the wind" /></p>

<h2>Idea 3 : More exploratory testing</h2>

<p>We decided to push on this matter as well. This means that we would be running two <a href="https://en.wikipedia.org/wiki/PDCA">PDCAs (Plan-Do-Check-Act)</a> at the same time. This is not the improvement kata procedure by the book. That could have been an error from our side, as first time users of the kata. Or maybe it&rsquo;s a pragmatic habit to adapt the kata to real life &hellip; I guess we&rsquo;ll know better as we apply the kata more often. The danger is that the different experiments can conflict with each other. When measuring the results, it becomes difficult to link observations with experiments. Anyway, back to our own situation, as you&rsquo;ll see, it ended up well for us.</p>

<p>The first thing was to know a bit more about our bugs. Checking the recently closed bugs yielded suspicions about a recent features. Analyzing further proved our gut feeling.</p>

<h6>Curve of how bugs were fixed on the last 2 months</h6>

<p><img src="../imgs/2017-09-27-how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5/fixed-bugs.png" alt="Curve of how bugs were fixed on last 2 months" /></p>

<h6>Curve of the origin of bugs on the last 2 months</h6>

<p><img src="../imgs/2017-09-27-how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5/kind-of-bugs.png" alt="Curve of the origin of bugs on the last 2 months" /></p>

<p>Ignoring the Christmas drop at the middle of the curve, we concluded 2 things from these graphs :</p>

<ul>
<li>We were leaking bugs to the product</li>
<li>Bugs mostly came from newly added features</li>
</ul>


<blockquote><p>Despite all our automated tests and regular Â exploratory testing, we were leaking bugs.</p></blockquote>

<p>We decided to do more exploratory testing for a while ! We were already doing exploratory testing at the end of every story. We added an extra 1 hour team session of exploratory testing every sprint.</p>

<h2>Do, Check &amp; Act</h2>

<p>We used these new conventions for a few weeks. We did more exploratory testing, and would be more strict about what a bug was. We stuck to our prioritization : first improvements, then bugs and only after, stories.</p>

<p>After a few weeks of that, we were able to update our bug trend and do a linear regression on it again. Here were the results :</p>

<p><img src="../imgs/2017-09-27-how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5/final-bug-trend.png" alt="Curve of the origin of bugs on the last 2 months" /></p>

<p>Hurray ! As you can see, we were to be done with bugs around April 2017, which was 3 months away at that time.</p>

<blockquote><p>ðŸ’¡ Quality is free, but only for those willing to pay for it ! [<a href="https://en.wikiquote.org/wiki/Tom_DeMarco">Tom DeMarco</a> in <a href="https://www.amazon.com/Peopleware-Productive-Projects-Teams-3rd/dp/0321934113/ref=pd_lpo_sbs_14_t_0?_encoding=UTF8&amp;psc=1&amp;refRID=9SX9Y3RG61NB7N9VJ6KS&amp;dpID=61lAwzXfQiL&amp;preST=_SX218_BO1,204,203,200_QL40_&amp;dpSrc=detail">Peopleware</a>]</p></blockquote>

<p><a href="https://www.amazon.com/Peopleware-Productive-Projects-Teams-3rd/dp/0321934113/ref=pd_lpo_sbs_14_t_0?_encoding=UTF8&amp;psc=1&amp;refRID=9SX9Y3RG61NB7N9VJ6KS&amp;dpID=61lAwzXfQiL&amp;preST=_SX218_BO1,204,203,200_QL40_&amp;dpSrc=detail"><img src="../imgs/2017-09-27-how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-5/peopleware.jpg" alt="Cover of the 'Peopleware' book by Tom DeMarco &amp; Timothy Lister" /></a></p>

<p>We confidently adopted these practices as part of our working agreements. This brought our first improvement kata to its end.</p>

<blockquote><p>ðŸ’¡ The improvement kata not only brings improvements, it also teaches you why they work.</p></blockquote>

<h2>3 months later</h2>

<p>As you know, April 2017 is long gone. I can now give you a more up to date report of the actual effects on the team&rsquo;s daily work.Â </p>

<p>First, the backlog does not contain bugs anymore. We payed the bug debt back. Second, we still discover some bugs from time to time, but a lot less than we used to. To summarize, there is now a pair of developers (25%) of the team that can work on user stories instead of fixing bugs.</p>

<p>As we are still fixing bugs as they appear, the 25% productivity gain claim might be an overstatement, but 20% is not. At the same time, less bugs are now escaping. This means that the whole organization is saving on interruptions and rework. 25% might not be such a bold claim after all !</p>

<h2>This is it !</h2>

<p>This was post 5 in a <a href="/blog/categories/first-improvement-kata-series/">series of 5</a> about the improvement kata. I&rsquo;m not completely done writing about this improvement kata though. In the coming weeks, I&rsquo;ll post about the <a href="/lessons-learned-from-running-our-first-improvement-kata/">lessons learned</a> and <a href="/how-to-run-your-first-improvement-kata/">how to start your own improvement kata</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forget unit tests, only fast tests matter]]></title>
    <link href="http://philippe.bourgau.net/forget-unit-tests/"/>
    <updated>2017-08-08T06:24:00+02:00</updated>
    <id>http://philippe.bourgau.net/forget-unit-tests</id>
    <content type="html"><![CDATA[<p>Don&rsquo;t worry if your unit tests go to the DB, that might not be so bad.</p>

<p>When I started writing unit tests, I did not know what these were. I read <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=126923">the definition</a>, and strived to follow the recommandations :</p>

<ul>
<li>they should be independent from each other</li>
<li>they should not access the DB</li>
<li>they should not use the network</li>
<li>they should only cover a small scope of your code</li>
</ul>


<p>I started to write unit tests on my own and became <a href="http://wiki.c2.com/?TestInfected">test infected</a> pretty fast. Once I got convinced of the benefits of unit testing, I tried to spread the practice around me. I used to explain to people that it is very important to write real unit tests by the book. Otherwise, <em>Bad Things</em> would happen &hellip;</p>

<h2>How I changed my mind</h2>

<p>A few years ago, I spent a few years working on a <a href="http://rubyonrails.org/">Rails</a> side project called <a href="https://github.com/philou/mes-courses">mes-courses.fr</a>. I was using a small test gem to enforce that no unit tests were accessing the db. I had to write a lot of mocks around the code. I ended up hating mocks : they are too painful to maintain and provide a false sense of security. I&rsquo;m not alone in this camp, check <a href="https://www.youtube.com/watch?v=9LfmrkyP81M">DHH&rsquo;s keynote at RailsConf 2014</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/9LfmrkyP81M" frameborder="0" allowfullscreen></iframe>


<p>At some point, the mock pain got so bad that I stopped all developments until I found another way. I found a pretty simple workaround : use in-memory SQLite. I got rid of all the DB access mocks. Not only were the tests easier to write and maintain, but they were as fast as before, and they covered more code.</p>

<p>That changed something fundamental in my understanding of testing</p>

<h2>It&rsquo;s all about speed baby</h2>

<p>The only thing that makes unit tests so important is that they run fast.</p>

<p>Unit tests as described in the literature run fast. Let&rsquo;s see what happens when you remove one of the recommandations for unit tests.</p>

<ul>
<li>If tests depend on each other, their outcome will change with the execution order. This wastes our time in analyzing the results. On top of that, independent unit tests are easy to run in parallel, providing an extra speedup. We lose this potential when our tests are dependent.</li>
<li>Tests that rely on an out-of-process DB run slower. Tests need to start the DB before anything else. Data needs to be setup and cleaned at every test. Accessing the DB implies using the network, which takes time as well. There&rsquo;s also a risk of making the tests dependent by sharing the same DB. A last issue is troubleshooting the DB process when things don&rsquo;t work.</li>
<li>Tests that use the network are slow too ! First, Network is slower than memory. Second, data serialization between processes is slow as well. Finally, these tests are likely to use some form of sleep or polling, which is slow, fragile, or both !</li>
<li>Finally, there is always a scope past which a test will be too slow.</li>
</ul>


<p>This means that not only unit tests are fast, but also that fast tests usually show the features of unit tests.</p>

<p>My guess is that &lsquo;unit tests&rsquo; were explicitly defined as a recipe for fast tests ! If you stick to the definition of unit tests, you&rsquo;ll get fast tests and all their benefits.</p>

<p><img src="../imgs/2017-08-08-forget-unit-tests/speedometer.jpg" alt="A speedometer" /></p>

<h2>Fast tests</h2>

<p>That also means that we should focus first on having fast tests rather than unit tests. Here is my real check to know if tests are fast enough :</p>

<ul>
<li>Is the build (and the tests and everything) less than 10 minutes ?</li>
<li>Can I continuously run my tests while coding and stay in the flow ?</li>
</ul>


<p>If both answers are yes, then I won&rsquo;t question myself too much whether my tests are unit, integration or end to end.</p>

<h2>So what ?</h2>

<p>I&rsquo;ve been experimenting with these heuristics for some time. Side projects are great for experimenting since you don&rsquo;t have a team to convince ! Here are my main takeaways :</p>

<ul>
<li>Stick to end to end tests at the beginning of your project. They are easy to refactor to finer grained tests later on.</li>
<li>In-memory DBs are great to speed tests up without wasting your time with mocking.  We can use a unique DB for every test to keep them independent.</li>
<li>Large scope tests are not an issue provided 2 things.

<ol>
<li>The code contains very few side effects.</li>
<li>It provides good exceptions and assertions messages</li>
</ol>
</li>
</ul>


<p>On the other side, there are things that I still recommend :</p>

<ul>
<li>Independent tests are easy to write from the beginning, difficult to fix later on. As they save a lot of headaches in diagnostic, I stick to them from the start.</li>
<li>Avoid network, it makes the tests slow, fragile and tricky to diagnostic. But please, read <a href="http://philippe.bourgau.net/how-not-to-use-mocks-my-talk-at-paris-rb/">this</a> before jumping to mocks.</li>
</ul>


<p>These rules have served me well, particularly in my side projects, where I don&rsquo;t have a lot of time. What about you ? Do you have your own testing rules ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't stick to TDD's Red-Green-Refactor loop to the letter]]></title>
    <link href="http://philippe.bourgau.net/dont-stick-to-tdds-red-green-refactor-loop-to-the-letter/"/>
    <updated>2017-06-28T15:52:00+02:00</updated>
    <id>http://philippe.bourgau.net/dont-stick-to-tdds-red-green-refactor-loop-to-the-letter</id>
    <content type="html"><![CDATA[<p>As long as you are writing your tests before your code and doing regular refactoring, you are doing <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> !</p>

<p>The Red &ndash; Green &ndash; Refactor loop is useful to introduce TDD to new developers. Different loops can be more effective in real world situation.</p>

<p>The Red &ndash; Green &ndash; Refactor loop is not a dogma !</p>

<p><a href="http://www.natpryce.com/"><img src="../imgs/2017-06-28-dont-stick-to-tdds-red-green-refactor-loop-to-the-letter/red-green-refactor.jpg" alt="The famous red, green, refactor TDD loop" /></a></p>

<h2>Refactor &ndash; Red &ndash; Green</h2>

<p>When I work on a story, I very often keep a TODO list next to my desk. I use it to keep track of the next steps, the edge cases to test, the code smells and refactorings to do.</p>

<p>When I get to the end of the story, all that remains of this list is a few refactorings. Very often, I don&rsquo;t do them !</p>

<p>With the feature working, doing these refactorings feels like violation of <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>. Next time we&rsquo;ll have to work on this part of the code, we&rsquo;ll have a story to serve as guide to which refactorings to do.</p>

<p>The same thing is effective at the unit test scale. It&rsquo;s easier to refactor when you know the test you want to add. Refactor to make this test easy to write !</p>

<p>Here is an example with <a href="https://en.wikipedia.org/wiki/Fizz_buzz">Fizz Buzz</a></p>

<p>```java
static int fizzBuzz(int number) {
Â Â Â return number;
}</p>

<p>@Test public void
it_is_1_for_1() {
Â Â Â assertThat(fizzBuzz(1)).isEqualTo(1);
}</p>

<p>@Test public void
it_is_2_for_2() {
Â Â Â assertThat(fizzBuzz(2)).isEqualTo(2);
}
```</p>

<p>Here is the test I&rsquo;d like to add.Â </p>

<p><code>java
@Test public void
it_is_Fizz_for_3() {
Â Â Â assertThat(fizzBuzz(3)).isEqualTo("Fizz");
}
</code></p>

<p>Unfortunately, fizzBuzz needs to return a String instead of an integer for it to compile. That&rsquo;s when I would refactor before adding the new test.</p>

<p>```java
static String fizzBuzz(int number) {
Â Â Â return Integer.toString(number);
}</p>

<p>@Test public void
it_is_1_for_1() {
Â Â Â assertThat(fizzBuzz(1)).isEqualTo(&ldquo;1&rdquo;);
}</p>

<p>@Test public void
it_is_2_for_2() {
Â Â Â assertThat(fizzBuzz(2)).isEqualTo(&ldquo;2&rdquo;);
}
```</p>

<p>In the end, this loop is very like the classic TDD loop :</p>

<p><code>
red-green-refactor-red-green-refactor-red-green-refactor.............
..........refactor-red-green-refactor-red-green-refactor-red-green...
</code></p>

<p>A bit more YAGNI, that&rsquo;s all.</p>

<h2>Red &ndash; Better Red &ndash; Green &ndash; Refactor</h2>

<p>A few weeks ago, <a href="/speed-up-the-tdd-feedback-loop-with-better-assertion-messages/">I wrote about error messages in unit tests</a>. To summarize, extra work on error messages reduces the testing feedback loop.</p>

<p>We can translate this focus on error messages into an extra TDD step. Whatever the TDD loop you are using, you can add this step after the Red step.</p>

<h2><del>Red</del> &ndash; Green &ndash; Refactor &ndash; Red &ndash; Green</h2>

<p>Sometimes, it makes sense to refactor before fixing the test. The idea is to rely on the existing tests to prepare the code to fix the new test in one line.</p>

<p>Let&rsquo;s take our Fizz Buzz example again. Imagine we finished the kata, when we decide to tweak the rules and try Fizz Buzz Bang. We should now print Bang on multiples of 7.</p>

<p>Here is our starting point :</p>

<p>```java
static String fizzBuzz(int number) {
Â Â Â if (multipleOf(number, 3)) {
Â Â Â Â Â Â return &ldquo;Fizz&rdquo;;
Â Â Â }
Â Â Â if (multipleOf(number, 5)) {
Â Â Â Â Â Â return &ldquo;Buzz&rdquo;;
Â Â Â }
Â Â Â if (multipleOf(number, 3*5)) {
Â Â Â Â Â Â return &ldquo;FizzBuzz&rdquo;;
Â Â Â } Â Â 
Â Â Â return Integer.toString(number);
}</p>

<p>&hellip;</p>

<p>@Test public void
it_is_Bang_for_7() {
Â Â Â assertThat(fizzBuzz(7)).isEqualTo(&ldquo;Bang&rdquo;);
}
```</p>

<p>I could go through all the hoops, 7, 14, then 3<em>7, 5</em>7 and finally 3<em>5</em>7 &hellip; By now, I should know the music though !</p>

<p>What I would do in this case is :</p>

<ul>
<li>first to comment the new failing test to get back to green</li>
<li>refactor the code to prepare for the new code</li>
<li>uncomment the failing test</li>
<li>fix it</li>
</ul>


<p>In our example, here is the refactoring I would do</p>

<p>```java
static String fizzBuzz(int number) {
Â Â Â String result = &ldquo;&rdquo;;
Â Â Â result += multipleWord(number, 3, &ldquo;Fizz&rdquo;);
Â Â Â result += multipleWord(number, 5, &ldquo;Buzz&rdquo;);
Â Â Â if (result.isEmpty()) {
Â Â Â Â Â Â result = Integer.toString(number);
Â Â Â }
Â Â Â return result;
}</p>

<p>private static String multipleWord(int number, int multiple, String word) {
Â Â Â if (multipleOf(number, multiple)) {
Â Â Â Â Â Â return word;
Â Â Â }
Â Â Â return &ldquo;&rdquo;;
}</p>

<p>&hellip;</p>

<p>//@Test public void
//it_is_Bang_for_7() {
// Â Â assertThat(fizzBuzz(7)).isEqualTo(&ldquo;Bang&rdquo;);
//}
```</p>

<p>From there, fixing the test is dead simple.</p>

<p>In practice I find this loop very useful. At local scale as we saw but it&rsquo;s also a great way to refactor your architecture at larger scale.</p>

<p>One downsize is that if you are not careful, it might lead to over-engineering. Be warned, keep an eye on that !</p>

<p>Last caveat : not all TDD interviewers like this technique &hellip;</p>

<h2>Don&rsquo;t obsess</h2>

<p>It&rsquo;s not because you are not following the Red Green Refactor loop to the letter that you are not doing TDD.</p>

<p>An interesting point is that these variations to the TDD loop are combinable ! Experienced TDD practitioners can jump from one to the other without even noticing.</p>

<p><a href="https://blog.acolyer.org/2017/06/13/a-dissection-of-the-test-driven-development-process-does-it-really-matter-to-test-first-or-test-last/">This paper</a> argues that as long as you write the tests along (before or after) the code, you get the same benefit. That&rsquo;s not going to make me stop writing my tests first, but it is interesting. That would mean that even a Code &ndash; Test &ndash; Refactor loop would be ok if it is fast enough !</p>
]]></content>
  </entry>
  
</feed>
