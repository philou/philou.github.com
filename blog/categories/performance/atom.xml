<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: performance | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/performance/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2015-04-07T05:18:18+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What Optimization Should We Work On (Lean Software Development Part 5)]]></title>
    <link href="http://philippe.bourgau.net/what-optimization-should-we-work-on-lean-software-development-part-5/"/>
    <updated>2015-03-26T20:30:00+00:00</updated>
    <id>http://philippe.bourgau.net/what-optimization-should-we-work-on-lean-software-development-part-5</id>
    <content type="html"><![CDATA[<p>At work, we are building a risk aggregation system. As it&rsquo;s dealing with a large bunch of numbers, it&rsquo;s a huge heap of optimizations. Once that its most standard features set is supported, our job mostly consists of making it faster.</p>

<p>That&rsquo;s were we are now doing.</p>

<p>{% img center /imgs/2015-03-26-what-optimization-should-we-work-on-lean-software-development-part-5/turtle.jpg A turtle with a rocket on the back %}</p>

<h1>How do we choose which optimization to work on ?</h1>

<p>The system still being young, we have a wide range of options to optimize it. To name just a few : caches, better algorithms, better low level hardware usage &hellip;</p>

<p>It turns out that we can use the speedup factor as a substitute for business value and use known techniques to help us to make the best decisions.</p>

<h2>Let&rsquo;s walk through an example</h2>

<h3>I. List the optimizations you are thinking of</h3>

<p>Let&rsquo;s suppose we are thinking of the following 3 optimizations for our engine</p>

<ul>
<li>Create better data structures to speed up the reconciliation algorithm</li>
<li>Optimize the reconciliation algorithm itself to reduce CPU cache misses</li>
<li>Minimize boxing and unboxing</li>
</ul>


<h3>II. Poker estimate the story points and speedup</h3>

<p>Armed with these stories, we can poker estimate them, by story points and by expected speedup.
As a substitute for WSJF, we will then be able to compute the speedup rate per story point.
We will then just have to work on the stories with the highest speedup rate first.</p>

<table>
<thead>
<tr>
<th>Title                   </th>
<th> Story Points  </th>
<th> /10    </th>
<th> /2     </th>
<th> -10%    </th>
<th> ~  </th>
<th> +10%   </th>
<th> x2      </th>
<th> x10     </th>
<th> Expected Speedup ratio* </th>
<th> Speedup rate / story point**</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structures     </td>
<td> 13        </td>
<td>        </td>
<td>        </td>
<td>             </td>
<td>        </td>
<td> 4 votes</td>
<td> 5 votes </td>
<td>         </td>
<td> x 1.533                 </td>
<td> x 1.033</td>
</tr>
<tr>
<td>Algorithm           </td>
<td> 13        </td>
<td>    </td>
<td> 1 vote </td>
<td> 1 vote      </td>
<td> 2 votes</td>
<td> 1 vote </td>
<td> 2 votes </td>
<td> 2 votes </td>
<td> x 1.799                 </td>
<td> x 1.046</td>
</tr>
<tr>
<td>Boxing                  </td>
<td> 8     </td>
<td>    </td>
<td>        </td>
<td>             </td>
<td>        </td>
<td> 9 votes</td>
<td>         </td>
<td>         </td>
<td> x 1.1                   </td>
<td> x 1.012</td>
</tr>
</tbody>
</table>


<p><sup><em>* Expected speedup ratio is the logarithmic average of the voted speedups</em></sup><br>
<sup><em>** Speedup rate is &ldquo;speedup<sup>(1/ story points)</sup>&rdquo;</em></sup></p>

<p>So based on speedup rate, here is the order in which we should perform the stories :</p>

<ol>
<li>Algorithm</li>
<li>Data Structures</li>
<li>Boxing</li>
</ol>


<h3>III. And what about the risks ?</h3>

<p>{% img center /imgs/2015-03-26-what-optimization-should-we-work-on-lean-software-development-part-5/danger.jpg A danger zone panel %}</p>

<p>This poker estimation tells us something else &hellip;</p>

<blockquote><p>We don&rsquo;t have a clue about the speedup we will get by trying to optimize the algorithm !</p></blockquote>

<p>The votes range from /2 to x10 ! This is the perfect situation for an XP spike.</p>

<table>
<thead>
<tr>
<th>Title </th>
<th> Story points </th>
<th> Expected Speedup rate</th>
</tr>
</thead>
<tbody>
<tr>
<td>Algorithm spike : measure out of context CPU cache optimization speedup </td>
<td> 2 </td>
<td>   ?</td>
</tr>
</tbody>
</table>


<br>


<p>In order to compute the expected speedup rate, let&rsquo;s suppose that they are 2 futures, one where we get a high speedup and another where we get a low one.</p>

<p>They are computed by splitting the votes in 2 :</p>

<ul>
<li><em>low_speedup = 0.846</em></li>
<li><em>high_speedup = 3.827</em></li>
</ul>


<h4>If the spike succeeds</h4>

<p>We&rsquo;ll first work on the spike, and then on the algorithm story. In the end, we would get the speedup of the algorithm optimization.</p>

<ul>
<li><em>spike_high_speedup = high_speedup = 3.827</em></li>
</ul>


<h4>If the spike fails</h4>

<p>We&rsquo;ll also start by working on the spike. Afterwards, instead of the algorithm story, we&rsquo;ll tackle another optimization stories, yielding our average speedup rate for the duration of the algorithm story. The average speedup rate can be obtained from historical benchmark data, or by averaging the speedup rate of the other stories.</p>

<ul>
<li><em>average_speedup_rate = (1.033 * 1.011)<sup>&frac12;</sup> = 1.022</em></li>
<li><em>spike_low_speedup = average_speedup_rate<sup>story_points</sup> = 1.02213 = 1.326</em></li>
</ul>


<h4>Spike speedup rate</h4>

<p>We can now compute the average expected speedup rate for the full period &lsquo;spike &amp; algorithm&rsquo; stories. From this we will be able to get the speedup rate and finally, to prioritize this spike against the other stories in our backlog.</p>

<ul>
<li><em>spike_speedup = (spike_low_speedup * spike_high_speedup)<sup>&frac12;</sup> = 2.253</em></li>
<li><em>spike_speedup_rate = spike_speedup<sup>1/(spike_story_points + algorithm_story_points)</sup> = 2.253<sup>1/(2 + 13)</sup> = 1.056</em></li>
</ul>


<h3>IV. Putting it all together</h3>

<p>Here are all the speedup rate for the different stories.</p>

<table>
<thead>
<tr>
<th>Title </th>
<th> Speedup rate / story point</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structure  </td>
<td> x 1.033</td>
</tr>
<tr>
<td>Algorithm           </td>
<td> x 1.046</td>
</tr>
<tr>
<td>Boxing                  </td>
<td> x 1.012</td>
</tr>
<tr>
<td>Algorithm spike         </td>
<td> x 1.056</td>
</tr>
</tbody>
</table>


<br>


<p>Finally, here is the optimal order through which we should perform the stories :</p>

<ul>
<li>Algorithm spike</li>
<li>Algorithm (only if the spike proved it would work)</li>
<li>Data Structures</li>
<li>Boxing</li>
</ul>


<h2>Summary</h2>

<p>The math are not that complex, and a simple formula can be written to compute the spike speedup rate :</p>

<p>{% img center /imgs/2015-03-26-what-optimization-should-we-work-on-lean-software-development-part-5/poc_speedup_rate.png Formula for a spike speedup rate %}</p>

<p>I think most experienced engineers would have come to the same conclusion by gut feeling &hellip;</p>

<p>Nevertheless I believe that systematically applying the such method when prioritizing optimizations can lead to a greater speedup rate than the competition in the long run. This is a perfect example where taking measured risks can payoff !</p>

<p>This was part 5 of my <a href="/the-flow-book-summary-lean-software-development_part_1/">Lean Software Development Series</a>. Part 4 was <a href="/measure-the-business-value-of-your-spikes-and-take-high-payoff-risks-lean-software-development-part-4/">Measure the business value of your spikes and take high payoff risks</a>, Part 5 will be &ldquo;Measure the value of the lean startup &lsquo;learning&rsquo;&rdquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Performance is a feature]]></title>
    <link href="http://philippe.bourgau.net/performance-is-a-feature/"/>
    <updated>2015-01-19T06:46:00+00:00</updated>
    <id>http://philippe.bourgau.net/performance-is-a-feature</id>
    <content type="html"><![CDATA[<p>Now that is a widespread title for blog articles ! Just <a href="https://www.google.fr/search?sourceid=chrome-psyapi2&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;q=performance%20is%20a%20feature">search Google</a>, and you&rsquo;ll find &ldquo;Performance is a feature&rdquo; in <a href="http://blog.codinghorror.com/performance-is-a-feature/">Coding Horror</a> and <a href="http://coffeeonthekeyboard.com/performance-is-a-feature-623/">others</a>.</p>

<p><a href="http://www.motorstown.com/50701-dragster-jet.html">{% img center /imgs/2015-01-19-performance-is-a-feature/dragster.jpg A Dragster at full speed %}</a></p>

<h1>What&rsquo;s in it for us ?</h1>

<p>If performance is indead a feature, then it can be managed like any feature :</p>

<ul>
<li><p>It should result from use cases</p>

<blockquote><p>During use case X, the user should not wait more than Y seconds for Z</p></blockquote></li>
<li><p>It can be split into user stories</p></li>
</ul>


<blockquote><ul>
<li>Story 1: During use case X, the user should not wait more than 2*Y seconds for Z</li>
<li>Story 2: During use case X, the user should not wait more than Y seconds for Z</li>
</ul>
</blockquote>

<ul>
<li>They can be prioritized against other stories</li>
</ul>


<blockquote><ul>
<li>Let&rsquo;s forget about performance for now and deliver functionality A as soon as ready, we&rsquo;ll speed things up later.</li>
<li>Let&rsquo;s fix basic performance constraints for use case X for now, every story will have to comply with these constraints later.</li>
</ul>
</blockquote>

<ul>
<li>The performance on these use cases should be automatically tested and non regressed</li>
</ul>


<blockquote><ul>
<li>If we slow things too much and these tests breaks, we&rsquo;ll have to optimize the code.</li>
<li>But as long as we don&rsquo;t break the tests, it&rsquo;s ok to unoptimize the code !</li>
</ul>
</blockquote>

<p>Maybe that&rsquo;s a chance to stop performance related gut feeling quarrels !</p>
]]></content>
  </entry>
  
</feed>
