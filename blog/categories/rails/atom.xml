<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2016-10-26T08:15:33+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Continuously Deliver a Rails App to your DigitalOcean Box using Docker]]></title>
    <link href="http://philippe.bourgau.net/continuously-deliver-a-rails-app-to-your-digital-ocean-box-using-docker/"/>
    <updated>2016-10-25T20:39:00+00:00</updated>
    <id>http://philippe.bourgau.net/continuously-deliver-a-rails-app-to-your-digital-ocean-box-using-docker</id>
    <content type="html"><![CDATA[<p>I decided to use <a href="https://github.com/philou/planning-poker">my latest side project</a> as an occasion to learn <a href="https://www.docker.com/">Docker</a>. I first used <a href="https://www.heroku.com/">Heroku</a> as a platform for deployment (see <a href="/how-to-boot-a-new-rails-project-with-docker-and-heroku/">previous post</a>). It works fine but I discovered the following shortcomings :</p>

<ul>
<li>Heroku does not deploy with Docker, which means that I&rsquo;d get quite different configurations between dev and prod, which is one of the promises of Docker :(</li>
<li>The dockerfile provided by docker runs bundle install in a directory outside of the docker main shared volume, this forces to do bundle update twice (once to update Gemfile.lock and a second time to update the actual gems &hellip;)</li>
</ul>


<p>None of these issues could be fixed without moving away from Heroku.</p>

<h2>A great Tutorial / Guide</h2>

<p>I followed <a href="http://chrisstump.online/">Chris Stump</a>&rsquo;s great tutorials to <a href="http://chrisstump.online/2016/02/20/docker-existing-rails-application/">setup Docker for my app</a>, to <a href="http://chrisstump.online/2016/03/03/continuous-integration-docker-rails/">continuously integrate</a> on <a href="https://circleci.com/">CircleCI</a> and to <a href="http://chrisstump.online/2016/03/17/continuous-deployment-docker-rails/">continuously deploy</a> on a private virtual server on <a href="https://www.digitalocean.com/">DigitalOcean</a>.</p>

<p>The first 2 steps (Docker &amp; CI) worked really out of the box after following the tutorial. Dealing with step 3 (CD) was a bit more complicated, because of :</p>

<ol>
<li>the specificities of DigitalOcean</li>
<li>the fact that I&rsquo;m a no deployment expert &hellip;</li>
</ol>


<p><img class="center" src="/imgs/2016-10-25-continuously-deliver-a-rails-app-to-your-digital-ocean-box-using-docker/docker-circleci-digitalocean.jpg" title="The logos of Docker, CircleCI and DigitalOcean" ></p>

<h2>What did I need to do to make it work</h2>

<h3>Setup SSH on the DigitalOcean box</h3>

<p>I started by creating a <a href="https://cloud.digitalocean.com/droplets/new?size=2gb&amp;region=nyc3&amp;appId=20423249&amp;type=applications">one-click DigitalOcean box</a> with Docker pre-installed. That&rsquo;s the moment where I had to setup SSH in order to make CircleCI deploy to my box. DigitalOcean has a <a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets">guide for this</a>, but here is how id did it :</p>

<ol>
<li>Create a special user on my dev machine <code>adduser digitaloceanssh</code></li>
<li>Log as this user <code>su digitaloceanssh</code>, and generated ssh keys for it <code>ssh-keygen</code></li>
<li>Print the public key <code>cat ~/.ssh/id_rsa.pub</code> and copy paste it in your DigitalOcean box setup</li>
<li>Print the private key <code>cat ~/.ssh/id_rsa</code> and copy past it in your circle-ci job ssh keys</li>
</ol>


<p>The benefit of this is that you should now be able to ssh in your DigitalOcean box from your digitaloceanssh user <code>ssh root@&lt;ip.to.digital.ocean&gt;</code></p>

<h3>Optional : update the box</h3>

<p>The first time I logged into my box, I noted that packages were out of date. If you need it, updating the packages is a simple matter of <code>apt-get update &amp;&amp; apt-get upgrade</code></p>

<h3>Fix deployment directory</h3>

<p>By default, the home dir of the root user on the DigitalOcean box is <code>/root/</code>. Unfortunately, Chris Stump&rsquo;s tutorial assumes it to be <code>/home/root/</code>. In order to fix that, I ssh-ed in the box and created a symbolic link : <code>ln -s /root /home/root</code>.</p>

<h3>Install docker-compose on the box</h3>

<p>Chris Stump&rsquo;s tutorial expects docker-compose on the deployment box, but DigitalOcean only installs Docker on its boxes &hellip; Install instructions for docker-compose can be found <a href="https://docs.docker.com/compose/install/">here</a>. Don&rsquo;t use the container option, it does not inherit environment variables, and will fail the deployment, just use the first curl based alternative.</p>

<h3>Warning : replace ALL dockerexample</h3>

<p>This comes as an evidence, but be sure to replace all the references to &lsquo;dockerexample&rsquo; to your own app name in all of Chris Stump&rsquo;s templates (I forgot some and lost a few rebuilds for that)</p>

<h3>Create the production DB</h3>

<p>Chris Stump&rsquo;s deployment script works with an existing production DB. The first migration will fail. To fix this, just do the following :</p>

<ol>
<li>ssh into the DigitalOcean server</li>
<li>run <code>DEPLOY_TAG=&lt;latest_deploy_tag&gt; RAILS_ENV=production docker-compose -f docker-compose.production.yml run app bundle exec rake db:create</code></li>
</ol>


<p>You can find the latest DEPLOY_TAG from the CircleCi step <code>bundle exec rake docker:deploy</code></p>

<h3>How to access the logs</h3>

<p>It might come handy to check the logs of your production server ! Here is how to do this :</p>

<ol>
<li>ssh in your production server</li>
<li>run the following to tail on the logs <code>DEPLOY_TAG=`cat deploy.tag` RAILS_ENV=production docker-compose -f docker-compose.production.yml run app tail -f log/production.log</code></li>
</ol>


<p>Obviously, tail is just an example, use anything else at your convenience.</p>

<h3>Generate a secret token</h3>

<p>Eventually, the build and deployment job succeeded &hellip; I had still one last error when I tried to access the web site : <code>An unhandled lowlevel error occurred. The application logs may have details.</code>. After some googling, I understood that this error occurs when you did not set a secret key base for your rails app (<a href="http://stackoverflow.com/questions/37112804/an-unhandled-lowlevel-error-occurred-the-application-logs-may-have-details">details</a>). There is a <a href="http://www.jamesbadger.ca/2012/12/18/generate-new-secret-token/">rails task to generate a token</a>, all that was needed was to create a .env file on the server with the following :</p>

<p><code>SECRET_KEY_BASE=&lt;GENERATED_SECRET...&gt;</code></p>

<h2>What&rsquo;s next ?</h2>

<p>Obviously, I learned quite a lot with this Docker exploration. I am still in the discovery phase, but my planning poker side project is now continuously built on <a href="https://circleci.com/gh/philou/planning-poker">circleci</a>, and deployed to a <a href="http://104.131.47.10/">DigitalOcean box</a>.</p>

<p>The next steps (first, find a better subdomain, second, speed up the build job) will tell me if this kind of deployment is what I need for my pet projects. If it turns out too complicated or too difficult to maintain, <a href="http://dokku.viewdocs.io/dokku/">Dokku</a> is on my radar.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to setup Rails, Docker, PostgreSQL (and Heroku) for local development ?]]></title>
    <link href="http://philippe.bourgau.net/how-to-setup-rails-docker-postgresql-and-heroku-for-local-development/"/>
    <updated>2016-07-20T06:12:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-setup-rails-docker-postgresql-and-heroku-for-local-development</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/philou/planning_poker">My current side project</a> is an online tool to do remote planning pokers. I followed my <a href="/how-to-boot-a-new-rails-project-with-docker-and-heroku/">previous tutorial</a> to setup Rails, Docker and Heroku.</p>

<p>Naturally, as a BDD proponent, I tried to install <a href="https://cucumber.io">cucumber</a> to write my first scenario.</p>

<p>Here is the result of my first cucumber run :</p>

<p><code>bash
$ docker-compose run shell bundle exec cucumber
rails aborted!
PG::ConnectionBad: could not translate host name "postgres://postgres:@herokuPostgresql:5432/postgres" to address: Name or service not known
...
</code></p>

<p>It turned out that I had taken instructions from a <a href="https://blog.codeship.com/deploying-docker-rails-app/">blog article on codeship</a> that mistakenly used <code>host:</code> instead of <code>url:</code> in their <code>config/database.yml</code></p>

<p>After fixing that in my database.yml file, things where only slightly working better :</p>

<p><code>bash
$ docker-compose run shell bundle exec cucumber
rails aborted!
ActiveRecord::StatementInvalid: PG::ObjectInUse: ERROR:  cannot drop the currently open database
: DROP DATABASE IF EXISTS "postgres"
</code></p>

<p>The thing is the config was still using the same database for all environments. That&rsquo;s not exactly what I wanted. I updated my <code>config/database.yml</code> :</p>

<p>```yaml
default: &amp;default
  adapter: postgresql
  encoding: unicode
  pool: 5
  timeout: 5000
  username: postgres
  port: 5432
  host: herokuPostgresql</p>

<p>development:
  &lt;&lt;: *default
  database: planning_poker_development</p>

<p>test: &amp;test
  &lt;&lt;: *default
  database: planning_poker_test</p>

<p>production:
  &lt;&lt;: *default
  url: &lt;%= ENV[&lsquo;DATABASE_URL&rsquo;] %>
```</p>

<p>Victory ! Cucumber is running</p>

<p>```bash
$ docker-compose run shell bundle exec cucumber
Using the default profile&hellip;
0 scenarios
0 steps
0m0.000s
Run options: &mdash;seed 45959</p>

<h1>Running:</h1>

<p>Finished in 0.002395s, 0.0000 runs/s, 0.0000 assertions/s.</p>

<p>0 runs, 0 assertions, 0 failures, 0 errors, 0 skips
```</p>

<h2>Fixing rake db:create</h2>

<p>By searching through the web, I found that people were having similar issues with rake db:create. I tried to run it and here is what I got :</p>

<p><code>bash
$ docker-compose run shell bundle exec rake db:create
Database 'postgres' already exists
Database 'planning_poker_test' already exists
</code></p>

<p>Why is it trying to create the postgres database ? It turns out that the DATABASE_URL takes precedence over what is defined in my <code>config/database.yml</code>. I need to unset this variable locally. I already have the <code>docker-compose.override.yml</code> for that :</p>

<p>```yaml
web:
  environment:</p>

<pre><code>DATABASE_URL:
</code></pre>

<p>  &hellip;</p>

<p>shell:
  environment:</p>

<pre><code>DATABASE_URL:
</code></pre>

<p>  &hellip;
```</p>

<p>Rake db:create works just fine now :</p>

<p><code>bash
$ docker-compose run shell bundle exec rake db:create
Database 'planning_poker_development' already exists
Database 'planning_poker_test' already exists
</code></p>

<h2>Starting a psql session</h2>

<p>During all my trouble-shootings, I tried to connect to the Postgresql server to make sure that the databases where created and ready. Here is how I managed to do that :</p>

<h3>1. Install psql client</h3>

<p>On my Ubuntu machine, that was a simple <code>sudo apt-get install postgresql-client-9.4</code>.</p>

<h3>2. Finding the server port</h3>

<p>The port can be found through <code>config/database.yml</code> or through <code>docker ps</code>. Let&rsquo;s use the later, as we&rsquo;ll need it to find the server IP as well.</p>

<p><code>bash
$ docker ps
CONTAINER ID        IMAGE            COMMAND                  CREATED             STATUS              PORTS           NAMES
b58ce42d2b2b        postgres         "/docker-entrypoint.s"   46 hours ago        Up 46 hours         5432/tcp        planningpoker_herokuPostgresql_1
</code></p>

<p>Here the port is clearly 5432.</p>

<h3>3. Finding the server IP</h3>

<p>Using the container id we got on previous <code>docker ps</code> command, we can use <code>docker inspect</code> to get further details :</p>

<p>```bash
$ docker inspect b58ce42d2b2b | grep IPAddress</p>

<pre><code>        "SecondaryIPAddresses": null,
        "IPAddress": "172.17.0.2",
                "IPAddress": "172.17.0.2",
</code></pre>

<p>```</p>

<h3>4. Connecting to the database</h3>

<p>Connecting is now just a matter of filling the command line.</p>

<p>```sql
$ psql -U postgres -p 5432 -d planning_poker_development -h 172.17.0.2
planning_poker_development=# select * from schema_migrations;</p>

<h2> version</h2>

<p>(0 rows)
```</p>

<h3>5. Installing psql client directly in the shell</h3>

<p>It should be possible to install the psql client in the shell container automatically, but I must admit I did not try this yet. It should just a matter of adding this to the <code>Dockerfile</code></p>

<p><code>
RUN apt-get install postgresql-client-&lt;version&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to boot a new Rails project with Docker and Heroku]]></title>
    <link href="http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku/"/>
    <updated>2016-07-13T04:55:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku</id>
    <content type="html"><![CDATA[<p>A few years ago, I used <a href="http://www.heroku.com">Heroku</a> to deploy my <a href="https://github.com/philou/mes-courses">side-project</a>. It provides great service, but I remember that updates to the Heroku Stack was a nightmare &hellip; Versions of the OS (and nearly everything) changed. The migration was a matter of days, and while doing a side-project, this was difficult. At the time, I remember thinking that using branches and VMs would have been the solution.</p>

<p>Now that I started to use Heroku again, I decided to use <a href="http://www.docker.com">Docker</a> from the beginning. More specifically, I am expecting :</p>

<ul>
<li>to have a minimal setup on my host machine</li>
<li>to use the same infrastructure in dev than in production</li>
<li>to simplify switching to a new machine</li>
<li>to simplify the migration to the next Heroku stack</li>
</ul>


<p>As an added benefit, if ever someone else joins me in my side-project, it will be a matter of minutes before we can all work on the same infrastructure !</p>

<p>Heroku provides a <a href="https://devcenter.heroku.com/articles/local-development-with-docker">tutorial</a> about how to deploy an existing <a href="http://rubyonrails.org/">Rails</a> app to heroku using containers. Unfortunately, I did yet have an existing rails app &hellip; So the first challenge I faced, was how to create a Rails app without actually installing Rails on my machine. The trick is to bootstrap rails in docker itself before packaging all this for Heroku.</p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/logos.jpg" title="The 3 logos of Rails, Docker and Heroku" ></p>

<h2>1. Install the required software</h2>

<p>I installed only 4 things on my host machine
&ndash; Docker <a href="https://docs.docker.com/engine/installation/">instructions</a>
&ndash; Docker Compose <a href="https://docs.docker.com/compose/install/">instructions</a>
&ndash; Heroku Toolbelt <a href="https://toolbelt.heroku.com/">instructions</a>
&ndash; Heroku container plugin <code>heroku plugins:install heroku-container-tools</code></p>

<p>That&rsquo;s all I changed to my host machine.</p>

<h2>2. Setup docker</h2>

<p>First, let&rsquo;s create a new dir and step into it. Run :
<code>bash
mkdir docker-rails-heroku
cd docker-rails-heroku
</code>
To prepare the Heroku setup, create a <code>Procfile</code>
<code>
web: bundle exec puma -C config/puma.rb
</code>
and <code>app.json</code>
```json
{
  &ldquo;name&rdquo;: &ldquo;Docker Rails Heroku&rdquo;,
  &ldquo;description&rdquo;: &ldquo;An example app.json for container-deploy&rdquo;,
  &ldquo;image&rdquo;: &ldquo;heroku/ruby&rdquo;,
  &ldquo;addons&rdquo;: [</p>

<pre><code>"heroku-postgresql"
</code></pre>

<p>  ]
}
<code>
To generate docker files for Heroku, run :
</code>bash
heroku container:init
```
You want to run Rails in dev mode locally, so we need to override Heroku&rsquo;s default env (<a href="/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode/">Check my previous post for details</a>)</p>

<p>Create an <code>.env</code> file
<code>
RAILS_ENV=development
</code>
and <code>docker-compose.override.yml</code>
```yaml
web:
  volumes:</p>

<pre><code>- '.:/app/user'
</code></pre>

<p>  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>shell:
  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>```</p>

<h2>3. Create the Rails app</h2>

<p>It&rsquo;s now time to follow <a href="https://docs.docker.com/compose/rails/">the official docker-compose rails tutorial</a> to bootstrap the rails app and directories :</p>

<p>Change <code>Dockerfile</code> to
```</p>

<h1>FROM heroku/ruby</h1>

<p>FROM ruby:2.2.0
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs
RUN mkdir /myapp
WORKDIR /myapp
ADD Gemfile /myapp/Gemfile
ADD Gemfile.lock /myapp/Gemfile.lock
RUN bundle install
ADD . /myapp
```</p>

<p>Create a bootstrap <code>Gemfile</code> with the content
<code>ruby
source 'https://rubygems.org'
gem 'rails', '4.2.0'
</code>
Bundle install within the container requires a existing <code>Gemfile.lock</code>
```bash</p>

<h1>Create an empty Gemfile.lock</h1>

<p>touch Gemfile.lock
```</p>

<p>It&rsquo;s now time to build your docker container to be able to run rails and generate your source files. Run the following :
```bash</p>

<h1>Build your containers</h1>

<p>docker-compose build</p>

<h1>Run rails within the shell container and generate rails files</h1>

<p>docker-compose run shell bundle exec rails new . &mdash;force &mdash;database=postgresql &mdash;skip-bundle
```</p>

<p>Unfortunately, rails is ran as root inside the container. We can change ownership and rights with this command :
```bash</p>

<h1>Change ownership</h1>

<p>sudo chown -R $USER:$USER .</p>

<h1>Change rights</h1>

<p>sudo chmod -R ug+rw .
```</p>

<h2>4. Make it Heroku ready</h2>

<p>Now that the rails files are generated, It&rsquo;s time to replace the bootstrap settings with real Heroku Dockerfile</p>

<p>Revert <code>Dockerfile</code> to simply :
<code>
FROM heroku/ruby
</code></p>

<p>Heroku uses <a href="http://puma.io/">Puma</a> so we need to add it to our <code>Gemfile</code>
```ruby</p>

<h1>Use Puma as the app server</h1>

<p>gem &lsquo;puma&rsquo;, &lsquo;~> 3.0&rsquo;
<code>
We also need to add a config file for Puma. Create</code>config/puma.rb<code>with this content (you can check [heroku doc](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#adding-puma-to-your-application) for details)
</code>ruby
workers Integer(ENV[&lsquo;WEB_CONCURRENCY&rsquo;] || 2)
threads_count = Integer(ENV[&lsquo;RAILS_MAX_THREADS&rsquo;] || 5)
threads threads_count, threads_count</p>

<p>preload_app!</p>

<p>rackup      DefaultRackup
port        ENV[&lsquo;PORT&rsquo;]     || 3000
environment ENV[&lsquo;RACK_ENV&rsquo;] || &lsquo;development&rsquo;</p>

<p>on_worker_boot do
  # Worker specific setup for Rails 4.1+
  # See: <a href="https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot</a>
  ActiveRecord::Base.establish_connection
end
```</p>

<p>It should now be possible to rebuild the container, and run the app :
```bash</p>

<h1>Rebuild the containers</h1>

<p>docker-compose build</p>

<h1>Start the rails app using the web container</h1>

<p>docker-compose up web
```
The app should be accessible at <a href="http://0.0.0.0:8080">http://0.0.0.0:8080</a></p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/rails-homepage.jpg" title="The default homepage for a new Rails application" ></p>

<h2>5. Deploying to heroku</h2>

<p>We&rsquo;re almost ready to deploy to heroku.</p>

<p>First, we need to exclude development files from our image. For this, we need to create a <code>.dockerignore</code> file with the content
<code>
.git*
db/*.sqlite3
db/*.sqlite3-journal
log/*
tmp/*
Dockerfile
.env
docker-compose.yml
docker-compose.override.yml
README.rdoc
</code>
It&rsquo;s then classic Heroku deploy commands :</p>

<p>```bash</p>

<h1>create an Heroku app</h1>

<p>heroku apps:create &lt;your-app-name></p>

<h1>And deploy to it</h1>

<p>heroku container:release &mdash;app &lt;your-app-name>
```</p>

<p>Your app should be accessible on line at <a href="https://">https://</a>&lt;your-app-name>.herokuapp.com/</p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/deployed-to-heroku.jpg" title="The typical error message when you deploy a new Rails app to heroku" ></p>

<p>Rails does not provide a default homepage in production. But you can check the logs with</p>

<p><code>bash
heroku logs --app &lt;your-app-name&gt;
</code></p>

<h2>6. Running commands</h2>

<p>When in development mode, you might want to run rails or other commands on your source code again. The shell container exists just for that, run <code>docker-compose run shell ...</code>.
```bash</p>

<h1>For example, to update your bundle</h1>

<p>docker-compose run shell bundle update
```</p>

<h3>EDIT 2016-07-20</h3>

<p>For the moment, there&rsquo;s a catch with bundle install or update commands, as the gems are installed outside the shared volume, only Gemfile.lock will be updated, which required to run docker-compose build again &hellip; I&rsquo;ll have a look into this later and see if I can fix that.</p>

<p><code>bash
docker-compose run shell bundle update
docker-compose build
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I organized my javascript assets in Rails]]></title>
    <link href="http://philippe.bourgau.net/how-i-organized-my-javascript-assets-in-rails/"/>
    <updated>2013-11-27T05:56:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-i-organized-my-javascript-assets-in-rails</id>
    <content type="html"><![CDATA[<p><a href="/jasmine-and-coffeescript-setup-for-rails/">Lately</a>, I have been introducing javascript and coffeescript in <a href="http://www.mes-courses.com">www.mes-courses.fr</a> (with structural architecture issues as a side effect, but that&rsquo;s another story &hellip;).</p>

<p>Here are the general goals I had when using the rails asset pipeline :</p>

<ul>
<li>most of js compiled in a single file</li>
<li>no js code in your html files : I want to use unintrusive javascript techniques, and have some outside js hook code that will wire js and html together</li>
<li>sometimes, I want some js code to be only explicitly included by some particular pages (example: hooking a timer on the document ready event of a particular html page). This means that I cannot simply compile all js code in a single minified file</li>
<li>In unit tests, I want to be able to manually set up and tear down the js hooks</li>
</ul>


<p>So, here is how I eventually organized my js code :</p>

<ul>
<li>I create a specific dependencies.js file that will require all outside dependencies</li>
<li>I split my js code under 3 subdirectories :

<ul>
<li>explicit : hooks that will be explicitly included</li>
<li>hooks : all the other hooks</li>
<li>application : all the real code</li>
</ul>
</li>
<li>In my application.js, I include dependencies and all files under application and hooks. Here is my app/assets/javascript/application.js</li>
</ul>


<p><code>javascript
//= require dependencies.js
//= require_tree ./application
//= require_tree ./hooks
</code></p>

<ul>
<li>In my tests, I only load dependencies and files from the application directory. Here is my spec/javascript/spec.js.coffee</li>
</ul>


<p>```coffeescript</p>

<h1>= require ../../app/assets/javascripts/dependencies.js</h1>

<h1>= require_tree ../../app/assets/javascripts/application</h1>

<h1>= require_tree ./</h1>

<p>```</p>

<ul>
<li>Hook code only consists of calling a setup function from the &lsquo;real&rsquo; code. For example, here is my app/assets/javascript/hooks/cart_lines/index.coffee file</li>
</ul>


<p><code>coffeescript
$(document).ready(window.mesCourses.cartLines.index.setUp)
</code></p>

<p>this setUp function is defined in the app/assets/javascript/application/cart_lines/index.coffee file</p>

<ul>
<li>This way, from the unit tests, I can explicitly call this setUp function, here is the beginning of my spec/javascript/application/cart_lines/index_spec.coffee file</li>
</ul>


<p>```coffeescript
describe &lsquo;mesCourses.cartLines.index&rsquo;, &ndash;></p>

<p>  beforeEach &ndash;></p>

<pre><code>window.mesCourses.cartLines.index.setUp()
</code></pre>

<p>  &hellip;
```</p>

<p>And you, how are you organizing your javacript assets ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simplest way to speed up rspec with in memory sqlite db]]></title>
    <link href="http://philippe.bourgau.net/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db/"/>
    <updated>2013-08-02T09:16:00+00:00</updated>
    <id>http://philippe.bourgau.net/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db</id>
    <content type="html"><![CDATA[<p>There are already a lot of articles explaining how to setup an in memory <a href="http://www.sqlite.org/">SQLite</a> database to speed up <a href="http://rubyonrails.org/">Rails</a> specs or unit tests. Most of them explain how to change your database.yml and to run setup your schema before running the tests. It works fine.</p>

<p>There&rsquo;s a catch though : suppose you are using <a href="http://cukes.info/">cucumber</a>, it&rsquo;s likely you&rsquo;d rather run cucumber on a real database (<a href="http://www.postgresql.org/">PostgreSQL</a>, <a href="http://www.mysql.com/">MySQL</a> or whatever). Most gems expect cucumber and <a href="http://rspec.info/">rspec</a> to both run in the test environment &hellip; Every time I updated my bundle or that I wanted to use a new test gem, I would hit an issue about cucumber being run in its own &lsquo;cucumber&rsquo; environment : unexpected warnings and things not working out of the box.</p>

<p>Eventually, I ditched the cucumber env, setup a PostgreSQL db on the test env, and injected the in memory sqlite database right inside spec_helper.rb :</p>

<p>In database.yml :</p>

<p><code>yaml
test:
  adapter: postgresql
  database: mes_courses_test
  encoding: utf8
  pool: 5
  timeout: 5000
  username: mes_courses
  password: secret
  host: localhost
  port: 5433
</code></p>

<p>At the bottom of spec_helper.rb</p>

<p>```ruby
setup_sqlite_db = lambda do
  ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)</p>

<p>  load &ldquo;#{Rails.root.to_s}/db/schema.rb&rdquo; # use db agnostic schema by default
  # ActiveRecord::Migrator.up(&lsquo;db/migrate&rsquo;) # use migrations
end
silence_stream(STDOUT, &amp;setup_sqlite_db)
```</p>
]]></content>
  </entry>
  
</feed>
