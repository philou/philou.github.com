<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2017-02-17T07:49:26+00:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How I finally use Docker on small open source side projects]]></title>
    <link href="http://philippe.bourgau.net/how-i-finally-use-docker-on-small-open-source-side-projects/"/>
    <updated>2017-02-16T19:37:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-i-finally-use-docker-on-small-open-source-side-projects</id>
    <content type="html"><![CDATA[<p>A few months ago, I started <a href="https://github.com/philou/planning-poker">Philou&rsquo;s Planning Poker</a>, an open source side project to run <a href="https://en.wikipedia.org/wiki/Planning_poker">planning poker estimate sessions</a> remotely. The main technology is <a href="http://rubyonrails.org/">Rails</a>, and I&rsquo;d been planning to use <a href="https://www.docker.com/">Docker</a> as much as possible as a way to learn it. Indeed, I learned that Docker is no Silver Bullet !</p>

<p><img class="center" src="/imgs/2017-02-16-how-i-finally-use-docker-on-small-open-source-side-projects/docker-silver-bullet.jpg" title="The Docker logo next to a silver bullet" ></p>

<h2>The Docker love phase</h2>

<p>At first everything seemed great about Docker. I&rsquo;d used it on toy projects and it proved great to quickly setup cheap and fast virtual machines. I even created the <a href="https://github.com/philou/rubybox">Rubybox</a> project on Github to clone new ruby VMs in a matter of seconds. I also used Docker to host my <a href="http://octopress.org/">Octopress</a> environment to write this blog. As a long time Linux user, my dev machines have repeatedly been suffering from pollution : after some time, they get plagued with all the stuff I installed to do my various dev experiments, and at some point, re-install seems easier than cleaning up all the mess. If I could use containers for all my projects, Docker would be a cure for this.</p>

<p>Going through all these successes, when I started my planning poker app, I decided to go all into Docker, development, CI and deployment. You can read the log of how I did that in <a href="http://philippe.bourgau.net/blog/categories/docker/">these posts</a>. Fast forward a bit of searching, experimenting and deploying, all was setup : my dev env was in containers, my CI was running in containers in <a href="https://circleci.com/gh/philou/planning-poker/tree/master">CircleCI</a> and the app was pushed to containers on <a href="https://www.digitalocean.com/">DgitalOcean</a>.</p>

<h2>Reality strikes back</h2>

<p>At first, everything seemed to be working fine. Even if there were a few glitches that I would have to fix down the road like :</p>

<ul>
<li>Whenever I wanted to update my app&rsquo;s dependencies, I had to run <code>bundle update</code> twice, and not incrementally. Surely, I would manage to fix that with a bit of time</li>
<li>Obviously, the CI was slower, because it had to build the containers before deploying them to <a href="https://hub.docker.com/">Docker Hub</a>, but that was the price to pay in order to know exactly what was running on the server &hellip; right ?</li>
<li>And &hellip; <a href="https://github.com/guard/guard">Guard</a> notifications did not appear on my desktop. I was accessing my dev env through ssh, so I would have to fix that, just a few hours and it should be working</li>
</ul>


<p>After a while, I got used to my work environment and became almost as productive as I used to be &hellip; but you know, shit happens !</p>

<ul>
<li>I had to install <a href="http://phantomjs.org/">PhantomJS</a> on my CI, and if that comes out of the box on <a href="https://travis-ci.org/">TravisCI</a>, you&rsquo;re all alone in your own containers. Installing this on the Debian container proved unnecessarily complex, but I figured it out</li>
<li>Then all of a sudden, my CI started to break &hellip; You can read a summary of what I did to fix it <a href="/how-i-fixed-devicemapper-error-when-deploying-my-docker-app/">here</a>. Long story short : I had forgotten to clean up old docker images, and after enough deployments, the server ran out of space, and that corrupted the docker cache somehow. I eventually re-installed and upgraded the deployment VM. That made me lose quite some time though.</li>
<li>Finally, as I started to play with <a href="https://github.com/rails/actioncable">ActionCable</a>, I could not get the web-socket notifications through my dev host. There must be some settings and configuration to make this work, for sure, but it&rsquo;s supposed to work out of the box.</li>
</ul>


<p>Eventually, this last issue convinced me to change my setup. All these usages of Docker where definitely worth it from a learning point of view, but as my focus moved to actually building the app, it was time to take pragmatic decisions.</p>

<h2>My use of Docker now</h2>

<p>There were 2 main ideas driving my changes to my dev env for this open source side project :</p>

<ol>
<li>Use the thing most people do</li>
<li>Use commercially supported services &amp; tools</li>
</ol>


<p>These should avoid losing my time instead of being productive. My setup is now almost boring ! To summarize I now use <a href="https://travis-ci.org/philou/planning-poker">TravisCI</a>, <a href="https://philous-planning-poker.herokuapp.com/">Heroku</a>, and <a href="https://github.com/rbenv/rbenv">rbenv</a> on my physical machine. I kept Docker where it really shines : all the local servers required for development are managed by <a href="https://docs.docker.com/compose/">Docker Compose</a>. Here is my <a href="https://github.com/philou/planning-poker/blob/master/docker-compose.yml"><code>docker-compose.yml</code></a></p>

<p>```yaml
db:
  image: postgres:9.4.5
  volumes:</p>

<pre><code>- planning-poker-postgres:/var/lib/postgresql/data
</code></pre>

<p>  ports:</p>

<pre><code>- "5432:5432"
</code></pre>

<p>redis:
  image: redis:3.2-alpine
  volumes:</p>

<pre><code>- planning-poker-redis:/var/lib/redis/data
</code></pre>

<p>  ports:</p>

<pre><code>- "6379:6379"
</code></pre>

<p>```</p>

<p>This saves me from installing <a href="https://www.postgresql.org/">Postgresql</a> or <a href="https://redis.io/">Redis</a> on my dev machine, and I can start all the services required for app with a single <code>docker-compose up</code> command !</p>

<h2>My future uses of Docker</h2>

<p>More generally, in the near future, here is when I&rsquo;ll use docker</p>

<ul>
<li>As I just said, to manage local servers</li>
<li>To boot quick and cheap VMs (check <a href="https://github.com/philou/rubybox">rubybox</a>)</li>
<li>To handle CI and deployment of large or non-standard systems, where Docker can provide a lot of benefits in terms of price, scaling or configurability</li>
</ul>


<p>Docker came from the deployment world, and this is where it is so great. As of today though, even if it is usable as dev VM, it is still not up to a standard dev machine. Despite that, all the issues I ran into could be fixed, and I&rsquo;m pretty sure they&rsquo;ll be some day.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 minutes hack to speed up RSpec in Rails 5 using in-memory SQLite]]></title>
    <link href="http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite/"/>
    <updated>2017-01-25T07:53:00+00:00</updated>
    <id>http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite</id>
    <content type="html"><![CDATA[<p>Here is the story : you have a <a href="http://rubyonrails.org/">Rails 5</a> app that uses <a href="http://rspec.info/">RSpec</a>, but your RSpec suite is getting slower and slower to run. You&rsquo;ve already considered some solutions :</p>

<ul>
<li>Use <a href="https://sqlite.org/">SQLite</a> in memory for your test env.</li>
</ul>


<p><code>yaml
test:
  adapter: sqlite3
  database: ":memory:"
</code></p>

<p>That&rsquo;s the most straightforward thing to do, but unfortunately, if you are sharing your test env with <a href="https://cucumber.io/">Cucumber</a>, you might want to use a production like DB with Cucumber (<a href="https://www.postgresql.org/">PostgreSQL</a> or whatever). So unless you are ready to setup a new env for cucumber (which I tried and don&rsquo;t recommend) you&rsquo;re stuck.</p>

<ul>
<li>Use mocks. That&rsquo;s surely going to work, it&rsquo;s going to make your test hell of a lot faster ! It will also make your tests a lot more fragile and more expensive to maintain &hellip; If you want to read more about why I think mocks are a bad idea, just have a look at <a href="/blog/categories/mocking/">these posts</a>.</li>
</ul>


<h2>The hack</h2>

<p>Here is a third alternative, I&rsquo;ve <a href="/simplest-way-to-speed-up-rspec-with-in-memory-sqlite-db/">already written about it</a>, but here it comes updated and tested for Rails 5 :</p>

<ol>
<li>Don&rsquo;t change anything to your <code>config/database.yml</code></li>
<li>Obviously, you&rsquo;ll need to add <code>sqlite3</code> to your <code>Gemfile</code></li>
<li>At the beginning of your <code>spec/rails_helper.rb</code>, replace</li>
</ol>


<p>``` ruby</p>

<h1>Checks for pending migration and applies them before tests are run.</h1>

<h1>If you are not using ActiveRecord, you can remove this line.</h1>

<p>ActiveRecord::Migration.maintain_test_schema!
```</p>

<p>with</p>

<p>``` ruby</p>

<h1>In order to keep the same RAILS_ENV for rspec and cucumber,</h1>

<h1>patch the connection to use sqlite in memory when running rspec</h1>

<p>ActiveRecord::Base.establish_connection(adapter: &lsquo;sqlite3&rsquo;, database: &lsquo;:memory:&rsquo;)
ActiveRecord::Schema.verbose = false
load &ldquo;#{Rails.root.to_s}/db/schema.rb&rdquo;
```</p>

<p>That&rsquo;s it ! Run your specs &hellip; not bad for a 5 minutes investment !</p>

<h2>One more thing &hellip;</h2>

<p>If you need even more speed, you can now run your specs in parallel in different processes ! Each in-memory SQLite DB is bound to its process, so unlike a real PostgreSQL dev DB, you won&rsquo;t get any conflicts between your tests ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Continuously Deliver a Rails App to your DigitalOcean Box using Docker]]></title>
    <link href="http://philippe.bourgau.net/continuously-deliver-a-rails-app-to-your-digital-ocean-box-using-docker/"/>
    <updated>2016-10-25T20:39:00+00:00</updated>
    <id>http://philippe.bourgau.net/continuously-deliver-a-rails-app-to-your-digital-ocean-box-using-docker</id>
    <content type="html"><![CDATA[<p>I decided to use <a href="https://github.com/philou/planning-poker">my latest side project</a> as an occasion to learn <a href="https://www.docker.com/">Docker</a>. I first used <a href="https://www.heroku.com/">Heroku</a> as a platform for deployment (see <a href="/how-to-boot-a-new-rails-project-with-docker-and-heroku/">previous post</a>). It works fine but I discovered the following shortcomings :</p>

<ul>
<li>Heroku does not deploy with Docker, which means that I&rsquo;d get quite different configurations between dev and prod, which is one of the promises of Docker :(</li>
<li>The dockerfile provided by docker runs bundle install in a directory outside of the docker main shared volume, this forces to do bundle update twice (once to update Gemfile.lock and a second time to update the actual gems &hellip;)</li>
</ul>


<p>None of these issues could be fixed without moving away from Heroku.</p>

<h2>A great Tutorial / Guide</h2>

<p>I followed <a href="http://chrisstump.online/">Chris Stump</a>&rsquo;s great tutorials to <a href="http://chrisstump.online/2016/02/20/docker-existing-rails-application/">setup Docker for my app</a>, to <a href="http://chrisstump.online/2016/03/03/continuous-integration-docker-rails/">continuously integrate</a> on <a href="https://circleci.com/">CircleCI</a> and to <a href="http://chrisstump.online/2016/03/17/continuous-deployment-docker-rails/">continuously deploy</a> on a private virtual server on <a href="https://www.digitalocean.com/">DigitalOcean</a>.</p>

<p>The first 2 steps (Docker &amp; CI) worked really out of the box after following the tutorial. Dealing with step 3 (CD) was a bit more complicated, because of :</p>

<ol>
<li>the specificities of DigitalOcean</li>
<li>the fact that I&rsquo;m a no deployment expert &hellip;</li>
</ol>


<p><img class="center" src="/imgs/2016-10-25-continuously-deliver-a-rails-app-to-your-digital-ocean-box-using-docker/docker-circleci-digitalocean.jpg" title="The logos of Docker, CircleCI and DigitalOcean" ></p>

<h2>What did I need to do to make it work</h2>

<h3>Setup SSH on the DigitalOcean box</h3>

<p>I started by creating a <a href="https://cloud.digitalocean.com/droplets/new?size=2gb&amp;region=nyc3&amp;appId=20423249&amp;type=applications">one-click DigitalOcean box</a> with Docker pre-installed. That&rsquo;s the moment where I had to setup SSH in order to make CircleCI deploy to my box. DigitalOcean has a <a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets">guide for this</a>, but here is how I did it :</p>

<ol>
<li>Create a special user on my dev machine <code>adduser digitaloceanssh</code></li>
<li>Log as this user <code>su digitaloceanssh</code>, and generated ssh keys for it <code>ssh-keygen</code></li>
<li>Print the public key <code>cat ~/.ssh/id_rsa.pub</code> and copy paste it in your DigitalOcean box setup</li>
<li>Print the private key <code>cat ~/.ssh/id_rsa</code> and copy past it in your circle-ci job ssh keys</li>
</ol>


<p>The benefit of this is that you should now be able to ssh in your DigitalOcean box from your digitaloceanssh user <code>ssh root@&lt;ip.to.digital.ocean&gt;</code></p>

<h3>Optional : update the box</h3>

<p>The first time I logged into my box, I noted that packages were out of date. If you need it, updating the packages is a simple matter of <code>apt-get update &amp;&amp; apt-get upgrade</code></p>

<h3>Fix deployment directory</h3>

<p>By default, the home dir of the root user on the DigitalOcean box is <code>/root/</code>. Unfortunately, Chris Stump&rsquo;s tutorial assumes it to be <code>/home/root/</code>. In order to fix that, I ssh-ed in the box and created a symbolic link : <code>ln -s /root /home/root</code>.</p>

<h3>Install docker-compose on the box</h3>

<p>Chris Stump&rsquo;s tutorial expects docker-compose on the deployment box, but DigitalOcean only installs Docker on its boxes &hellip; Install instructions for docker-compose can be found <a href="https://docs.docker.com/compose/install/">here</a>. Don&rsquo;t use the container option, it does not inherit environment variables, and will fail the deployment, just use the first curl based alternative.</p>

<h3>Warning : replace ALL dockerexample</h3>

<p>This comes as an evidence, but be sure to replace all the references to &lsquo;dockerexample&rsquo; to your own app name in all of Chris Stump&rsquo;s templates (I forgot some and lost a few rebuilds for that)</p>

<h3>Create the production DB</h3>

<p>Chris Stump&rsquo;s deployment script works with an existing production DB. The first migration will fail. To fix this, just do the following :</p>

<ol>
<li>ssh into the DigitalOcean server</li>
<li>run <code>DEPLOY_TAG=&lt;latest_deploy_tag&gt; RAILS_ENV=production docker-compose -f docker-compose.production.yml run app bundle exec rake db:create</code></li>
</ol>


<p>You can find the latest DEPLOY_TAG from the CircleCi step <code>bundle exec rake docker:deploy</code></p>

<h3>How to access the logs</h3>

<p>It might come handy to check the logs of your production server ! Here is how to do this :</p>

<ol>
<li>ssh in your production server</li>
<li>run the following to tail on the logs <code>DEPLOY_TAG=`cat deploy.tag` RAILS_ENV=production docker-compose -f docker-compose.production.yml run app tail -f log/production.log</code></li>
</ol>


<p>Obviously, tail is just an example, use anything else at your convenience.</p>

<h3>Generate a secret token</h3>

<p>Eventually, the build and deployment job succeeded &hellip; I had still one last error when I tried to access the web site : <code>An unhandled lowlevel error occurred. The application logs may have details.</code>. After some googling, I understood that this error occurs when you did not set a secret key base for your rails app (<a href="http://stackoverflow.com/questions/37112804/an-unhandled-lowlevel-error-occurred-the-application-logs-may-have-details">details</a>). There is a <a href="http://www.jamesbadger.ca/2012/12/18/generate-new-secret-token/">rails task to generate a token</a>, all that was needed was to create a .env file on the server with the following :</p>

<p><code>SECRET_KEY_BASE=&lt;GENERATED_SECRET...&gt;</code></p>

<h2>What&rsquo;s next ?</h2>

<p>Obviously, I learned quite a lot with this Docker exploration. I am still in the discovery phase, but my planning poker side project is now continuously built on <a href="https://circleci.com/gh/philou/planning-poker">circleci</a>, and deployed to a <a href="http://104.131.47.10/">DigitalOcean box</a>.</p>

<p>The next steps (first, find a better subdomain, second, speed up the build job) will tell me if this kind of deployment is what I need for my pet projects. If it turns out too complicated or too difficult to maintain, <a href="http://dokku.viewdocs.io/dokku/">Dokku</a> is on my radar.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to setup Rails, Docker, PostgreSQL (and Heroku) for local development ?]]></title>
    <link href="http://philippe.bourgau.net/how-to-setup-rails-docker-postgresql-and-heroku-for-local-development/"/>
    <updated>2016-07-20T06:12:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-setup-rails-docker-postgresql-and-heroku-for-local-development</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/philou/planning_poker">My current side project</a> is an online tool to do remote planning pokers. I followed my <a href="/how-to-boot-a-new-rails-project-with-docker-and-heroku/">previous tutorial</a> to setup Rails, Docker and Heroku.</p>

<p>Naturally, as a BDD proponent, I tried to install <a href="https://cucumber.io">cucumber</a> to write my first scenario.</p>

<p>Here is the result of my first cucumber run :</p>

<p><code>bash
$ docker-compose run shell bundle exec cucumber
rails aborted!
PG::ConnectionBad: could not translate host name "postgres://postgres:@herokuPostgresql:5432/postgres" to address: Name or service not known
...
</code></p>

<p>It turned out that I had taken instructions from a <a href="https://blog.codeship.com/deploying-docker-rails-app/">blog article on codeship</a> that mistakenly used <code>host:</code> instead of <code>url:</code> in their <code>config/database.yml</code></p>

<p>After fixing that in my database.yml file, things where only slightly working better :</p>

<p><code>bash
$ docker-compose run shell bundle exec cucumber
rails aborted!
ActiveRecord::StatementInvalid: PG::ObjectInUse: ERROR:  cannot drop the currently open database
: DROP DATABASE IF EXISTS "postgres"
</code></p>

<p>The thing is the config was still using the same database for all environments. That&rsquo;s not exactly what I wanted. I updated my <code>config/database.yml</code> :</p>

<p>```yaml
default: &amp;default
  adapter: postgresql
  encoding: unicode
  pool: 5
  timeout: 5000
  username: postgres
  port: 5432
  host: herokuPostgresql</p>

<p>development:
  &lt;&lt;: *default
  database: planning_poker_development</p>

<p>test: &amp;test
  &lt;&lt;: *default
  database: planning_poker_test</p>

<p>production:
  &lt;&lt;: *default
  url: &lt;%= ENV[&lsquo;DATABASE_URL&rsquo;] %>
```</p>

<p>Victory ! Cucumber is running</p>

<p>```bash
$ docker-compose run shell bundle exec cucumber
Using the default profile&hellip;
0 scenarios
0 steps
0m0.000s
Run options: &mdash;seed 45959</p>

<h1>Running:</h1>

<p>Finished in 0.002395s, 0.0000 runs/s, 0.0000 assertions/s.</p>

<p>0 runs, 0 assertions, 0 failures, 0 errors, 0 skips
```</p>

<h2>Fixing rake db:create</h2>

<p>By searching through the web, I found that people were having similar issues with rake db:create. I tried to run it and here is what I got :</p>

<p><code>bash
$ docker-compose run shell bundle exec rake db:create
Database 'postgres' already exists
Database 'planning_poker_test' already exists
</code></p>

<p>Why is it trying to create the postgres database ? It turns out that the DATABASE_URL takes precedence over what is defined in my <code>config/database.yml</code>. I need to unset this variable locally. I already have the <code>docker-compose.override.yml</code> for that :</p>

<p>```yaml
web:
  environment:</p>

<pre><code>DATABASE_URL:
</code></pre>

<p>  &hellip;</p>

<p>shell:
  environment:</p>

<pre><code>DATABASE_URL:
</code></pre>

<p>  &hellip;
```</p>

<p>Rake db:create works just fine now :</p>

<p><code>bash
$ docker-compose run shell bundle exec rake db:create
Database 'planning_poker_development' already exists
Database 'planning_poker_test' already exists
</code></p>

<h2>Starting a psql session</h2>

<p>During all my trouble-shootings, I tried to connect to the Postgresql server to make sure that the databases where created and ready. Here is how I managed to do that :</p>

<h3>1. Install psql client</h3>

<p>On my Ubuntu machine, that was a simple <code>sudo apt-get install postgresql-client-9.4</code>.</p>

<h3>2. Finding the server port</h3>

<p>The port can be found through <code>config/database.yml</code> or through <code>docker ps</code>. Let&rsquo;s use the later, as we&rsquo;ll need it to find the server IP as well.</p>

<p><code>bash
$ docker ps
CONTAINER ID        IMAGE            COMMAND                  CREATED             STATUS              PORTS           NAMES
b58ce42d2b2b        postgres         "/docker-entrypoint.s"   46 hours ago        Up 46 hours         5432/tcp        planningpoker_herokuPostgresql_1
</code></p>

<p>Here the port is clearly 5432.</p>

<h3>3. Finding the server IP</h3>

<p>Using the container id we got on previous <code>docker ps</code> command, we can use <code>docker inspect</code> to get further details :</p>

<p>```bash
$ docker inspect b58ce42d2b2b | grep IPAddress</p>

<pre><code>        "SecondaryIPAddresses": null,
        "IPAddress": "172.17.0.2",
                "IPAddress": "172.17.0.2",
</code></pre>

<p>```</p>

<h3>4. Connecting to the database</h3>

<p>Connecting is now just a matter of filling the command line.</p>

<p>```sql
$ psql -U postgres -p 5432 -d planning_poker_development -h 172.17.0.2
planning_poker_development=# select * from schema_migrations;</p>

<h2> version</h2>

<p>(0 rows)
```</p>

<h3>5. Installing psql client directly in the shell</h3>

<p>It should be possible to install the psql client in the shell container automatically, but I must admit I did not try this yet. It should just a matter of adding this to the <code>Dockerfile</code></p>

<p><code>
RUN apt-get install postgresql-client-&lt;version&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to boot a new Rails project with Docker and Heroku]]></title>
    <link href="http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku/"/>
    <updated>2016-07-13T04:55:00+00:00</updated>
    <id>http://philippe.bourgau.net/how-to-boot-a-new-rails-project-with-docker-and-heroku</id>
    <content type="html"><![CDATA[<p>A few years ago, I used <a href="http://www.heroku.com">Heroku</a> to deploy my <a href="https://github.com/philou/mes-courses">side-project</a>. It provides great service, but I remember that updates to the Heroku Stack was a nightmare &hellip; Versions of the OS (and nearly everything) changed. The migration was a matter of days, and while doing a side-project, this was difficult. At the time, I remember thinking that using branches and VMs would have been the solution.</p>

<p>Now that I started to use Heroku again, I decided to use <a href="http://www.docker.com">Docker</a> from the beginning. More specifically, I am expecting :</p>

<ul>
<li>to have a minimal setup on my host machine</li>
<li>to use the same infrastructure in dev than in production</li>
<li>to simplify switching to a new machine</li>
<li>to simplify the migration to the next Heroku stack</li>
</ul>


<p>As an added benefit, if ever someone else joins me in my side-project, it will be a matter of minutes before we can all work on the same infrastructure !</p>

<p>Heroku provides a <a href="https://devcenter.heroku.com/articles/local-development-with-docker">tutorial</a> about how to deploy an existing <a href="http://rubyonrails.org/">Rails</a> app to heroku using containers. Unfortunately, I did yet have an existing rails app &hellip; So the first challenge I faced, was how to create a Rails app without actually installing Rails on my machine. The trick is to bootstrap rails in docker itself before packaging all this for Heroku.</p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/logos.jpg" title="The 3 logos of Rails, Docker and Heroku" ></p>

<h2>1. Install the required software</h2>

<p>I installed only 4 things on my host machine
&ndash; Docker <a href="https://docs.docker.com/engine/installation/">instructions</a>
&ndash; Docker Compose <a href="https://docs.docker.com/compose/install/">instructions</a>
&ndash; Heroku Toolbelt <a href="https://toolbelt.heroku.com/">instructions</a>
&ndash; Heroku container plugin <code>heroku plugins:install heroku-container-tools</code></p>

<p>That&rsquo;s all I changed to my host machine.</p>

<h2>2. Setup docker</h2>

<p>First, let&rsquo;s create a new dir and step into it. Run :
<code>bash
mkdir docker-rails-heroku
cd docker-rails-heroku
</code>
To prepare the Heroku setup, create a <code>Procfile</code>
<code>
web: bundle exec puma -C config/puma.rb
</code>
and <code>app.json</code>
```json
{
  &ldquo;name&rdquo;: &ldquo;Docker Rails Heroku&rdquo;,
  &ldquo;description&rdquo;: &ldquo;An example app.json for container-deploy&rdquo;,
  &ldquo;image&rdquo;: &ldquo;heroku/ruby&rdquo;,
  &ldquo;addons&rdquo;: [</p>

<pre><code>"heroku-postgresql"
</code></pre>

<p>  ]
}
<code>
To generate docker files for Heroku, run :
</code>bash
heroku container:init
```
You want to run Rails in dev mode locally, so we need to override Heroku&rsquo;s default env (<a href="/docker-compose-trick-how-to-have-an-overridable-environment-variable-in-development-mode/">Check my previous post for details</a>)</p>

<p>Create an <code>.env</code> file
<code>
RAILS_ENV=development
</code>
and <code>docker-compose.override.yml</code>
```yaml
web:
  volumes:</p>

<pre><code>- '.:/app/user'
</code></pre>

<p>  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>shell:
  environment:</p>

<pre><code>RAILS_ENV: "${RAILS_ENV}"
</code></pre>

<p>```</p>

<h2>3. Create the Rails app</h2>

<p>It&rsquo;s now time to follow <a href="https://docs.docker.com/compose/rails/">the official docker-compose rails tutorial</a> to bootstrap the rails app and directories :</p>

<p>Change <code>Dockerfile</code> to
```</p>

<h1>FROM heroku/ruby</h1>

<p>FROM ruby:2.2.0
RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs
RUN mkdir /myapp
WORKDIR /myapp
ADD Gemfile /myapp/Gemfile
ADD Gemfile.lock /myapp/Gemfile.lock
RUN bundle install
ADD . /myapp
```</p>

<p>Create a bootstrap <code>Gemfile</code> with the content
<code>ruby
source 'https://rubygems.org'
gem 'rails', '4.2.0'
</code>
Bundle install within the container requires a existing <code>Gemfile.lock</code>
```bash</p>

<h1>Create an empty Gemfile.lock</h1>

<p>touch Gemfile.lock
```</p>

<p>It&rsquo;s now time to build your docker container to be able to run rails and generate your source files. Run the following :
```bash</p>

<h1>Build your containers</h1>

<p>docker-compose build</p>

<h1>Run rails within the shell container and generate rails files</h1>

<p>docker-compose run shell bundle exec rails new . &mdash;force &mdash;database=postgresql &mdash;skip-bundle
```</p>

<p>Unfortunately, rails is ran as root inside the container. We can change ownership and rights with this command :
```bash</p>

<h1>Change ownership</h1>

<p>sudo chown -R $USER:$USER .</p>

<h1>Change rights</h1>

<p>sudo chmod -R ug+rw .
```</p>

<h2>4. Make it Heroku ready</h2>

<p>Now that the rails files are generated, It&rsquo;s time to replace the bootstrap settings with real Heroku Dockerfile</p>

<p>Revert <code>Dockerfile</code> to simply :
<code>
FROM heroku/ruby
</code></p>

<p>Heroku uses <a href="http://puma.io/">Puma</a> so we need to add it to our <code>Gemfile</code>
```ruby</p>

<h1>Use Puma as the app server</h1>

<p>gem &lsquo;puma&rsquo;, &lsquo;~> 3.0&rsquo;
<code>
We also need to add a config file for Puma. Create</code>config/puma.rb<code>with this content (you can check [heroku doc](https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#adding-puma-to-your-application) for details)
</code>ruby
workers Integer(ENV[&lsquo;WEB_CONCURRENCY&rsquo;] || 2)
threads_count = Integer(ENV[&lsquo;RAILS_MAX_THREADS&rsquo;] || 5)
threads threads_count, threads_count</p>

<p>preload_app!</p>

<p>rackup      DefaultRackup
port        ENV[&lsquo;PORT&rsquo;]     || 3000
environment ENV[&lsquo;RACK_ENV&rsquo;] || &lsquo;development&rsquo;</p>

<p>on_worker_boot do
  # Worker specific setup for Rails 4.1+
  # See: <a href="https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#on-worker-boot</a>
  ActiveRecord::Base.establish_connection
end
```</p>

<p>It should now be possible to rebuild the container, and run the app :
```bash</p>

<h1>Rebuild the containers</h1>

<p>docker-compose build</p>

<h1>Start the rails app using the web container</h1>

<p>docker-compose up web
```
The app should be accessible at <a href="http://0.0.0.0:8080">http://0.0.0.0:8080</a></p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/rails-homepage.jpg" title="The default homepage for a new Rails application" ></p>

<h2>5. Deploying to heroku</h2>

<p>We&rsquo;re almost ready to deploy to heroku.</p>

<p>First, we need to exclude development files from our image. For this, we need to create a <code>.dockerignore</code> file with the content
<code>
.git*
db/*.sqlite3
db/*.sqlite3-journal
log/*
tmp/*
Dockerfile
.env
docker-compose.yml
docker-compose.override.yml
README.rdoc
</code>
It&rsquo;s then classic Heroku deploy commands :</p>

<p>```bash</p>

<h1>create an Heroku app</h1>

<p>heroku apps:create &lt;your-app-name></p>

<h1>And deploy to it</h1>

<p>heroku container:release &mdash;app &lt;your-app-name>
```</p>

<p>Your app should be accessible on line at <a href="https://">https://</a>&lt;your-app-name>.herokuapp.com/</p>

<p><img class="center" src="/imgs/2016-07-13-how-to-boot-a-new-rails-project-with-docker-and-heroku/deployed-to-heroku.jpg" title="The typical error message when you deploy a new Rails app to heroku" ></p>

<p>Rails does not provide a default homepage in production. But you can check the logs with</p>

<p><code>bash
heroku logs --app &lt;your-app-name&gt;
</code></p>

<h2>6. Running commands</h2>

<p>When in development mode, you might want to run rails or other commands on your source code again. The shell container exists just for that, run <code>docker-compose run shell ...</code>.
```bash</p>

<h1>For example, to update your bundle</h1>

<p>docker-compose run shell bundle update
```</p>

<h3>EDIT 2016-07-20</h3>

<p>For the moment, there&rsquo;s a catch with bundle install or update commands, as the gems are installed outside the shared volume, only Gemfile.lock will be updated, which required to run docker-compose build again &hellip; I&rsquo;ll have a look into this later and see if I can fix that.</p>

<p><code>bash
docker-compose run shell bundle update
docker-compose build
</code></p>
]]></content>
  </entry>
  
</feed>
