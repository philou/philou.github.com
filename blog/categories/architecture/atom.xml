<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-06-08T06:06:00+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[When is testing using mocks still a good idea ?]]></title>
    <link href="http://philippe.bourgau.net/when-is-testing-using-mocks-still-a-good-idea/"/>
    <updated>2018-06-07T06:29:00+02:00</updated>
    <id>http://philippe.bourgau.net/when-is-testing-using-mocks-still-a-good-idea</id>
    <content type="html"><![CDATA[<p>In the previous 7 articles of <a href="/blog/categories/how-to-avoid-mocks-series/">this series</a>, I&rsquo;ve tried my best get rid of mocks. I&rsquo;m pretty sure that using these techniques will get you a long way out of <a href="/careless-mocking-considered-harmful/">mock hell</a>. Excessive mocking leads to unmaintainable tests. Unmaintainable tests lead to low coverage. Low coverage ultimately leads to legacy code. If you haven&rsquo;t already, I encourage you to start reading from <a href="/careless-mocking-considered-harmful/">the beginning</a>.</p>

<p>One question remains though : Is it realistic to get rid of <em>all</em> mocks ? An even better question would be : Are mocks always bad ? Are there situations when mocking is the best choice ?</p>

<h2>When mocking still makes sense</h2>

<p>Let&rsquo;s to through a few examples.</p>

<h3>Testing a generic wrapper</h3>

<p>A few years ago, I had to write a service for an enterprise system. As any service, I had to ensure that it was returning nice errors. We decided to capture and wrap all errors from a few &lsquo;gate&rsquo; points in the code. We built a generic wrapper that did only delegation plus exception wrapping. In this case, it made a lot more sense to test this with a mocking framework.</p>

<p>```ruby</p>

<p>context ServiceErrorWrapper do</p>

<p>Â specify &lsquo;converts all kinds of exceptions&rsquo; do<br/>
Â Â Â failing_object = object_double(&ldquo;Failing object&rdquo;)<br/>
Â Â Â allow(failing_object).to receive(:long_computation).and_raise(Exception.new(&ldquo;Something terrible happened&rdquo;))</p>

<p>Â Â Â expect{ ServiceErrorWrapper.new(failing_object).long_computation }.to raise_error(ServiceError).with_message(&ldquo;Something terrible happened&rdquo;)<br/>
Â end</p>

<p>Â # &hellip;<br/>
end</p>

<p>```</p>

<p>Not only did we reuse the wrapper many times in my service. We also ended up using it in other services as well !</p>

<h3>Injecting a hand written in-memory fake</h3>

<p>As you might have noticed, in <a href="/get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes/">the previous article</a>, I recommended to use an in-memory fake instead of mocks. By nature, an in-memory fake is a kind of mock. Even if it is not defined by a mocking framework. (I actually think that by making mocking so easy, mocking frameworks often do more harm than good.)</p>

<blockquote><p>ðŸ’¡ By making mocking so easy, mocking frameworks often do more harm than good.</p></blockquote>

<p>Still, I used <code>const_stub(...)</code> to inject the in-memory fake.</p>

<p>```ruby</p>

<p>config.before(:each) do Â </p>

<p>Â Â stub_const(&ldquo;TwitterClient::Client&rdquo;, FakeTwitterClient.new) Â </p>

<p>end Â </p>

<p>```</p>

<p>I did this for 2 reasons :</p>

<ul>
<li>Production code can continue to use a straightforward constant</li>
<li>I don&rsquo;t risk forgetting to remove the mock at the end of its lifecycle, the framework does this for me</li>
<li>As I&rsquo;m injecting the same fake for all tests, there is not much risk of test conflict (for the moment)</li>
</ul>


<h3>Testing a cache</h3>

<p>The &ldquo;raison d'Ãªtre&rdquo; of a cache is to avoid doing something twice. It should also return the same results as if it was not there. This is by nature almost impossible to test with state based assertions. Mock frameworks are great for this situation though. Here is an example :</p>

<p>```ruby</p>

<p>context &ldquo;UsersController&rdquo; do<br/>
Â it &lsquo;caches users&rsquo; do<br/>
Â Â Â expect(User).to receive(:load).once.and_return(User.new(name: &ldquo;Joe&rdquo;))</p>

<p>Â Â Â controller.login(&lsquo;Joe&rsquo;, &lsquo;secret&rsquo;)<br/>
Â Â Â controller.login(&lsquo;Joe&rsquo;, &lsquo;secret&rsquo;)<br/>
Â end<br/>
end<br/>
```</p>

<p>The assertion could not be more explicit, we are checking that the expensive load was only done once.</p>

<h3>Legacy code</h3>

<p><a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052"><img src="../imgs/2018-06-01-when-is-testing-using-mocks-still-a-good-idea/legacy-code.jpg" alt="Michael C.Feathers explains that testing using mocks is a key practice in &quot;Working Effectively with Legacy Code&quot;" /></a></p>

<p>In <a href="https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a> <a href="https://michaelfeathers.silvrback.com/">Michael Feathers</a> explains how to exploit <a href="http://www.informit.com/articles/article.aspx?p=359417&amp;seqNum=2">&ldquo;seams&rdquo;</a> in the code to put it under test. Mocking is straightforward way to inject behavior through a seam.</p>

<p>Mocking is a pretty good starting point but we need to be careful and keep a few things in mind. Legacy or not, we must not forget that too many mocks will make tests unmaintainable !</p>

<ul>
<li>It&rsquo;s a good idea to refer to a target design or architecture blueprint to know where to inject mocks. (I&rsquo;ll write a post about this one day). This increases the chances to replace them with an in-memory fake later down the road.</li>
<li>Plan to replace the mocks with a better design as soon as possible.</li>
</ul>


<h3>It depends &hellip;</h3>

<p>As with anything in software, there is no absolute rule about mocking. Even if I prefer not to 99% of the time, there are situation when testing using mocks is the thing to do. Knowing the risks, it&rsquo;s up to you to decide !</p>

<h2>If using a mock, prefer spy / proxies</h2>

<p><img src="../imgs/2018-06-01-when-is-testing-using-mocks-still-a-good-idea/proxy-plug.jpg" alt="Spies and proxies make testing using mocks less intrusive" /></p>

<p>As I explained in previous posts, mocks duplicate behavior. If we could use mocks without duplicating behavior, they would do less harm.</p>

<p>It turns out there is a flavor of mocks for that : <a href="https://martinfowler.com/articles/mocksArentStubs.html">spies</a> and <a href="https://relishapp.com/rspec/rspec-mocks/docs/configuring-responses/calling-the-original-implementation">overlooked proxies</a>. Proxies do the real thing but also record the calls and return values. It&rsquo;s as non-intrusive as mocks can be.</p>

<blockquote><p>ðŸ’¡ Proxy mocks are as unintrusive as mocks can be.</p></blockquote>

<p>For example, here is how our cache test would look like using a proxy :</p>

<p>```ruby</p>

<p>context &ldquo;UsersController&rdquo; do<br/>
Â it &lsquo;caches users&rsquo; do<br/>
Â Â Â allow(User).to receive(:load).and_call_original</p>

<p>Â Â Â controller.login(&lsquo;Joe&rsquo;, &lsquo;secret&rsquo;)<br/>
Â Â Â controller.login(&lsquo;Joe&rsquo;, &lsquo;secret&rsquo;)</p>

<p>Â Â Â expect(User).to have_received(:load).once<br/>
Â end<br/>
end<br/>
```</p>

<p>It&rsquo;s more verbose, but simpler. Most mock frameworks provide some form of spy or proxies. A few years ago, I also wrote <a href="http://philippe.bourgau.net/rspecproxies">rspecproxies</a>, a wrapper on top of <a href="http://rspec.info/">rspec</a> to make this easier.</p>

<h2>This is the end</h2>

<p>This was the 8th and last post in a series about how to avoid mocks. Before closing here is a list of other references about the topic.</p>

<ul>
<li>In the <a href="https://www.youtube.com/watch?v=9LfmrkyP81M">RailsConf 2014 keynote</a>, <a href="https://twitter.com/dhh">DHH </a> explains how mocking made their test harness unreliable.</li>
<li><a href="https://martinfowler.com/articles/is-tdd-dead/">Is TDD dead</a> is a well known online discussion about the Classic vs Mockist TDD approach</li>
<li>Have a look at what <a href="https://blog.cleancoder.com/">Uncle Bob</a> says about <a href="http://blog.cleancoder.com/uncle-bob/2014/05/10/WhenToMock.html">When To Mock</a></li>
<li>For JS expert <a href="https://medium.com/@_ericelliott">Eric Elliott</a>, <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">Mocking is a Code Smell</a></li>
<li>In this talk  <a href="https://skillsmatter.com/skillscasts/9971-testable-software-architecture-with-aslak-hellesoy">Testable Architecture talk</a>, <a href="https://twitter.com/aslak_hellesoy">Aslak HellesÃ¸y</a> explains how to build a full architecture for fast tests</li>
<li><a href="http://www.jamesshore.com/">James Shore</a> recently published a full pattern language entitled <a href="http://www.jamesshore.com/Blog/Testing-Without-Mocks.html">Testing Without Mock</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Get rid of mock maintenance with full fledged in-memory fakes]]></title>
    <link href="http://philippe.bourgau.net/get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes/"/>
    <updated>2018-05-31T19:15:00+02:00</updated>
    <id>http://philippe.bourgau.net/get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes</id>
    <content type="html"><![CDATA[<p><a href="/avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture/">Last week&rsquo;s post</a> was about how <a href="http://alistair.cockburn.us/Hexagonal+architecture">hexagonal architecture</a> results in fast, mock-free tests around your core domain. Unfortunately, that does not remove all mocks, yet it groups them in the same, less critical, zone. In last week&rsquo;s code sample, this was the controller. I concluded that at least, this was easier to manage. Let&rsquo;s see how.</p>

<p><img src="../imgs/2018-05-28-get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes/in-memory-fake.jpg" alt="Hand written 'In-memory fake' with memory replaced by a RAM board" /></p>

<p>This is the 7th post in <a href="/blog/categories/how-to-avoid-mocks-series/">a series about avoiding mocks</a>. If you haven&rsquo;t, you might start from <a href="/careless-mocking-considered-harmful/">the beginning</a>.</p>

<h2>Mock concentration</h2>

<p>Let&rsquo;s get back to the <a href="/avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture/">last post</a>&rsquo;s code sample. As a reminder, it&rsquo;s a very basic TODO app built on <a href="https://rubyonrails.org/">Rails</a>. I extracted the domain part, the tasks, in a core domain area. This allowed to push all mocks out of this section. A consequence though, is that all mocks gathered in the controller test. Here is the controller code :</p>

<p>```ruby</p>

<p>require &lsquo;core/task'<br/>
require 'infrastructure/task_repo&rsquo;</p>

<p>class TasksController &lt; ApplicationController<br/>
Â before_action :set_task, only: [:show, :edit, :update, :destroy]</p>

<p>Â # GET /tasks<br/>
Â def index<br/>
Â Â Â @tasks = Infrastructure::TaskRepo.all<br/>
Â end</p>

<p>Â # GET /tasks/1<br/>
Â def show<br/>
Â end</p>

<p>Â # GET /tasks/new<br/>
Â def new<br/>
Â Â Â @task = Core::Task.new<br/>
Â end</p>

<p>Â # GET /tasks/1/edit<br/>
Â def edit<br/>
Â end</p>

<p>Â # POST /tasks<br/>
Â def create<br/>
Â Â Â begin<br/>
Â Â Â Â Â @task = Core::Task.new(task_params)<br/>
Â Â Â Â Â Infrastructure::TaskRepo.save(@task)</p>

<p>Â Â Â Â Â redirect_to task_url(@task.db_id), notice: &lsquo;Task was successfully created.&rsquo;</p>

<p>Â Â Â rescue ArgumentError<br/>
Â Â Â Â Â render :new<br/>
Â Â Â end<br/>
Â end</p>

<p>Â # PATCH/PUT /tasks/1<br/>
Â def update<br/>
Â Â Â begin<br/>
Â Â Â Â Â @task.update(task_params)<br/>
Â Â Â Â Â Infrastructure::TaskRepo.save(@task)</p>

<p>Â Â Â Â Â redirect_to task_url(@task.db_id), notice: &lsquo;Task was successfully updated.&rsquo;</p>

<p>Â Â Â rescue ArgumentError<br/>
Â Â Â Â Â render :edit<br/>
Â Â Â end<br/>
Â end</p>

<p>Â # DELETE /tasks/1<br/>
Â def destroy<br/>
Â Â Â Infrastructure::TaskRepo.delete(@task)<br/>
Â Â Â redirect_to tasks_url, notice: &lsquo;Task was successfully destroyed.'<br/>
Â end</p>

<p>Â private<br/>
Â Â Â def set_task<br/>
Â Â Â Â Â @task = Infrastructure::TaskRepo.load(params[:id])<br/>
Â Â Â Â Â @task.notify_when_done do |task|<br/>
Â Â Â Â Â Â Â TwitterClient::Client.update(task.description)<br/>
Â Â Â Â Â end<br/>
Â Â Â end</p>

<p>Â Â Â # Never trust parameters from the scary internet, only allow the white list through.<br/>
Â Â Â def task_params<br/>
Â Â Â Â Â params.permit(:description, :done)<br/>
Â Â Â end<br/>
end</p>

<p>```</p>

<p>The controller is now dealing both with the Twitter connection and the database. This is visible in the controller test :</p>

<p>```ruby</p>

<p>require &lsquo;rails_helper&rsquo;</p>

<p>RSpec.describe TasksController, type: :controller do</p>

<p>Â before :each do<br/>
Â Â Â allow(TwitterClient::Client).to receive(:update)<br/>
Â end</p>

<p>Â Â # &hellip;</p>

<p>Â describe &ldquo;PUT #update&rdquo; do<br/>
Â Â Â context &ldquo;with valid params&rdquo; do<br/>
Â Â Â Â Â let(:new_attributes) {<br/>
Â Â Â Â Â Â Â {done: true}<br/>
Â Â Â Â Â }</p>

<p>Â Â Â Â Â it &ldquo;updates the requested task&rdquo; do<br/>
Â Â Â Â Â Â Â task = Task.create! valid_attributes<br/>
Â Â Â Â Â Â Â put :update, params: new_attributes.merge(id: task.to_param)<br/>
Â Â Â Â Â Â Â task.reload<br/>
Â Â Â Â Â Â Â expect(task).to be_done<br/>
Â Â Â Â Â end</p>

<p>Â Â Â Â Â it &ldquo;tweets about completed tasks&rdquo; do<br/>
Â Â Â Â Â Â Â task = Task.create! valid_attributes</p>

<p>Â Â Â Â Â Â Â expect(TwitterClient::Client).to receive(:update).with(task.description)</p>

<p>Â Â Â Â Â Â Â put :update, params: {id: task.to_param, done: true}<br/>
Â Â Â Â Â end</p>

<p>Â Â Â Â Â it &ldquo;redirects to the task&rdquo; do<br/>
Â Â Â Â Â Â Â task = Task.create! valid_attributes<br/>
Â Â Â Â Â Â Â put :update, params: valid_attributes.merge(id: task.to_param)<br/>
Â Â Â Â Â Â Â expect(response).to redirect_to(task_url(task.id))<br/>
Â Â Â Â Â end<br/>
Â Â Â end</p>

<p>Â Â Â # &hellip;Â </p>

<p>Â Â end<br/>
end</p>

<p>```</p>

<p>We need to <a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da">stub out</a> the twitter API for most tests. We are also still using a mock to verify that the tweet is sent. Finally, as we can see from the test execution times, we are still using the database in some tests.</p>

<p><img src="../imgs/2018-05-28-get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes/test-timings.jpg" alt="Screen capture of the tests execution time" /></p>

<p>If the project grew large this would become an issue. Sadly, mocking is often the fix people jump on &hellip;</p>

<blockquote><p>ðŸ’¡ Mocking is the unfortunate quick fix to slow tests.</p></blockquote>

<p>From a mocking point of view, our current controller test can seem worse than before ! There&rsquo;s something pretty effective we can do though !</p>

<h2>In memory fakes</h2>

<p>Instead of stubbing and mocking in every test, let&rsquo;s write a full fledged in-memory <a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da">fake</a> that does the job we need. We could then install it once and for all, and forget about it !</p>

<p>Actually, this is nothing new. This is exactly what Rails provides out of the box with <code>ActionMailer::Base.delivery_method = :test</code>.</p>

<p>Here&rsquo;s how we could do the same thing for our Twitter Client.</p>

<h6>spec/rails_helper.rb</h6>

<p>```ruby</p>

<p>class FakeTwitterClient<br/>
Â def initialize<br/>
Â Â Â @tweets = []<br/>
Â end</p>

<p>Â attr_accessor :tweets</p>

<p>Â def update(message)<br/>
Â Â Â @tweets.push(message)<br/>
Â end<br/>
end</p>

<p>RSpec.configure do |config|</p>

<p>Â Â # &hellip;<br/>
Â config.before(:each) do<br/>
Â Â Â stub_const(&ldquo;TwitterClient::Client&rdquo;, FakeTwitterClient.new)<br/>
Â end<br/>
end<br/>
```</p>

<h6>spec/controllers/tasks_controller_spec.rb</h6>

<p>```ruby</p>

<p>it &ldquo;tweets about completed tasks&rdquo; do<br/>
Â task = Task.create! valid_attributes</p>

<p>Â put :update, params: {id: task.to_param, done: true}</p>

<p>Â expect(TwitterClient::Client.tweets).to include(task.description)<br/>
end<br/>
```</p>

<p>Simple isn&rsquo;t it ?</p>

<h2>Wait a sec &hellip;</h2>

<p>There&rsquo;s a catch though &hellip; How do we make sure that this fake is behaving the same way as the real thing ?</p>

<p>Let&rsquo;s run the same tests on both ! We could mimic the twitter API in our fake, but that might not be a great idea. Do you remember the moto &ldquo;Always wrap your 3rd parties&rdquo; ? It takes all its meaning here, for 2 reasons.</p>

<p>The first is to make faking easier. We can build a minimal wrapper API that is just enough for our use. By keeping this interface small, we&rsquo;ll make it a lot easier to fake.</p>

<p>The second reason is that we can write real integration tests on the 3rd party through this wrapper. They&rsquo;d look like ordinary unit tests, except that they&rsquo;d end up calling the real 3rd party in a sandbox. They are usually pretty slow, but as 3rd parties don&rsquo;t change everyday, that&rsquo;s ok. We can ensure up-front that integration will go well. As a bonus, we can be very fast to detect and contain changes to online services. (I&rsquo;m looking at you <a href="https://en.wikipedia.org/wiki/Web_scraping">Scrappers</a>!)</p>

<p>Here is what it would look like for our Twitter client :</p>

<h6>lib/infrastructure/twitter_client.rb</h6>

<p>```ruby</p>

<p>class FakeTwitterClient<br/>
Â def initialize<br/>
Â Â Â @tweets = []<br/>
Â end</p>

<p>Â attr_accessor :tweets</p>

<p>Â def tweet(message)<br/>
Â Â Â @tweets.push(message)<br/>
Â end</p>

<p>Â def search_tweets(text)<br/>
Â Â Â @tweets.select {|tweet| tweet.include?(text) }<br/>
Â end<br/>
end</p>

<p>class RealTwitterClient<br/>
Â def initialize(&amp;block)<br/>
Â Â Â @client = Twitter::REST::Client.new(&amp;block)<br/>
Â end</p>

<p>Â def tweet(message)<br/>
Â Â Â @client.update(message)<br/>
Â end</p>

<p>Â def search_tweets(text)<br/>
Â Â Â @client.search(&ldquo;from:test_user #{text}&rdquo;)<br/>
Â end<br/>
end</p>

<p>```</p>

<p>As you can see, we renamed <code>update</code> to <code>tweet</code> in the wrapper. We&rsquo;d have to update the calls accordingly. Let&rsquo;s look at the tests.</p>

<h6>spec/lib/Infrastructure/twitter_client_spec.rb</h6>

<p>```ruby</p>

<p>require &lsquo;rails_helper'<br/>
require 'infrastructure/twitter_client'<br/>
require 'securerandom&rsquo;</p>

<p>RSpec.shared_examples &ldquo;a twitter client&rdquo; do |new_client_instance|<br/>
Â let(:client) { new_client_instance }<br/>
Â it &ldquo;sends tweets&rdquo; do<br/>
Â Â Â token = SecureRandom.uuid<br/>
Â Â Â message = &ldquo;Philippe was here #{token}"<br/>
Â Â Â client.tweet(message)</p>

<p>Â Â Â expect(client.search_tweets(token)).to include(message)<br/>
Â end<br/>
end</p>

<p>context FakeTwitterClient do<br/>
Â it_behaves_like &ldquo;a twitter client&rdquo;, FakeTwitterClient.new<br/>
end</p>

<p>context RealTwitterClient, integration: true, speed: :slow do<br/>
Â it_behaves_like &ldquo;a twitter client&rdquo;, (RealTwitterClient.new do |config|<br/>
Â Â Â config.consumer_key Â Â Â Â Â Â Â = &ldquo;TEST_CONSUMER_KEY"<br/>
Â Â Â config.consumer_secret Â Â Â Â = "TEST_CONSUMER_SECRET"<br/>
Â Â Â config.access_token Â Â Â Â Â Â Â = "TEST_ACCESS_TOKEN"<br/>
Â Â Â config.access_token_secret = "TEST_ACCESS_SECRET"<br/>
Â end)<br/>
end</p>

<p>```</p>

<p>We had to add a search method to our interface for the sake of testing. This should remain &ldquo;For testing only&rdquo;. We&rsquo;d also adapt the controller test to use this <code>search_tweets</code> method.</p>

<p>Let&rsquo;s look at where we stand now. We&rsquo;re injecting each mock only once. Tests are fast yet straightforward, almost as if they were testing the real thing. Doing so, we&rsquo;ve split our system in cohesive parts and we&rsquo;ve wrapped our 3rd parties. We&rsquo;ve actually done a lot more than removing mocks ! <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">Mocking really is a design smell</a>.</p>

<blockquote><p>ðŸ’¡ Merciless mock hunting will improve the design of your system !</p></blockquote>

<h2>Last word about implementation</h2>

<p>Sometimes, this 3rd party wrapper can become pretty complicated. Try to reuse as much of it as possible between the real and the fake. For example, an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>, like ActiveRecord for example, is a wrapper around the database. Reimplementing a fake ORM would be real challenge. We&rsquo;re far better <a href="http://philippe.bourgau.net/5-minutes-hack-to-speed-up-rspec-in-rails-5-using-in-memory-sqlite/">plugin it on top of SQLite</a> instead !</p>

<h2>References</h2>

<p>Smart people have already spoken and written about this subject. If you want to learn more, I recommend that you have a look at <a href="https://twitter.com/aslak_hellesoy">Aslak HellesÃ¸y</a>&rsquo;s <a href="https://skillsmatter.com/skillscasts/9971-testable-software-architecture-with-aslak-hellesoy">Testable Architecture talk</a>. <a href="http://www.jamesshore.com/">James Shore</a>, the author of <a href="https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675/ref=sr_1_1?ie=UTF8&amp;qid=1527568833&amp;sr=8-1&amp;keywords=the+art+of+agile+development">The Art of Agile Development</a>, also wrote a pattern language called <a href="http://www.jamesshore.com/Blog/Testing-Without-Mocks.html">Testing Without Mock</a>.</p>

<h2>Next week</h2>

<p>This was the 7th blog post in <a href="http://philippe.bourgau.net/blog/categories/how-to-avoid-mocks-series/">a series about how to avoid mocks</a>. Hopefully, I&rsquo;m reaching the end ! <a href="/when-is-testing-using-mocks-still-a-good-idea/">Next week&rsquo;s post</a> should be the last in series, and deal with a few remaining points. What to do when you really need a mock ? What about mocking and legacy code ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Avoid mocks and test your core domain faster with Hexagonal Architecture]]></title>
    <link href="http://philippe.bourgau.net/avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture/"/>
    <updated>2018-05-24T06:43:00+02:00</updated>
    <id>http://philippe.bourgau.net/avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture</id>
    <content type="html"><![CDATA[<p>As I&rsquo;ve written in my last few posts, we can get a long way to avoid mocks with small scale coding best practices. Unfortunately, when systems reach a certain size, we need something at architecture scale.</p>

<p>This is the 6th post of a <a href="/blog/categories/how-to-avoid-mocks-series/">series about avoiding mocks</a>. If you haven&rsquo;t, you can start by <a href="/careless-mocking-considered-harmful/">the beginning</a>.</p>

<p><img src="../imgs/2018-05-24-avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture/hexagonal-building.jpg" alt="A drawing of a hexagon-shaped building" /></p>

<h2>Why do we end up with mocks in large systems ?</h2>

<p>A few years ago, I joined a team working in a legacy system. We wanted to apply <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and refactoring. As expected, adding tests legacy code proved a real challenge. With a lot of effort we could manage to add a few. Unfortunately, this did not seem to have any positive effect on our maintainability ! The tests we were writing all involved a lot of mocking. The system was such a large mass of spaghetti code that there was no clear place to mock. We were actually mocking where it seemed the easiest on a test by test basis. We were making progress at small scale, but the big picture was not improving at all !</p>

<p>Large systems are beasts with many faces. They Â involve a lot of IOs. They write and read data from the disk and databases. They call 3rd parties and remote services.</p>

<p>As we test these large systems, we&rsquo;ll need to stub out these IOs. Even if the tests are fast enough, we usually don&rsquo;t want to call external services for real. Most of the time though, tests are slow. That&rsquo;s 2 reasons why end up adding some mocks.</p>

<p>Here comes the nasty part. These large systems are so complex that we, developers, don&rsquo;t have the full picture. When we test, we tend to mock at different places, depending on our knowledge. This is bad for maintenance. Mocks duplicate production code behavior. When many different mocks are in place to isolate an external dependency, we end up with &lsquo;n&rsquo; versions of the code. That&rsquo;s a nightmare to refactor !</p>

<blockquote><p>ðŸ’¡ When many different mocks are in place to isolate an external dependency, we end up with &lsquo;n&rsquo; versions of the code !</p></blockquote>

<h2>Hexagonal architecture to the rescue</h2>

<p><a href="http://alistair.cockburn.us/Hexagonal+architecture">Alistair Cockburn</a> coined the term. The idea is pretty simple : Â isolate a piece of code from all dependencies. This is particularly useful for the core functional areas. With this in place, it becomes straightforward (and fast) to test the core domain logic.</p>

<p>To main techniques to isolate a piece of code from any dependency areÂ :</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection</a></li>
<li><a href="https://en.wikipedia.org/wiki/Observer_pattern">Observers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapters</a></li>
</ul>


<p>It&rsquo;s also possible to split a system in many &lsquo;hexagons&rsquo; and glue them together with adapters at startup. If you want to learn more on this style of architecture, have a look into the <a href="https://www.infoq.com/articles/ddd-contextmapping">Domain Driven Design lore</a>. This community has been building systems this way for years now.</p>

<h2>Enough talk, show me the code !</h2>

<p>This post was the occasion to try to inject a Hexagonal Architecture and a dash of DDD in a Rails application. There&rsquo;s one caveat though : DDD shines on complex systems. Unfortunately, large and complex systems make very poor didactic examples. The following code highlights the gains about mocking. We would not use DDD for such a small app in real life.</p>

<h3>The starting point</h3>

<p>I chose a simple TODO app. I started by generating a scaffold for a Task with a description and a done/not-done status. As third party interaction, completing a task sends an automatic tweet. Here is the only specific code I wrote on top of the Rails scaffold :</p>

<h6>app/models/task.rb</h6>

<p>```ruby
class Task &lt; ApplicationRecord
  include ActiveModel::Dirty</p>

<p>  validates :description, presence: true</p>

<p>  before_save :tweet_if_done</p>

<p>  private
  def tweet_if_done</p>

<pre><code>if done_changed?
  TwitterClient::Client.update(self.description)
end
</code></pre>

<p>  end
end
```</p>

<p>Thanks Jason Charnes for the <a href="https://jasoncharnes.com/changed-attributes-rails/">change attribute technique</a>.</p>

<h6>spec/models/task_spec.rb</h6>

<p>```ruby
require &lsquo;rails_helper&rsquo;</p>

<p>RSpec.describe Task, type: :model do</p>

<p>  it &ldquo;is valid with all attributes set&rdquo; do</p>

<pre><code>expect(Task.create(description: "Finish presentation", done: false)).to be_valid
</code></pre>

<p>  end</p>

<p>  it &ldquo;requires a description&rdquo; do</p>

<pre><code>expect(Task.create(description: nil, done: false)).to be_invalid
expect(Task.create(description: "", done: false)).to be_invalid
</code></pre>

<p>  end</p>

<p>  it &ldquo;tweets when a task is finished&rdquo; do</p>

<pre><code>task = Task.create(description: "Wash the car", done: false)

expect(TwitterClient::Client).to receive(:update).with("Wash the car")

task.done = true
task.save
</code></pre>

<p>  end
end
```</p>

<p>This is pretty simple and to the point !</p>

<h3>5 years later</h3>

<p>Now let&rsquo;s imagine that the app grew to tens of thousands of lines. We added a lot of features to the app, which transformed the TODO domain into a very complex thing. Now suppose that, for the sake of maintenance, we want to isolate the domain logic into its own hexagon. Unlike traditional Rails ActiveRecords, we want to make it independent from the database. We also want it to be independent from the Twitter API.</p>

<p>Here is what the code might look like.</p>

<h6>lib/core/task.rb</h6>

<p>First, we have a core task class, independent from anything else. The Core module is our hexagon.</p>

<p>```ruby
module Core
  class Task</p>

<pre><code>attr_reader :description
attr_accessor :db_id

def initialize(attributes = {})
  @description= "What do you need to do ?"
  @done = false
  @done_subscribers = []

  self.update(attributes)
end

def done?
  @done
end

def mark_as_done
  @done = true
  @done_subscribers.each {|proc| proc.call(self) }
end

def update(attributes={})
  self.description= attributes[:description] unless attributes[:description].nil?
  self.mark_as_done if attributes[:done]
end

def notify_when_done(&amp;proc)
  @done_subscribers.push(proc)
end

def description=(desc)
  raise ArgumentError.new("Task description cannot be blank") if desc.blank?

  @description = desc
end
</code></pre>

<p>  end
end
```</p>

<p>As we can see, it contains only domain logic and nothing else.</p>

<h6># spec/lib/core/task_spec.rb</h6>

<p>Here is the corresponding test, fast, mock-free and independent from the database and any external system.</p>

<p>```ruby
require &lsquo;rails_helper&rsquo;
require &lsquo;core/task&rsquo;</p>

<p>context &lsquo;Task&rsquo; do</p>

<p>  let(:task) { Core::Task.new}</p>

<p>  specify &lsquo;is not done by default&rsquo; do</p>

<pre><code>expect(task).not_to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;comes with a default description&rsquo; do</p>

<pre><code>expect(task.description).not_to be_blank
</code></pre>

<p>  end</p>

<p>  specify &lsquo;it can be initialized from a hash&rsquo; do</p>

<pre><code>task = Core::Task.new(description: "Old description", done: true)

expect(task.description).to eq("Old description")
expect(task).to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;can have a custom description&rsquo; do</p>

<pre><code>task.description= "Clean up the house"
expect(task.description).to eq("Clean up the house")
</code></pre>

<p>  end</p>

<p>  specify &lsquo;forbids empty descriptions&rsquo; do</p>

<pre><code>expect{task.description = nil }.to raise_error(ArgumentError)
expect{task.description = "" }.to raise_error(ArgumentError)
</code></pre>

<p>  end</p>

<p>  specify &lsquo;can be done&rsquo; do</p>

<pre><code>task.mark_as_done
expect(task).to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;publishes when done&rsquo; do</p>

<pre><code>done_task = nil
task.notify_when_done {|t| done_task = t}

task.mark_as_done

expect(done_task).to be(task)
</code></pre>

<p>  end</p>

<p>  specify &lsquo;can be updated with a hash&rsquo; do</p>

<pre><code>task.update(description: "New description", done: true)

expect(task.description).to eq("New description")
expect(task).to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;has no DB id by default&rsquo; do</p>

<pre><code>expect(task.db_id).to be_nil
</code></pre>

<p>  end
end
```</p>

<h6># lib/infrastructure/task_repo.rb</h6>

<p>To read and save with the database, we now go through an adapter. This is not considered to be part of our core domain.</p>

<p>```ruby
module Infrastructure
  class TaskRepo</p>

<pre><code>def self.all
  Task.all.map do |db_task|
    from_db(db_task)
  end
end

def self.load(db_id)
  from_db(Task.find(db_id))
end

def self.save(task)
  if task.db_id.nil?
    db_task = Task.create!(to_db_attributes(task))
    task.db_id = db_task.id
  else
    db_task = Task.find(task.db_id)
    db_task.update!(to_db_attributes(task))
  end
  task
end

def self.delete(task)
  unless task.db_id.nil?
    db_task = Task.find(task.db_id)
    db_task.destroy!
    task.db_id = nil
  end
end

private

def self.to_db_attributes(task)
  {description: task.description, done: task.done?}
end

def self.from_db(db_task)
  result = Core::Task.new
  result.db_id = db_task.id
  result.description = db_task.description
  result.mark_as_done if db_task.done?
  result
end
</code></pre>

<p>  end
end
```</p>

<h6># app/controllers/tasks_controller.rb</h6>

<p>Finally, all the pieces interact together in the controller. This controller basically does what the previous version was, it&rsquo;s just using different classes. Obviously, we&rsquo;ll need to adapt the views and the tests.</p>

<p>```ruby
require &lsquo;core/task&rsquo;
require &lsquo;infrastructure/task_repo&rsquo;</p>

<p>class TasksController &lt; ApplicationController
  before_action :set_task, only: [:show, :edit, :update, :destroy]</p>

<p>  # GET /tasks
  def index</p>

<pre><code>@tasks = Infrastructure::TaskRepo.all
</code></pre>

<p>  end</p>

<p>  # GET /tasks/1
  def show
  end</p>

<p>  # GET /tasks/new
  def new</p>

<pre><code>@task = Core::Task.new
</code></pre>

<p>  end</p>

<p>  # GET /tasks/1/edit
  def edit
  end</p>

<p>  # POST /tasks
  def create</p>

<pre><code>begin
  @task = Core::Task.new(task_params)
  Infrastructure::TaskRepo.save(@task)

  redirect_to task_url(@task.db_id), notice: 'Task was successfully created.'

rescue ArgumentError
  render :new
end
</code></pre>

<p>  end</p>

<p>  # PATCH/PUT /tasks/1
  def update</p>

<pre><code>begin
  @task.update(task_params)
  Infrastructure::TaskRepo.save(@task)

  redirect_to task_url(@task.db_id), notice: 'Task was successfully updated.'

rescue ArgumentError
  render :edit
end
</code></pre>

<p>  end</p>

<p>  # DELETE /tasks/1
  def destroy</p>

<pre><code>Infrastructure::TaskRepo.delete(@task)
redirect_to tasks_url, notice: 'Task was successfully destroyed.'
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def set_task
  @task = Infrastructure::TaskRepo.load(params[:id])
  @task.notify_when_done do |task|
    TwitterClient::Client.update(task.description)
  end
end

# Never trust parameters from the scary internet, only allow the white list through.
def task_params
  params.permit(:description, :done)
end
</code></pre>

<p>end
```</p>

<p>The main gain here is that our core domain, our most valuable asset is now easy to test without mocks. This means that we are able to write and execute fast tests for this area of the code. This puts us in a great position to increase our competitive advantage in our core business !</p>

<blockquote><p>ðŸ’¡ By keeping your tests around your core domain fast, Hexagonal Architecture increases your competitive advantage.</p></blockquote>

<p>As you can see, we are now wiring everything together at the controller level. We could later build a facade to isolate the controller from the inside of our domain. A <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">presenter</a> might do, but it seemed over-engineered, even in this made up example. (I&rsquo;ll post something about that some day)</p>

<h2>Next post</h2>

<p>As we can deduce from the controller code above, we still have to use fakes or mocks when testing the controller. The good thing though is that this is now more local which already makes mocking less of an issue. If a mock is used in less tests, it&rsquo;s easier to use the same mock everywhere ! This is a great opportunity for simplifying test setup, as we&rsquo;ll see in the <a href="/get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes/">next post about in-memory fakes</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Rails teaches us about building platforms and frameworks]]></title>
    <link href="http://philippe.bourgau.net/what-rails-teaches-us-about-building-platforms-and-frameworks/"/>
    <updated>2017-10-09T09:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/what-rails-teaches-us-about-building-platforms-and-frameworks</id>
    <content type="html"><![CDATA[<p>More than ever, the cheapest way to build a framework is to refactor it out of a specific app.</p>

<p><a href="http://rubyonrails.org/">Rails</a> is a web development server side framework built in <a href="https://www.ruby-lang.org/">Ruby</a>. It&rsquo;s been and remains very popular. It set the tone for all the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> web frameworks that followed. People have ported it to many other languages. Rails is now in it&rsquo;s 5th version, what is less known is how it was built in the first place.</p>

<p><img src="../imgs/2017-10-09-what-rails-teaches-us-about-building-platforms-and-frameworks/train-and-rails.jpg" alt="Drawing of a train being detached from its rails" /></p>

<h2>The story of Rails</h2>

<p><a href="http://david.heinemeierhansson.com/">David Heinemeier Hansson</a>, the creator of Rails, is a cult in the Ruby community. You can find the history of Rails at many places. If you have a bit of time, read <a href="https://www.wired.com/2008/02/mf-signals/?currentPage=all">this great article</a> from Wired. If you don&rsquo;t have a lot of time, here is a summary.</p>

<p><a href="https://twitter.com/jasonfried?lang=fr">Jason Fried</a> and DHH were working at <a href="https://37signals.com/">37signals</a>. They were working on project management app for small businesses called <a href="https://basecamp.com/">Basecamp</a>. After releasing the first version of Basecamp, DHH extracted and open sourced Rails out of it.</p>

<p>37signals later then re-used Rails to build other apps like Campfire, Highrise and Backpack.</p>

<p>We all know the end of the story, Rails adoption exploded. Many successful companies like <a href="https://github.com/">Github</a>, <a href="https://www.airbnb.com/">Airbnb</a>, <a href="https://twitter.com">Twitter</a> &amp; <a href="https://www.shopify.com">Shopify</a> have used it. It evolved a lot, through the darwinism of open source. Today, Rails might not be the latest and coolest web framework, but it is still very productive and popular.</p>

<p><img src="../imgs/2017-10-09-what-rails-teaches-us-about-building-platforms-and-frameworks/rails-logo.jpg" alt="The Rails logo" /></p>

<h2>Economic sense</h2>

<p>To summarize, here is how they did it :</p>

<ol>
<li>Built a specific app, and monetized it</li>
<li>Extracted an open source framework from it</li>
<li>Built other apps on the framework</li>
</ol>


<p>If you are not a programmers, you&rsquo;re likely to assume that the cost of reusing software is negligible. If you are a programmer, I&rsquo;ll ask you to assume that it is for a while. Â Under this hypothesis, all they did makes a lot of business sense :</p>

<ul>
<li>Building a specific app first is the fastest path to paying customers. Building a framework first would need more work.</li>
<li>Once you have paying customers, you&rsquo;ve got money to fuel further work.</li>
<li>In particular, you have money to finance the extraction of an open source framework.</li>
<li>Putting the framework open source increases its reusability through bug reports and contributions.</li>
<li>Building the next app is even easier thanks to a mature framework and the revenues from the original app</li>
</ul>


<blockquote><p>ðŸ’¡ Once you have paying customers, you&rsquo;ve got money to fuel further work.</p></blockquote>

<h2>How can it work ?</h2>

<p><a href="https://www.amazon.com/Rework-Jason-Fried/dp/0307463745/ref=sr_1_1?ie=UTF8&amp;qid=1507610064&amp;sr=8-1&amp;keywords=rework"><img src="../imgs/2017-10-09-what-rails-teaches-us-about-building-platforms-and-frameworks/rework-cover.jpg" alt="Cover of Rework book" /></a></p>

<p>Ok, enough for common sense. Let&rsquo;s see what happens when you take into account the real cost of changing software ? All software developers know that changing software is far from cheap. Very often, it&rsquo;s more expensive to adapt than to rebuild</p>

<p>So how did the Rails guys manage it ? Rails has 3 specificities that explain that :</p>

<ul>
<li>Rails has automated testing built in and out</li>
<li>Basecamp guys are agile with a lower &lsquo;a&rsquo;. They don&rsquo;t follow Scrum or any method. Read <a href="https://basecamp.com/about/books">their books</a> and you&rsquo;ll understand how agile they are. They follow principles like KISS, YAGNI, Lean startup discovery &hellip;</li>
<li>Finally, it was open sourced !</li>
</ul>


<p>Agile principles and technical practices is what allowed them to take the common-sense path.</p>

<blockquote><p>ðŸ’¡ Thanks to agile practices, the cheapest way to build a framework is to extract it from a specific app.</p></blockquote>

<h2>Open question</h2>

<p>If it is possible to do the thing that makes the most economic sense, why isn&rsquo;t it the default way ? Why are so many of us still losing a ton of money writing large frameworks and platforms up-front ? How could we get large companies to adopt the more nimble &lsquo;basecamp&rsquo; way ?</p>

<p><em>If you have remarks, answers or different point of views, I&rsquo;d love to read your comment !</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Incremental architecture, a cure against architecture astronauts]]></title>
    <link href="http://philippe.bourgau.net/incremental-architecture-a-cure-against-architecture-astronauts/"/>
    <updated>2017-04-24T06:52:00+02:00</updated>
    <id>http://philippe.bourgau.net/incremental-architecture-a-cure-against-architecture-astronauts</id>
    <content type="html"><![CDATA[<p>Back in 2001, when I started to code for a living, fresh out of school, I was mainly doing a form of <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a>. After a few months of maintaining my own mess, I started to recall my university lessons : we should be doing design before coding &hellip;</p>

<p>When I was asked to re-engineer the &lsquo;wizards UI&rsquo;, I paused my coding to design something clean from scratch. It worked quite well at first : the overall code was a lot simpler and contained a lot less duplication than before. Seeing this new shiny UI, product people asked for new features. Unfortunately, I hadn&rsquo;t thought of them when designing this little framework. I was almost back at my initial situation.</p>

<p>That&rsquo;s how I started to look for another way to design software. At about the same time the <a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_3?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1493096057&amp;sr=8-3&amp;keywords=extreme+programming">eXtreme Programming book</a> fell into my hands. That&rsquo;s where I discovered the idea of incremental design and architecture.</p>

<p><a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_3?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1493096057&amp;sr=8-3&amp;keywords=extreme+programming"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/xp-1ed.jpg" alt="Front cover of the first edition of the XP book" /></a></p>

<h2>What is Incremental Archi</h2>

<p>Let&rsquo;s start with the antithesis of incremental architecture :</p>

<h3>Astronaut Architecture</h3>

<p>The term &ldquo;Architecture Astronaut&rdquo; was coined by <a href="https://www.joelonsoftware.com">Joel Spolsky</a> back in 2001. If you haven&rsquo;t read this <a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">classic post</a> yet, I strongly encourage you to do so. Basically, he explains that we should not be impressed by architects going over their heads talking about too abstract stuff.</p>

<p>Incremental is the exact opposite of astronaut architecture</p>

<h3>Two Schools to Software Architecture</h3>

<p>Traditional architecture is about taking up-front choices that will be difficult to change. Incremental architecture is about preparing for non-stop change and taking decisions as late as possible.</p>

<p>The idea in incremental architecture is really simple : keep your code simple, clean and automatically tested in order to be able to simply adapt your code and architecture when definitely needed.</p>

<h3>Pros and Cons of incremental architecture</h3>

<p>The first reaction of most software engineers (me included, remember how my story started) is that it can only work on trivial stuff. After practicing it for about a decade, I am now convinced it works most of the time. I&rsquo;m not alone, <a href="http://www.jamesshore.com/Agile-Book/incremental_design.html">James Shore</a> (who wrote the more on the subject) also shares my view:</p>

<blockquote><p>Common thought is that distributed processing, persistence, internationalization, security, and transaction structure are so complex that you must consider them from the start of your project. I disagree; I&rsquo;ve dealt with all of them incrementally.</p>

<p>Two issues that remain difficult to change are choice of programming language and platform. I wouldn&rsquo;t want to make those decisions incrementally!</p></blockquote>

<p>I would add published APIs to this list.</p>

<p>Granted, there are situations that incremental architecture alone cannot handle, what about its good points then ?</p>

<p>In all the other cases (and that means most of the time), here is what you get :</p>

<ul>
<li>As you won&rsquo;t need to deal with future use cases, you&rsquo;ll do less work</li>
<li>That in turn, will keep your code simpler, decreasing time to release new features</li>
<li>As change is built-in, you&rsquo;ll be able to improve your architecture in ways you could not have imagined from the start !</li>
</ul>


<p><a href="https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1493096137&amp;sr=1-1&amp;keywords=the+art+of+agile+development"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/art-of-agile.jpg" alt="Front cover of the Art of Agile Software Development book" /></a></p>

<p>If you cannot see how this could possibly work ? Read on !</p>

<h2>How to do it</h2>

<h3>eXtreme Programming</h3>

<p>As I said earlier, incremental architecture emerged from eXtreme Programming. It won&rsquo;t come as a surprise that in order to work well incremental architecture requires the XP practices to be in place. In particular, the code base should be automatically tested, the continuous integration cycle should take less than 10 minutes, the design should be simple. The team should be good at doing refactoring.</p>

<p>Don&rsquo;t expect to be able to do incremental architecture without these practices in place. But this alone might be enough already !</p>

<p><a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1493096197&amp;sr=1-1&amp;keywords=fowler+refactoring"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/refactoring.jpg" alt="Front cover of the Martin Fowler's refactoring book" /></a></p>

<h3>Architecture Vision</h3>

<p>At work, where our team consists of 9 developers, it&rsquo;s not always that simple to coordinate and all pull in the same direction. That&rsquo;s why we find it useful to share a very long term architecture vision (<a href="https://www.thoughtworks.com/insights/blog/enabling-incremental-design-and-evolutionary-architecture">Enabling Incremental Design and Evolutionary Architecture</a>). This will help people to make coherent decisions when hesitating between 2 alternate designs.</p>

<p>The vision can be the result of the work of a pair, or a mob brainstorming or whatever. Building this vision is typically an activity where experienced programmers can contribute a lot of value.</p>

<p>Once this vision is shared and understood by the team, every time a pair has to work on a story, they can orient the design towards it. But always as little as possible to finish the work at hand, remember the XP motos <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS (Keep It Simple &amp; Stupid)</a> &amp; <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI (You Ain&rsquo;t Gonna Need It</a>.</p>

<p>One final word &hellip; a vision is just that : a vision ! It might turn out true, or false, be ready to change it as circumstances change.</p>

<h3>Spikes</h3>

<p>At times, even with a story in your hands and a long term architecture sketch on the whiteboard, you might have difficulties to know how to change your design to fulfill both.</p>

<p>As always in XP, in case of uncertainty, use <a href="http://agiledictionary.com/209/spike/">Spikes</a> ! Spikes are short time-boxed experiments of throwaway code, which goal is to answer a specific design question.</p>

<h3>How to mitigate the risks</h3>

<p>What about these topics that don&rsquo;t yield to incremental architecture ? What if you discover late that you need to change your platform ? Or your API ?</p>

<p>Obviously, you should think about these questions up-front. Hopefully, there are usually not that difficult to answer. But, over time, Non-Functional-Requirements and technologies change. Large and long living systems are particularly likely to need to change to a new platform someday.</p>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix had the answer</a> : build your system out of small tools, that do only one thing well, and that communicate through a standard protocol. Systems built that way can be re-written one piece at a time.</p>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/Ken_n_dennis.jpg" alt="Ken Thompson and Dennis Ritchie, the creators of Unix" /></a><div class="image-credits">Photo from <a href="https://commons.wikimedia.org/wiki/File:Ken_n_dennis.jpg">WikiMedia</a></div></p>

<p>The modern version of this is the micro-services architecture. Incremental architecture allows you to start with a monolith, split it when you need to, and replace micro-services as needed.   With the safety of simple code and a great automated test harness. Interestingly, successful software systems that were architectured up-front also take this road &hellip; without the safety !</p>

<h3>The Architect</h3>

<p>Good news : no more PowerPoints and a lot more coding with the team ! Here is what&rsquo;s expected from an incremental architect :</p>

<ul>
<li>To code with the team. As Bertrand Meyer once said &ldquo;<a href="http://stal.blogspot.fr/2008/08/architect-always-implements.html">Bubbles (aka. diagrams) don&rsquo;t crash</a>&rdquo;, it&rsquo;s plain too easy, and wrong, to mandate architecture without living with the consequences</li>
<li>To come up with more ideas when drafting the long term vision</li>
<li>To keep an eye on the &lsquo;long term&rsquo; while being the navigator in pair programming</li>
<li>In the second edition of the <a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0321278658/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1493096057&amp;sr=8-1&amp;keywords=extreme+programming">XP book</a> Kent Beck suggests that the architect should write large scale tests to stress the system and demonstrate architecture issues to the team</li>
<li>To delegate as much as possible to the team. However smart the architect, the team as a whole is smarter ! Delegating architecture increases motivation and the quality of the outcome.</li>
</ul>


<h2>End of the story</h2>

<p>I&rsquo;ve been practicing incremental architecture and design for a long time now. It made my life a lot simpler ! Most architecture questions become backlog items to prioritize.</p>

<p>One last advice : be prepared to re-read <a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">Joel Spolsky&rsquo;s article</a> whenever you get caught up in architecture meetings &hellip;</p>
]]></content>
  </entry>
  
</feed>
