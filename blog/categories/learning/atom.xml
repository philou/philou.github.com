<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: learning | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/learning/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-06-14T06:06:40+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Frequently asked questions about the 20 hours of Code Katas]]></title>
    <link href="http://philippe.bourgau.net/frequently-asked-questions-about-the-20-hours-of-code-katas/"/>
    <updated>2018-04-12T19:20:00+02:00</updated>
    <id>http://philippe.bourgau.net/frequently-asked-questions-about-the-20-hours-of-code-katas</id>
    <content type="html"><![CDATA[<p>In my <a href="/blog/categories/20-hours-code-kata-series/">previous posts</a>, I explained how to use the 20 hours of Code Katas technique to learn new languages. If you did not read these yet, start by <a href="/how-to-learn-a-programming-language-in-just-20-hours/">the beginning</a>.</p>

<p><img src="../imgs/2018-03-26-frequently-asked-questions-about-the-20-hours-of-code-katas/faq-bulb.jpg" alt="A drawing of FAQ in a lightbulb" /></p>

<p>To close <a href="/blog/categories/20-hours-code-kata-series/">this series</a>, here are a few tips and suggestions presented as questions and answers.</p>

<h2>What if you don&rsquo;t know TDD yet ?</h2>

<p>The few <a href="http://codingdojo.org/dojo/ParisDojo/">Parisian guys</a> who invented the Coding Dojo wanted to teach and spread TDD ! You should have no problem to use it to learn TDD yourself !</p>

<blockquote><p>ðŸ’¡ The coding dojo was invented to teach and spread TDD</p></blockquote>

<p>Pick your favorite language, and schedule a kata plan to practice TDD. Watch one or two <a href="https://www.google.fr/search?q=code+kata&amp;tbm=vid">videos</a> to see how gurus are doing it. At first, you&rsquo;ll have to be very careful to stick to baby steps and the red-green-refactor loop. If you need help, check <a href="https://www.meetup.com">meetup.com</a> for local coding dojos where you&rsquo;ll find help.</p>

<h2>Can I apply this technique to learn something else than a new language ?</h2>

<p>As you might have noticed, I used it to refresh my Javascript. I went on to learn different flavors of JS, but also different test libraries. I&rsquo;ve used in to learn more advanced parts of other languages in the past.</p>

<p>Katas also work well to learn programming techniques like <a href="https://en.wikipedia.org/wiki/Code_refactoring">refactoring</a> or <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a>. Some nice people shared <a href="http://kata-log.rocks/refactoring">refactoring katas</a> on the web. To practice DDD, we could repeat katas with the constraint of using <a href="https://en.wikipedia.org/wiki/Entity">Entities</a> and <a href="https://en.wikipedia.org/wiki/Value_object">Value Objects</a> only.</p>

<p>You can even use the technique to learn other things like frameworks or tools, but you&rsquo;ll need to tune it. As I explained before, you need an exercice for deliberate practice and a fast feedback loop. We typically use a Code Katas and TDD for that, but that&rsquo;s not the only options. Whenever you can find a way to deliberately practice with a fast feedback loop, you&rsquo;re ready to go ! These days, we should look for docker images with frameworks and tools pre-installed. Going through tutorials without looking at the solutions is deliberate practice. A small live environment can give us fast enough feedback.</p>

<blockquote><p>ðŸ’¡ Find Deliberate Practice exercices and a fast feedback loop for efficient learning</p></blockquote>

<h2>What if I don&rsquo;t find any kata ?</h2>

<p>Build one yourself ! I&rsquo;m not joking, building a kata, especially one where you start from scratch is not too difficult. Inspiration comes from anything you happen to do in your daily work. Trim down a programming challenge you had to work, and you might have a kata ! Went to a programming interview ? The question you had to answer might do a nice kata.</p>

<p><img src="../imgs/2018-03-26-frequently-asked-questions-about-the-20-hours-of-code-katas/make-things-happen.jpg" alt="&quot;Make things happen&quot; written on a blackboard" /></p>

<p>Once you&rsquo;ve created and tested your kata, share it ! There are online kata repositories where you could get a chance to publish it.</p>

<ul>
<li>Â Â <a href="http://codingdojo.org/">codingdojo.org</a></li>
<li>Â Â <a href="http://cyber-dojo.org/">cyber-dojo.org</a></li>
<li>Â Â <a href="http://kata-log.rocks">kata-log.rocks</a></li>
</ul>


<h2>One last thing</h2>

<p>I just remembered I did not finish <a href="/how-to-learn-a-programming-language-in-just-20-hours/">my story about my Javascript kata plan</a>. For those wondering, here is the end of story. In the end I did not join this team to do Javascript coaching. After thinking through it for a while, I decided to stop the katas there, and move to something else. I was only 6 hours in, and what was the point to study Javascript not to use it straight away ? The day I&rsquo;ll need it, I&rsquo;m likely to have forgotten 80% of it and some of it will be outdated. The knowledge is only another 20 hours away anyway !</p>

<p>That&rsquo;s what we could call &ldquo;Just In Time Learning&rdquo; ! We are drowning in knowledge nowadays. It&rsquo;s better to have a fast and effective way to learn anything than trying to know everything.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why 20 hours of code kata are so effective for learning new languages]]></title>
    <link href="http://philippe.bourgau.net/why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/"/>
    <updated>2018-04-05T08:53:00+02:00</updated>
    <id>http://philippe.bourgau.net/why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages</id>
    <content type="html"><![CDATA[<p>In my <a href="/how-to-learn-a-programming-language-in-just-20-hours/">previous post</a>, I described how I&rsquo;ve been using 20 hours of Code Katas to learn new languages. If you did not read it yet, have a look at it first. Let&rsquo;s now look at why it works so well.</p>

<p>In <a href="https://www.amazon.com/First-20-Hours-Learn-Anything/dp/1591846943/ref=sr_1_2?ie=UTF8&amp;qid=1521785371&amp;sr=8-2&amp;keywords=the+first+20+hours">The First 20 Hours</a> Josh Kaufman explains how he learned <a href="https://www.ruby-lang.org/">Ruby</a> in 20 hours. He did not become a Ruby expert, but he was able to build and maintain a static website generator. For my part, I have succeeded to learn <a href="/how-i-got-my-feet-wet-with-machine-learning-with-the-first-20-hours/">a bit of machine learning</a> using the 20 hours technique.</p>

<p>The effectiveness of the 20 hours of Code Katas relies a few key points.</p>

<p><img src="../imgs/2018-03-26-why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/why.jpg" alt="Drawing of &quot;Why ?&quot; mixed up with the inside of a clock" /></p>

<h2>Time-boxing</h2>

<p>Time-boxing has 2 main benefits. First, it forces us to stick to what is the most important for us to learn. There is no time to waste slacking around in only 20 hours. Plus it&rsquo;s a lot easier to focus for 20 hours than over a very long period of time.</p>

<p>There&rsquo;s a second great thing about time-boxing. The further you go, the less remains to do, and the less likely you are to drop the effort ! We are a lot less likely to abandon when we know we only need a few hours to finish the goal we had set to ourselves.</p>

<blockquote><p>ðŸ’¡ Time-boxing creates focus</p></blockquote>

<h2>A plan</h2>

<p>Again, the plan helps us to focus. We&rsquo;ll need to choose what gets in a 20 hours plan. Building the plan itself forces us to get a grasp of the learning space. This will help to pick the good stuff to practice.</p>

<h2>Routine</h2>

<p>Routine is a magic trick to get things done. Once we have a routine in place, we don&rsquo;t have to think or do extra efforts to find time to learn. The time is already there, we just have to use it !</p>

<h2>Deliberate practice</h2>

<p>Some exemples from &ldquo;The first 20 hours&rdquo; highlight the benefits of deliberate practice. When learning the <a href="https://en.wikipedia.org/wiki/Colemak">Colemak keyboard</a>, the author went through typing exercices. When studying the game of Go, he did practices specific situation puzzles. In both cases, deliberate practice made him learn faster. Code katas are typical deliberate practice exercices for programmers.</p>

<p><img src="../imgs/2018-03-26-why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/golf-practice.jpg" alt="Picture of a golfer deliberately practicing" /></p>

<h2>Test Driven Development</h2>

<p><a href="http://codingdojo.org/">Coding Dojos</a> are the programmers' deliberate practice. Coding Dojos traditionally rely on <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a>. TDD sets up a fast feedback loop that is key to efficient learning. Think of all the time saved by not having to run and debug a full program every time ! Even dabbling around in the <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> cannot beat running 20 or so test cases every few seconds.</p>

<h2>We are already programmers</h2>

<p>One last and obvious little detail : we don&rsquo;t have to learn it all ! When the author learned Ruby in 20 hours, he was starting from scratch ! Unlike us, who already know how to program, but want to extend our knowledge to a few more topics. Most of the times, we don&rsquo;t need to relearn everything, but to transpose what we know in a new context.</p>

<p>For example, if we already know an object oriented language, learning a new one will be easier. It&rsquo;s a bit like with foreign languages, the more you know, and the easier it is to learn the next one. In fact, the more languages, frameworks, patterns and paradigms you know, the more the 20 hours code katas will work for you.</p>

<blockquote><p>ðŸ’¡ The more you know about software, the easier it will be to learn your next programming language.</p></blockquote>

<p>You might have a look at <a href="/how-to-keep-up-with-software-technologies/">this post</a> for advices about evergreen concepts to learn.</p>

<h2>Next part</h2>

<p>This was the second post on this <a href="/blog/categories/20-hours-code-kata-series/">series about the 20 hours of Code Katas technique</a>. The <a href="/frequently-asked-questions-about-the-20-hours-of-code-katas/">next, and last, post</a> will be compilation of answers to frequently asked questions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to learn a programming language in just 20 hours]]></title>
    <link href="http://philippe.bourgau.net/how-to-learn-a-programming-language-in-just-20-hours/"/>
    <updated>2018-03-29T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-learn-a-programming-language-in-just-20-hours</id>
    <content type="html"><![CDATA[<p>We should not panic when asked to work with a new language. We should be bold enough to answer to job openings requiring technologies we are not used to. In one word, we should not be afraid of new techs. Here is why : by scheduling 20 hours of Code Kata routine sessions, we can get a decent level of mastery on most topics.</p>

<p><img src="../imgs/2018-03-23-how-to-learn-a-programming-language-in-just-20-hours/timed-book.jpg" alt="A book with built-in clock" /></p>

<h2>How I learned some Haskell</h2>

<p>Quite a few years ago, we used to do weekly <a href="http://codingdojo.org/">Coding Dojos</a> at <a href="https://www.murex.com/">Murex</a>. <a href="https://twitter.com/dr_c0d3">Arnaud Bailly</a> was among us, and as he is an <a href="https://www.haskell.org/">Haskell</a> fan, we ended up doing quite a lot of katas with Haskell. To my astonishment, after a few sessions, I understood of the fundamentals of the language. Without ever studying it !</p>

<blockquote><p>ðŸ’¡ I learned a lot of Haskell by just going to Coding Dojos !</p></blockquote>

<p>Many times afterwards, I learned new languages quickly by practicing them in the Dojo.</p>

<h2>How I set out to refresh my javascript</h2>

<p>Fast forward to the end of last year. Someone asked me if I could work at coaching a team doing some Javascript. I&rsquo;ve done some Javascript in the past, but my skills definitely needed a serious update. I decided to use Code Katas to refresh my Javascript. To try to make this even more effective, I decided to mix in a bit of the <a href="https://www.amazon.com/First-20-Hours-Learn-Anything/dp/1591846943/ref=sr_1_2?ie=UTF8&amp;qid=1521785371&amp;sr=8-2&amp;keywords=the+first+20+hours">&ldquo;First 20 hours&rdquo;</a> technique.</p>

<p><a href="https://www.amazon.com/First-20-Hours-Learn-Anything/dp/1591846943/ref=sr_1_2?ie=UTF8&amp;qid=1521785371&amp;sr=8-2&amp;keywords=the+first+20+hours"><img src="../imgs/2018-03-23-how-to-learn-a-programming-language-in-just-20-hours/the-first-20-hours.jpg" alt="The cover of the book &quot;The first 20 hours&quot;" /></a></p>

<p>I started by defining a plan of 10 sessions of 2 hours long code katas :</p>

<ol>
<li><a href="http://codingdojo.org/kata/RomanNumerals/">Roman Numeral</a> &ndash; <a href="https://mochajs.org/">Mocha</a> &ndash; JS 5</li>
<li><a href="http://codingdojo.org/kata/GameOfLife/">Game of Life</a> &ndash; <a href="https://mochajs.org/">Mocha</a> &ndash; JS 5</li>
<li><a href="http://kata-log.rocks/mars-rover-kata">Mars Rover</a> &ndash; <a href="https://mochajs.org/">Mocha</a> &ndash; JS 5</li>
<li><a href="http://codingdojo.org/kata/Bowling/">Bowling Score</a> &ndash; <a href="https://mochajs.org/">Mocha</a> &ndash; JS 5</li>
<li>Median of a list of lists &ndash; <a href="https://mochajs.org/">Mocha</a> &ndash; <a href="http://es6-features.org/">ES 6</a></li>
<li><a href="http://codingdojo.org/kata/NumberToLCD/">LCD Numbers</a> &ndash; <a href="https://jasmine.github.io/">Jasmine</a> &ndash; <a href="http://es6-features.org/">ES 6</a></li>
<li><a href="http://codingdojo.org/kata/Potter/">Kata Potter</a> &ndash; <a href="https://jasmine.github.io/">Jasmine</a> &ndash; <a href="http://es6-features.org/">ES 6</a></li>
<li>T9 &ndash; Jasmine &ndash; <a href="http://www.typescriptlang.org/">Typescript</a></li>
<li><a href="http://codingdojo.org/kata/PokerHands/">Poker hand</a> &ndash; <a href="https://jasmine.github.io/">Jasmine</a> &ndash; <a href="http://www.typescriptlang.org/">Typescript</a></li>
<li>Egg cooker with <a href="https://reactjs.org/">React</a> &ndash; <a href="https://jasmine.github.io/">Jasmine</a> &ndash; <a href="http://www.typescriptlang.org/">Typescript</a></li>
</ol>


<p>The plan felt pretty ambitious at the beginning. The first session was a bit hectic as I struggled to find a quick setup I could use to code my kata in. After only 3 sessions though, I could feel I&rsquo;d already made a lot of progress. I had become confident I would get most of the plan done in 20 hours.</p>

<h2>How to start ?</h2>

<p>A good thing about the 20 hours technique is that it&rsquo;s pretty easy to start with ! There&rsquo;s a catch though ! At the start, it&rsquo;s puzzling to be on your own with no clear track on how to tackle the topic. Here is the fix : start anyway, stick through, and you&rsquo;ll work it out 99% of the time.</p>

<p>Here is, in more details, how to use code kata with the 20 hours technique :</p>

<ol>
<li>Start by setting up a routine. It could be 2 hours at lunch time, 1 hour in the morning or 3 hours at night. Do whatever is best for you. It should be enough to finish in a few days or weeks.</li>
<li>Use the first hours of your 20 hours to setup a code kata plan. It might be very fast if you already have an idea of your learning space. It will take longer if you are a complete newbie. Skim through the literature for the main concepts until you have a plan. Try to keep this phase under 6 hours, otherwise you won&rsquo;t have any time left for actual learning.</li>
<li><a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a> plays a key role in fast learning ! Next step is to setup a development environment with TDD to use in your Code Kata sessions.</li>
<li>Finally, do you code kata sessions. Time-box them for something less than 2 hours and run a mini-retrospective at the end of every session. Don&rsquo;t hesitate to adapt your plan if it makes sense.</li>
<li>When you reach 20 hours of learning, stop your sessions. It will be time to think a bit about what you accomplished.</li>
</ol>


<blockquote><p>ðŸ’¡ TDD plays a key role in fast learning.</p></blockquote>

<p>If all went well, you should have learned quite a lot in only 20 hours. At that point, it&rsquo;s up to you to decide what to do next. You can either decide to dig deeper. In this case, setup a new run of 20 hours of code katas ! It could also be a good time to read a bit of theory about what you just learned. Casting a different light on the topic will make it stick and deepen your understanding. Otherwise, you could stop there and start whatever is on your mind. I don&rsquo;t recommend continuing on the same topic without rethinking a new plan though. That would kill your focus and be a less efficient use of your time.</p>

<h2>To be continued</h2>

<p>This was the first post in <a href="/blog/categories/20-hours-code-kata-series/">a series about applying the 20 hours technique and Code Katas to learn new programming languages</a>. Here is the what to expect in the coming posts.</p>

<ol>
<li><a href="/how-to-learn-a-programming-language-in-just-20-hours/">How to learn a programming languages in just 20 hours</a></li>
<li><a href="/why-20-hours-of-code-kata-are-so-effective-for-learning-new-languages/">Why 20 hours of code kata are so effective for learning new languages</a></li>
<li><a href="/frequently-asked-questions-about-the-20-hours-of-code-katas/">Frequently asked questions about the 20 hours of Code Katas</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 things to know that will make you great at refactoring legacy code]]></title>
    <link href="http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/"/>
    <updated>2017-07-28T06:35:00+02:00</updated>
    <id>http://philippe.bourgau.net/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>We write tons of <a href="https://en.wikipedia.org/wiki/Legacy_code">legacy code</a> everyday. Experienced developers understand that legacy code is not something special. Legacy code is our daily bread and butter.</p>

<p>Should we abandon all hope as we enter legacy code ? Would that be professional ? In the end, code is only a bunch of bytes, somewhere on a drive. We are the software professionals. We need to deal with that.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/keep-calm-and-take-the-power-back-4.jpg" alt="Keep Calm and Take The Power Back" /></p>

<h2>1. Master non legacy refactoring first</h2>

<p>Please calm down before this &ldquo;Bring &lsquo;em out&rdquo; energy goes to your head.</p>

<p>I did not say that refactoring legacy code is easy. Legacy code can bite &hellip; bad. I&rsquo;ve been in teams which literally spent nights fixing a bad refactoring gone to production &hellip;</p>

<p>Before you can refactor legacy code, you need to be good at refactoring new code. We all learned to swim in the shallow pool, it&rsquo;s the same with refactoring. Mastering green code refactoring will help you when tackling legacy code.</p>

<p>First, you&rsquo;ll know the ideal you&rsquo;d like to get to. Knowing how productive a fast feedback loop is will motivate you to keep on refactoring.</p>

<p>Second, you&rsquo;ll have a better idea of the baby steps to take you through a tricky refactoring.</p>

<p>If you are not yet at ease with greenfield refactoring, have a look at <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">my previous post</a>.</p>

<h2>2. Understand that refactoring legacy code is different</h2>

<p>The next thing to remember is that refactoring legacy code is different. Let&rsquo;s assume <a href="https://stackoverflow.com/questions/4174867/what-is-the-definition-of-legacy-code">Michael Feather&rsquo;s definition of legacy code</a> : &ldquo;Code without tests&rdquo;. Getting rid of legacy code means adding automated tests.</p>

<p>Unfortunately, trying to force push unit tests in legacy code usually results in a mess. It introduces lot&rsquo;s of artificial mocks in a meaningless design. It also creates brittle and unmaintainable tests. More harm than good. This might be an intermediate step, but it is usually not the quickest way to master your legacy code beast.</p>

<p>Here are alternatives I prefer.</p>

<h2>3. Divide and conquer</h2>

<p>This is the most straightforward way to deal with legacy code. It&rsquo;s an iterative process to repeat until you get things under control. Here is how it goes :</p>

<p>(1) Rely on the tests you have, (2) to refactor enough, (3) to test sub-parts in isolation. (4) Repeat until you are happy with the speed of the feedback loop.</p>

<p>Depending on the initial state of your tests, this might take more or less time. Your first tests might even be manual. This is the bulldozer of refactoring. Very effective, but slow.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/bulldozer.jpg" alt="Bulldozer" /></p>

<h2>4. Pair or mob program</h2>

<blockquote><p>Given enough eyeballs, all bugs are shallow.</p>

<p><a href="https://en.wikipedia.org/wiki/Linus%27s_Law">Linus&rsquo;s Law</a></p></blockquote>

<p>Changing legacy code is a lot easier when you team up. First, it creates a motivating &ldquo;we&rsquo;re all in this together&rdquo; mindset. Second, it guards us against silly mistakes.</p>

<p><a href="https://en.wikipedia.org/wiki/Mob_programming">Mob programming</a>, might seem very expensive, so let me explain why it is not. Suppose you want to introduce some tests in a tricky section of code.</p>

<p>With mob programming, all the team gathers for half a day to work on this change. Together, they find and avoid most of the pitfalls. They commit a high quality change, which creates only one bug down the road.</p>

<p>Let&rsquo;s see the alternative.</p>

<p>Using solo programming, a poor programmer tries to tackle the change all by himself. He spends a few days to understand and double check all the traps he can think of. Finally, he commits his change, which results in many bugs later on. Every time a bug pops up, it interrupts someone to fix it ASAP.</p>

<p>The savings in interruptions are greater than up front cost of mob or pair programming.Â </p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/p_pvslS4gEI" frameborder="0" allowfullscreen></iframe>


<h2>5. Seams</h2>

<blockquote><p>A software seam is <em>a place where you can alter behavior in your program without editing in that place.</em></p>

<p><a href="http://wiki.c2.com/?SoftwareSeam">Michael Feathers</a></p></blockquote>

<p>This is one of the many interesting things I learned from Michael&rsquo;s book about legacy code.</p>

<p><a href="https://www.amazon.com/gp/product/0131177052/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131177052&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=edaadc6370c2c8c9e943348d9fbdafb9"><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/legacy-code.jpg" alt="Cover of Working Effectively with Legacy Code" /></a></p>

<p>Object polymorphism is only one kind of seam. Depending on your language, many other types of seams can be available.Â </p>

<ul>
<li>Type seam for generic languages</li>
<li>Static link seam for static libraries</li>
<li>Dynamic link seam for dynamic libraries</li>
<li>&hellip;</li>
</ul>


<p>Finding seams in your program is something opportunistic. Keep in mind though that testing through seams is not the end goal. It is only a step to bootstrap the test-refactor loop and start your refactoring journey.</p>

<h2>6. Mikado Method</h2>

<p>How do you get to your end then ? How to you refactor only what&rsquo;s useful for your features ? How do you do large refactorings in baby steps ?</p>

<p>Over time, I found that the mikado method is a good answer to all these issues. The goal of the <a href="https://mikadomethod.wordpress.com/">Mikado Method</a> is to build a graph of dependent refactoring. It can then use it to perform all these refactorings one by one. Here is the mikado method by the book.</p>

<p>Before anything else, you&rsquo;ll need a large sheet of paper to draw the graph. Then repeat the following :</p>

<ol>
<li>try to do the change you want</li>
<li>If it builds and the tests pass, great, commit and you&rsquo;re done</li>
<li>Otherwise, add a node for the change you wanted to do in your mikado graph</li>
<li>Write down the compilation and test errorsÂ </li>
<li>Revert your change</li>
<li>Recurse from 1 for every compilation or test error</li>
<li>Draw a dependency arrow from the nodes of errors to the node of your initial change</li>
</ol>


<p>Once you built the full graph, tackle the refactorings from the leaves. As leafs have no dependencies, it should be easy to do and commit them.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado.jpg" alt="A Sample Mikado Graph" /></p>

<p>When I first read about the mikado method, it seemed very simple and powerful. Things got more complex when I tried to apply it. For example, the fact that some changes don&rsquo;t compile hide future test failures. That means that very often, the &ldquo;Build the graph&rdquo; and &ldquo;Walk the graph&rdquo; phases overlap. In real life, the graph evolves and changes over time.Â </p>

<p>My advice about the Mikado Method is not to take it to the letter. It&rsquo;s a fantastic communication tool. It helps not to get lost and to avoid a refactoring tunnel. It also helps to tackle refactoring as a team.</p>

<p>It is not a strict algorithm though. Build and tests are not the only way to build the graph. Very often, a bit of thinking and expert knowledge are the best tools at hand.</p>

<p><a href="https://www.amazon.com/gp/product/1617291218/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1617291218&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=f7405cd74335b3cbb8b263f1a5c37c1d"><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/mikado-book.jpg" alt="Cover of The Mikado Method book" /></a></p>

<h2>7. Bubble Context</h2>

<p>Refactoring needs to be opportunistic. Sometimes there are shortcuts in your refactoring path.</p>

<p>If you have access to a domain expert, the <a href="http://dddcommunity.org/library/evans_2011_2/2">Bubble Context</a> will cut the amount of refactoring to do. It&rsquo;s also an occasion to get rid of all the features that are in your software but that are not required anymore.Â </p>

<p>The Bubble Context originated from the <a href="http://dddcommunity.org/library/evans_2011_2/">DDD community</a>, as a way to grow a domain in an existing code base. It goes like that :</p>

<ol>
<li>Find a domain expert</li>
<li>(Re)write clean code for a very tiny sub domain</li>
<li>Protect it from the outside with an <a href="https://softwareengineering.stackexchange.com/questions/184464/what-is-an-anti-corruption-layer-and-how-is-it-used">anticorruption layer</a></li>
<li>Grow it little by little</li>
</ol>


<p>I have friends who are fans of the bubble context. It is super effective provided you have a domain expert. It is a method of choice in complex domain software.</p>

<h2>8. Strangler</h2>

<p>Bubble Context works great when refactoring domain specific code, what about the rest ? I had good results with the <a href="https://www.martinfowler.com/bliki/StranglerApplication.html">Strangler pattern</a>.</p>

<p>For example, we had to refactor a rather complex parser for an internal DSL. It was very difficult to incrementally change the old parser, so we started to build a new one aside. It would try to parse, but delegate to the old one when it failed. Little by little, the new parser was handling more and more of the grammar. When it supported all the inputs, we removed the old one.</p>

<p>The strangler is particularly well suited for refactoring technical components. They have more stable interfaces and can be very difficult to change incrementally.</p>

<h2>9. Parallel Run</h2>

<p>This is more of a trick than a long term strategy. The idea is to use the initial (legacy) version of the code as a reference for your refactoring. Run both and check that they are doing the same thing.</p>

<p><img src="../imgs/2017-07-28-10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/railroad.jpg" alt="Parallel Railroads" /></p>

<p>Here are some variations around this idea.</p>

<p>If the code you want to refactor is side effect free, it should be easy to duplicate it before refactoring. This enables running both to check that they compute the same thing.</p>

<p>Put this in a unit test to bootstrap a test-refactor loop. You can also run both in production and log any difference. You&rsquo;ll need access to production logs &hellip; Devops teams have a refactoring advantage !</p>

<p>Here is another use of your logs. If the code writes a lot of logs, we can use them as a reference. Capture the logs of the old version, and unit test that the refactored version prints the same logs out. That&rsquo;s an unmaintainable test, but good enough to bootstrap the test-refactor loop.</p>

<p>The <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose kata</a> is a good exercise to practice this last technique.</p>

<h2>10. Dead code is better off dead</h2>

<p>You don&rsquo;t need to refactor dead code ! Again, access to production logs is a great advantage for refactoring.</p>

<p>Add logs to learn how the real code runs. If it&rsquo;s never called, then delete it. If it&rsquo;s only called with some set of values, simplify it.</p>

<h2>No silver bullet</h2>

<p>That was a whirlwind tour of the legacy code refactoring techniques I know. It&rsquo;s no promise that refactoring will become easy or fast. I hope it is a good starting point to set up and walk a refactoring plan.</p>

<p>This was the last post of a series of 3 about how to learn refactoring techniques. If you didn&rsquo;t already, check part 1 <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a> and part 2 <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">How to Start Learning the Tao of Incremental Code Refactoring Today</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to start learning the tao of incremental code refactoring today]]></title>
    <link href="http://philippe.bourgau.net/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/"/>
    <updated>2017-07-21T08:05:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-start-learning-the-tao-of-incremental-code-refactoring-today</id>
    <content type="html"><![CDATA[<p>In my <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">last post</a>, I explained why incremental refactoring techniques will make you both more productive and relaxed.</p>

<p>As anything worth its salt, the path to full mastery is long and requires dedication. The good news is that you&rsquo;ll start to feel the benefits long before you are a master.</p>

<h2>Dedicated Practice</h2>

<p>The quickest thing that will get you up to speed is dedicated practice. Take some time to do some exercices outside of any &lsquo;production&rsquo; code.</p>

<h3>TDD Coding Katas</h3>

<p>The most famous practice to learn TDD also works very well to learn refactoring. That shouldn&rsquo;t be a surprise as incremental refactoring is an integral part of TDD.</p>

<p>There are many ways to do your first coding kata. You could find a coding dojo near you (ask <a href="https://www.meetup.com/">meetup.com</a>). Or you could find motivated colleagues to start one at your company &hellip; I wrote in more details about how to attend a coding dojo in <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">this post</a>.</p>

<p><a href="https://www.amazon.com/gp/product/919811803X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=919811803X&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=340ea938a5e4f00178676804ac6c2278"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/coding-dojo.jpg" alt="Emily Bache's Coding Dojo book cover" /></a></p>

<p>You can also practice katas on your own. My friend <a href="https://twitter.com/tpierrain">Thomas Pierrain</a> rehearses the same katas to discover deeper insights.</p>

<h3>Refactoring Golf</h3>

<p>The goal of incremental refactoring is to keep the code production ready all the time. Smaller commits is one happy consequence of that.</p>

<p>You can stretch your refactoring muscles by doing coding katas and keeping the code compiling all the time. You&rsquo;ll need to master your IDE and its automated refactoring. Most of all, it will shift your attention from the goal to the path !</p>

<p>I learned at <a href="https://www.spaconference.org/spa2017/">SPA conference</a> that we call this &lsquo;Refactoring golf&rsquo;. The name comes from Golf contests, <a href="http://wiki.c2.com/?PerlGolf">popular in the Perl community</a>. Their goal is to write the shortest program possible to do a specific goal. The goal of a Refactoring Golf is to go from code A to code B in the fewest transformations possible.</p>

<p>They are a few <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=refactoring+golf&amp;type=">refactoring golf repos on Github</a>, I tried one and found it fun ! Give it a try too !</p>

<h2>Study some theory</h2>

<p>Real mastery does not come by practice alone. Studying theory alongside practice yields deeper insights. Theory enables to put your practice into perspective and to find ways to improve it. It saves you from getting stuck in bad habits. It also saves you from having to rediscover everything by yourself.</p>

<h3>Develop your design taste</h3>

<p>In <a href="http://www.paulgraham.com/taste.html">Taste for Makers</a> Paul Graham explains why taste for is fundamental to programming. Taste is what allows you to judge if code is nice or bad in a few seconds. Taste is subjective, intuitive and fast, unlike rules which are objective but slower. Expert designers use taste to pinpoint issues and good points in code on the spot.</p>

<p>Within the fast TDD &ndash; Refactoring loop, taste is the tool of choice to drive the design. Guess what : we can all improve our design taste !</p>

<p><a href="https://blog.codinghorror.com/code-smells/">Code smells</a> are the first things to read about to improve your design taste. Once you know them well enough, it will be possible to spot things that might need refactoring as you code.</p>

<p>Spotting problems is nice, but finding solutions is better ! <a href="https://en.wikipedia.org/wiki/Software_design_pattern">Design Patterns</a> are just that &hellip; There has been a lot of controversy around Design Patterns. If overusing them leads to bloated code, using them to fix strong smells makes a lot of sense. There is even a book about the subject :</p>

<p><a href="https://www.amazon.com/gp/product/0321213351/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321213351&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=d79d093008fb9e77f75ea2089d6cbdae"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/refactoring-to-patterns.jpg" alt="Joshua Kerievsky's Refactoring To Patterns book cover" /></a></p>

<p>Finally, there&rsquo;s a third and most common way to improve our design taste. It&rsquo;s to read code ! The more code we read, the better our brain becomes at picking small clues about what nice and what is not. It&rsquo;s important to read clean code but also bad code. To read code in different languages. Code built on different frameworks.Â </p>

<p>So, read code at work, read code in books, read code in open source libraries, good code, legacy code &hellip;</p>

<h3>Learn your refactorings</h3>

<p>As with most topics in programming there is a reference book about refactoring. It&rsquo;s Martin Fowlers&rsquo;s <a href="https://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=73fc09a5a451402a7036509ae62e8c66">Refactoring, improving the design of existing code</a>. Everything is in there, smells, unit testing and a repository of refactoring walkthroughs.</p>

<p><a href="https://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=73fc09a5a451402a7036509ae62e8c66"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/refactoring.jpg" alt="Martin Fowler's refactoring book cover" /></a></p>

<p>The book is said to be a difficult read, but the content is worth gold. If you have the grit, give it a try ! At the end, you should understand how your IDE does automated refactoring. You should also be able to perform all the refactorings that your IDE does not provide by hand ! This will enlarge your refactoring toolbox, and help you to drive larger refactorings from A to B.</p>

<h2>Develop a refactoring attitude</h2>

<p>Practice makes perfect. Whatever our refactoring skill, there is something to learn by practicing more.</p>

<h3>Make it a challenge</h3>

<p>As you are coding, whenever you find a refactoring to do to your code, make it a challenge to perform it in baby steps. Try to keep the code compiling and the tests green as much as possible.</p>

<p>When things go wrong, revert instead of pushing forward. Stop and think, try to find a different path.</p>

<p>If you are pairing, challenge your pair to find a safer track.</p>

<p>This might delay you a bit at first, but you&rsquo;ll also be able to submit many times per day. You&rsquo;ll see that your refactoring muscles will grow fast. You should see clear progress in only 1 or 2 weeks.</p>

<h3>Team up against long refactorings</h3>

<p>If your team prioritizes a user story that will need some re-design, try to agree on a refactoring plan. The idea is to find a coarse grain path that will allow you to commit and deliver many times. This plan might also help you to share the work on the story.</p>

<p>Having to question and explain your assumptions will speed up your learning.Â </p>

<h2>Legacy code</h2>

<p>Refactoring is most useful with bad legacy code. Unfortunately, it also where it is the most difficult. Next week&rsquo;s blog post will be about what we can do to learn how to refactor legacy code.</p>

<p>That was my second post in this mini-series about refactoring. First one was <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a>. The third and last is <a href="/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/">10 things to know that will make you great at refactoring legacy code</a></p>
]]></content>
  </entry>
  
</feed>
