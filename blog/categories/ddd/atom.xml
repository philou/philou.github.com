<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ddd | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/ddd/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2018-08-08T13:37:42+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Avoid mocks and test your core domain faster with Hexagonal Architecture]]></title>
    <link href="http://philippe.bourgau.net/avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture/"/>
    <updated>2018-05-24T06:43:00+02:00</updated>
    <id>http://philippe.bourgau.net/avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture</id>
    <content type="html"><![CDATA[<p>As I&rsquo;ve written in my last few posts, we can get a long way to avoid mocks with small scale coding best practices. Unfortunately, when systems reach a certain size, we need something at architecture scale.</p>

<p>This is the 6th post of a <a href="/blog/categories/how-to-avoid-mocks-series/">series about avoiding mocks</a>. If you haven&rsquo;t, you can start by <a href="/careless-mocking-considered-harmful/">the beginning</a>.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-05-24-avoid-mocks-and-test-your-core-domain-faster-with-hexagonal-architecture/hexagonal-building.jpg" alt="A drawing of a hexagon-shaped building" /></p>

<h2>Why do we end up with mocks in large systems ?</h2>

<p>A few years ago, I joined a team working in a legacy system. We wanted to apply <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and refactoring. As expected, adding tests legacy code proved a real challenge. With a lot of effort we could manage to add a few. Unfortunately, this did not seem to have any positive effect on our maintainability ! The tests we were writing all involved a lot of mocking. The system was such a large mass of spaghetti code that there was no clear place to mock. We were actually mocking where it seemed the easiest on a test by test basis. We were making progress at small scale, but the big picture was not improving at all !</p>

<p>Large systems are beasts with many faces. They Â involve a lot of IOs. They write and read data from the disk and databases. They call 3rd parties and remote services.</p>

<p>As we test these large systems, we&rsquo;ll need to stub out these IOs. Even if the tests are fast enough, we usually don&rsquo;t want to call external services for real. Most of the time though, tests are slow. That&rsquo;s 2 reasons why end up adding some mocks.</p>

<p>Here comes the nasty part. These large systems are so complex that we, developers, don&rsquo;t have the full picture. When we test, we tend to mock at different places, depending on our knowledge. This is bad for maintenance. Mocks duplicate production code behavior. When many different mocks are in place to isolate an external dependency, we end up with &lsquo;n&rsquo; versions of the code. That&rsquo;s a nightmare to refactor !</p>

<blockquote><p>ðŸ’¡ When many different mocks are in place to isolate an external dependency, we end up with &lsquo;n&rsquo; versions of the code !</p></blockquote>

<h2>Hexagonal architecture to the rescue</h2>

<p><a href="http://alistair.cockburn.us/Hexagonal+architecture">Alistair Cockburn</a> coined the term. The idea is pretty simple : Â isolate a piece of code from all dependencies. This is particularly useful for the core functional areas. With this in place, it becomes straightforward (and fast) to test the core domain logic.</p>

<p>To main techniques to isolate a piece of code from any dependency areÂ :</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection</a></li>
<li><a href="https://en.wikipedia.org/wiki/Observer_pattern">Observers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Adapter_pattern">Adapters</a></li>
</ul>


<p>It&rsquo;s also possible to split a system in many &lsquo;hexagons&rsquo; and glue them together with adapters at startup. If you want to learn more on this style of architecture, have a look into the <a href="https://www.infoq.com/articles/ddd-contextmapping">Domain Driven Design lore</a>. This community has been building systems this way for years now.</p>

<h2>Enough talk, show me the code !</h2>

<p>This post was the occasion to try to inject a Hexagonal Architecture and a dash of DDD in a Rails application. There&rsquo;s one caveat though : DDD shines on complex systems. Unfortunately, large and complex systems make very poor didactic examples. The following code highlights the gains about mocking. We would not use DDD for such a small app in real life.</p>

<h3>The starting point</h3>

<p>I chose a simple TODO app. I started by generating a scaffold for a Task with a description and a done/not-done status. As third party interaction, completing a task sends an automatic tweet. Here is the only specific code I wrote on top of the Rails scaffold :</p>

<h6>app/models/task.rb</h6>

<p>```ruby
class Task &lt; ApplicationRecord
  include ActiveModel::Dirty</p>

<p>  validates :description, presence: true</p>

<p>  before_save :tweet_if_done</p>

<p>  private
  def tweet_if_done</p>

<pre><code>if done_changed?
  TwitterClient::Client.update(self.description)
end
</code></pre>

<p>  end
end
```</p>

<p>Thanks Jason Charnes for the <a href="https://jasoncharnes.com/changed-attributes-rails/">change attribute technique</a>.</p>

<h6>spec/models/task_spec.rb</h6>

<p>```ruby
require &lsquo;rails_helper&rsquo;</p>

<p>RSpec.describe Task, type: :model do</p>

<p>  it &ldquo;is valid with all attributes set&rdquo; do</p>

<pre><code>expect(Task.create(description: "Finish presentation", done: false)).to be_valid
</code></pre>

<p>  end</p>

<p>  it &ldquo;requires a description&rdquo; do</p>

<pre><code>expect(Task.create(description: nil, done: false)).to be_invalid
expect(Task.create(description: "", done: false)).to be_invalid
</code></pre>

<p>  end</p>

<p>  it &ldquo;tweets when a task is finished&rdquo; do</p>

<pre><code>task = Task.create(description: "Wash the car", done: false)

expect(TwitterClient::Client).to receive(:update).with("Wash the car")

task.done = true
task.save
</code></pre>

<p>  end
end
```</p>

<p>This is pretty simple and to the point !</p>

<h3>5 years later</h3>

<p>Now let&rsquo;s imagine that the app grew to tens of thousands of lines. We added a lot of features to the app, which transformed the TODO domain into a very complex thing. Now suppose that, for the sake of maintenance, we want to isolate the domain logic into its own hexagon. Unlike traditional Rails ActiveRecords, we want to make it independent from the database. We also want it to be independent from the Twitter API.</p>

<p>Here is what the code might look like.</p>

<h6>lib/core/task.rb</h6>

<p>First, we have a core task class, independent from anything else. The Core module is our hexagon.</p>

<p>```ruby
module Core
  class Task</p>

<pre><code>attr_reader :description
attr_accessor :db_id

def initialize(attributes = {})
  @description= "What do you need to do ?"
  @done = false
  @done_subscribers = []

  self.update(attributes)
end

def done?
  @done
end

def mark_as_done
  @done = true
  @done_subscribers.each {|proc| proc.call(self) }
end

def update(attributes={})
  self.description= attributes[:description] unless attributes[:description].nil?
  self.mark_as_done if attributes[:done]
end

def notify_when_done(&amp;proc)
  @done_subscribers.push(proc)
end

def description=(desc)
  raise ArgumentError.new("Task description cannot be blank") if desc.blank?

  @description = desc
end
</code></pre>

<p>  end
end
```</p>

<p>As we can see, it contains only domain logic and nothing else.</p>

<h6># spec/lib/core/task_spec.rb</h6>

<p>Here is the corresponding test, fast, mock-free and independent from the database and any external system.</p>

<p>```ruby
require &lsquo;rails_helper&rsquo;
require &lsquo;core/task&rsquo;</p>

<p>context &lsquo;Task&rsquo; do</p>

<p>  let(:task) { Core::Task.new}</p>

<p>  specify &lsquo;is not done by default&rsquo; do</p>

<pre><code>expect(task).not_to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;comes with a default description&rsquo; do</p>

<pre><code>expect(task.description).not_to be_blank
</code></pre>

<p>  end</p>

<p>  specify &lsquo;it can be initialized from a hash&rsquo; do</p>

<pre><code>task = Core::Task.new(description: "Old description", done: true)

expect(task.description).to eq("Old description")
expect(task).to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;can have a custom description&rsquo; do</p>

<pre><code>task.description= "Clean up the house"
expect(task.description).to eq("Clean up the house")
</code></pre>

<p>  end</p>

<p>  specify &lsquo;forbids empty descriptions&rsquo; do</p>

<pre><code>expect{task.description = nil }.to raise_error(ArgumentError)
expect{task.description = "" }.to raise_error(ArgumentError)
</code></pre>

<p>  end</p>

<p>  specify &lsquo;can be done&rsquo; do</p>

<pre><code>task.mark_as_done
expect(task).to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;publishes when done&rsquo; do</p>

<pre><code>done_task = nil
task.notify_when_done {|t| done_task = t}

task.mark_as_done

expect(done_task).to be(task)
</code></pre>

<p>  end</p>

<p>  specify &lsquo;can be updated with a hash&rsquo; do</p>

<pre><code>task.update(description: "New description", done: true)

expect(task.description).to eq("New description")
expect(task).to be_done
</code></pre>

<p>  end</p>

<p>  specify &lsquo;has no DB id by default&rsquo; do</p>

<pre><code>expect(task.db_id).to be_nil
</code></pre>

<p>  end
end
```</p>

<h6># lib/infrastructure/task_repo.rb</h6>

<p>To read and save with the database, we now go through an adapter. This is not considered to be part of our core domain.</p>

<p>```ruby
module Infrastructure
  class TaskRepo</p>

<pre><code>def self.all
  Task.all.map do |db_task|
    from_db(db_task)
  end
end

def self.load(db_id)
  from_db(Task.find(db_id))
end

def self.save(task)
  if task.db_id.nil?
    db_task = Task.create!(to_db_attributes(task))
    task.db_id = db_task.id
  else
    db_task = Task.find(task.db_id)
    db_task.update!(to_db_attributes(task))
  end
  task
end

def self.delete(task)
  unless task.db_id.nil?
    db_task = Task.find(task.db_id)
    db_task.destroy!
    task.db_id = nil
  end
end

private

def self.to_db_attributes(task)
  {description: task.description, done: task.done?}
end

def self.from_db(db_task)
  result = Core::Task.new
  result.db_id = db_task.id
  result.description = db_task.description
  result.mark_as_done if db_task.done?
  result
end
</code></pre>

<p>  end
end
```</p>

<h6># app/controllers/tasks_controller.rb</h6>

<p>Finally, all the pieces interact together in the controller. This controller basically does what the previous version was, it&rsquo;s just using different classes. Obviously, we&rsquo;ll need to adapt the views and the tests.</p>

<p>```ruby
require &lsquo;core/task&rsquo;
require &lsquo;infrastructure/task_repo&rsquo;</p>

<p>class TasksController &lt; ApplicationController
  before_action :set_task, only: [:show, :edit, :update, :destroy]</p>

<p>  # GET /tasks
  def index</p>

<pre><code>@tasks = Infrastructure::TaskRepo.all
</code></pre>

<p>  end</p>

<p>  # GET /tasks/1
  def show
  end</p>

<p>  # GET /tasks/new
  def new</p>

<pre><code>@task = Core::Task.new
</code></pre>

<p>  end</p>

<p>  # GET /tasks/1/edit
  def edit
  end</p>

<p>  # POST /tasks
  def create</p>

<pre><code>begin
  @task = Core::Task.new(task_params)
  Infrastructure::TaskRepo.save(@task)

  redirect_to task_url(@task.db_id), notice: 'Task was successfully created.'

rescue ArgumentError
  render :new
end
</code></pre>

<p>  end</p>

<p>  # PATCH/PUT /tasks/1
  def update</p>

<pre><code>begin
  @task.update(task_params)
  Infrastructure::TaskRepo.save(@task)

  redirect_to task_url(@task.db_id), notice: 'Task was successfully updated.'

rescue ArgumentError
  render :edit
end
</code></pre>

<p>  end</p>

<p>  # DELETE /tasks/1
  def destroy</p>

<pre><code>Infrastructure::TaskRepo.delete(@task)
redirect_to tasks_url, notice: 'Task was successfully destroyed.'
</code></pre>

<p>  end</p>

<p>  private</p>

<pre><code>def set_task
  @task = Infrastructure::TaskRepo.load(params[:id])
  @task.notify_when_done do |task|
    TwitterClient::Client.update(task.description)
  end
end

# Never trust parameters from the scary internet, only allow the white list through.
def task_params
  params.permit(:description, :done)
end
</code></pre>

<p>end
```</p>

<p>The main gain here is that our core domain, our most valuable asset is now easy to test without mocks. This means that we are able to write and execute fast tests for this area of the code. This puts us in a great position to increase our competitive advantage in our core business !</p>

<blockquote><p>ðŸ’¡ By keeping your tests around your core domain fast, Hexagonal Architecture increases your competitive advantage.</p></blockquote>

<p>As you can see, we are now wiring everything together at the controller level. We could later build a facade to isolate the controller from the inside of our domain. A <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">presenter</a> might do, but it seemed over-engineered, even in this made up example. (I&rsquo;ll post something about that some day)</p>

<h2>Next post</h2>

<p>As we can deduce from the controller code above, we still have to use fakes or mocks when testing the controller. The good thing though is that this is now more local which already makes mocking less of an issue. If a mock is used in less tests, it&rsquo;s easier to use the same mock everywhere ! This is a great opportunity for simplifying test setup, as we&rsquo;ll see in the <a href="/get-rid-of-mocking-maintenance-with-full-fledged-in-memory-fakes/">next post about in-memory fakes</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Immutable Value Objects fight Mocks]]></title>
    <link href="http://philippe.bourgau.net/how-immutable-value-objects-fight-mocks/"/>
    <updated>2018-04-26T08:51:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-immutable-value-objects-fight-mocks</id>
    <content type="html"><![CDATA[<p>Excessive use of mocks makes tests very painful to maintain. If we stick painful mocks for too long, we&rsquo;ll end up abandoning unit testing. Eventually, the system will degrade into legacy.Â </p>

<p>There are many techniques to avoid mocks. Some of the most effective involve architecture changes. Unfortunately, there are not the most straightforward to use. Re-architecting involves people and time that you may not dispose of right now. In the following posts, I&rsquo;ll go over techniques that any developer can use in his day to day code to avoid mocks. These battle tested techniques that I&rsquo;ve used on different projects in the past. Check <a href="/careless-mocking-considered-harmful/">the previous post</a> if you&rsquo;re interested to learn how I came to use them.</p>

<p>This is the second post <a href="/blog/categories/how-to-avoid-mocks-series/">of a series about how to avoid mocks</a> in automated tests. If you haven&rsquo;t yet, I recommend you to read my <a href="/careless-mocking-considered-harmful/">first post</a> to understand the perils of mocks in more details.</p>

<p>The first mock fighting small-scale technique I&rsquo;ll go over is <a href="https://martinfowler.com/bliki/ValueObject.html">Immutable Value Objects</a>.</p>

<p><img src="http://philippe.bourgau.net/imgs/2018-04-17-how-immutable-value-objects-fight-mocks/immutable-rock.jpg" alt="A drawing of a rock written &quot;Immutable Value Object&quot;" /></p>

<h2>What are Immutable Value Objects ?</h2>

<p>Behind this weird name is something very simple to understand. Immutable Value Objects :</p>

<ul>
<li>Cannot change their state after construction</li>
<li>Only depend on other Immutable Value Objects</li>
<li>Don&rsquo;t change the state of the whole system in any way</li>
<li>Don&rsquo;t do side effects, like inputs and outputs for example</li>
</ul>


<p>Eric Evans popularized the name in the <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_2?ie=UTF8&amp;qid=1523985269&amp;sr=8-2&amp;keywords=domain+driven+design">Domain-Driven Design Blue Book</a>. Immutable Value Objects have existed for decades in functional languages though. We say these objects are immutable (they cannot change) and pure (they cannot do side effects). Here are 2 interesting properties of Value Objects :</p>

<ul>
<li>you can call a method any number of times with no risk of changing anything to the system</li>
<li>you&rsquo;ll always get the same result every time you call the same method on the same object</li>
</ul>


<p>These by itself, can already be handy when testing.</p>

<p><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_2?ie=UTF8&amp;qid=1523985269&amp;sr=8-2&amp;keywords=domain+driven+design"><img src="http://philippe.bourgau.net/imgs/2018-04-17-how-immutable-value-objects-fight-mocks/ddd.jpg" alt="Cover of Eric Evans's DDD book" /></a></p>

<h2>How do they prevent mocks ?</h2>

<p>That was a bit theoretical, so let&rsquo;s see how this helps to reduce mocking.</p>

<h3>Simpler &ldquo;init path&rdquo;</h3>

<p>Let&rsquo;s take it the other way round and see how side effects can lead to mocking. Every test starts with setting the state in which to run the test. Side effects make this complicated, as many objects need to collaborate to set this state up. When this becomes too painful, people start hacking around with mocks. This in turn makes the tests more fragile :</p>

<ul>
<li>We are not testing a &ldquo;real&rdquo; situation</li>
<li>We need to keep this setup in line with the real code</li>
</ul>


<blockquote><p>ðŸ’¡ Intricate state initialization encourage people to use mocks.</p></blockquote>

<h3>Isolates parts of the system</h3>

<p>Unfortunately, that is not all the story ! Mutable state also, tricks us into using mocks. As soon as your test deals with mutable state, there is a chance that this state is changed in the &lsquo;real&rsquo; system. This means that some bugs might &lsquo;escape&rsquo; unit tests and appear in end to end tests or in production. That&rsquo;s where the mocks strike ! In order to detect this bug in a fast feedback loop, we&rsquo;re likely to add larger scope tests and use mocks to speed them up &hellip;</p>

<blockquote><p>ðŸ’¡ Mutable state and side effects make unit tests less effective.</p></blockquote>

<h3>Reduces code with side effects</h3>

<p>But there&rsquo;s another reason why Immutable Value Objects help us to avoid mocks. As we&rsquo;ll try to use them more and more for the previous two reasons, we&rsquo;ll need to adapt our programming style. As we&rsquo;ll push more and more code in Immutable Value Objects, the &lsquo;imperative&rsquo; part will shrink. This &lsquo;imperative&rsquo; part is where side-effect happen. This is the part where mocking out IOs makes sense. To summarize, the more Immutable Value Objects we use, the more isolated the IOs are, and the less mocking we need.</p>

<p>Javascript expert Eric Elliot also wrote about the immutability and mocks <a href="https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">here</a>.</p>

<h2>Next week</h2>

<p>This was the second post in a <a href="/blog/categories/how-to-avoid-mocks-series/">series about how to prevent mocks</a> in your automated tests. <a href="/immutable-value-objects-vs-mocks-fizz-buzz/">Next post</a> will be an example of using immutable value objects on the <a href="http://codingdojo.org/kata/FizzBuzz/">FizzBuzz kata</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Almost 15 years of using Design By Contract]]></title>
    <link href="http://philippe.bourgau.net/almost-15-years-of-using-design-by-contract/"/>
    <updated>2017-03-14T18:57:00+01:00</updated>
    <id>http://philippe.bourgau.net/almost-15-years-of-using-design-by-contract</id>
    <content type="html"><![CDATA[<p>I first read about Design By Contract in 2002, in <a href="https://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554/ref=sr_1_2?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1490073815&amp;sr=8-2&amp;keywords=object+oriented+software+construction+meyer">Object Oriented Software Construction 2</a>. As soon as I read it, I was convinced, today, I still believe it&rsquo;s a great and fundamental technique. That&rsquo;s why, I almost never write a contract ! Let me explain.</p>

<h2>Phase 1 : DbC ignorance</h2>

<p>I started to code professionally in 2001. This was a time where design and quality software meant <a href="https://en.wikipedia.org/wiki/IBM_Rational_Rose_XDE">Rational Rose</a> (a UML design and code generation tool) while I, at the contrary, was just <a href="https://en.wikipedia.org/wiki/Cowboy_coding">Cow Boy Coding</a> my way out of any problem I was given.</p>

<p>I wasn&rsquo;t really doing Object Oriented programming, but rather imperative programming, using objects as structs, getters, setters, and classes as a way to organize the code &hellip; In this context, my design skills were improving slowly, and I was at the risk of falling in love with a local-optimum practice that would prevent me from growing further.</p>

<p>That&rsquo;s why I started to read books such as the <a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1490074343&amp;sr=1-1&amp;keywords=design+patterns">Gang Of Four Design Patterns</a>, or <a href="https://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554/ref=sr_1_2?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1490073815&amp;sr=8-2&amp;keywords=object+oriented+software+construction+meyer">OOSC2</a>.</p>

<h2>Phase 2 : DbC enlightenment</h2>

<p><a href="https://www.amazon.com/Object-Oriented-Software-Construction-Book-CD-ROM/dp/0136291554/ref=sr_1_2?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1490073815&amp;sr=8-2&amp;keywords=object+oriented+software+construction+meyer"><img src="http://philippe.bourgau.net/imgs/2017-03-14-almost-15-years-of-using-design-by-contract/OOSC2.jpg" alt="The cover of the Object Oriented Software Construction 2" /></a></p>

<p>Reading this book was a profound experience to me. My programming changed fundamentally before and after reading it. The chapter about contracts, taught me what objects are.</p>

<p>One the one hand, Pre and Post conditions can be used in any kind of programming and are just a kind of C <code>assert</code> macro on steroids. Class invariant, on the other hand, is a completely different kind of beast. The invariant of a class is a predicate about an instance of this class that should always be true. For example : field X should never be null, or the value of field N should always be greater than 0.</p>

<p>In some way, grasping the concept of invariant is close to understanding what a class is.</p>

<h2>Phase 3 : DbC everywhere</h2>

<p>That&rsquo;s when I started to write contracts everywhere. I was writing C++ code at the time, and my code must have looked something like that :</p>

<p>```c++
class MonkeyWrench
{</p>

<pre><code>bool m_isStarted;
std::vector&lt;Part&gt;* m_movingParts;
</code></pre>

<p>protected:</p>

<pre><code>virtual void invariant() const
{
    assert(m_isStarted == (m_movingParts != NULL));
}
</code></pre>

<p>public:</p>

<pre><code>MonkeyWrench()
{
    this-&gt;m_isStarted = false;
    this-&gt;m_movingParts = NULL;

    invariant();
}

bool isStarted() const
{
    return this-&gt;isStarted();
}

void start()
{
    assert(!this-&gt;isStarted());
    invariant();

    this-&gt;m_movingParts = ...

    invariant();
    assert(this-&gt;isStarted());
}

const std::vector&lt;Part&gt;&amp; movingParts() const
{
    assert(this-&gt;isStarted());
    invariant();

    return *this-&gt;m_movingParts;
}
...
</code></pre>

<p>};
```</p>

<p>I definitely over-abused contracts, it made the code unreadable. Plus sometimes, I was using excessively long and intricate assertions which made the problem even worse.</p>

<p>Hopefully, overusing contracts also taught me a lot in a short time. Here are some of the lessons I learned :</p>

<ul>
<li>DbC is not very well supported, it&rsquo;s never something built in the language, and edge cases like inheriting an invariant or conditions can become messy pretty fast.</li>
<li>Checking for intricate contracts at every method call can be pretty slow.</li>
<li>Checking everything beforehand is not always the simplest thing to do, at times, throwing an exception on failure just does a better job.</li>
<li>It happened that removing the contract made the code do just what I wanted. It&rsquo;s easy to write unnecessary strict contracts.</li>
<li><a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Command Query Separation Principle</a> is great ! Having &lsquo;const&rsquo; or &lsquo;pure&rsquo; queries that don&rsquo;t change anything make writing contracts a lot simpler.</li>
<li>Preconditions on queries are painful. When possible, returning a sensible &lsquo;null value&rsquo; works better, nothing is worse than getting an error when trying to call a const query from the interactive debugger.</li>
<li>Finally, the more immutable a class is, the simpler the invariant. With a lot of mutable fields, you might resort to have the invariant check that fields are synchronized as expected. If fields are immutable, this simply vanishes.</li>
</ul>


<h2>Phase 4 : DbC hangover</h2>

<p>At the same time I discovered all these small subtleties about contracts, I fell upon Martin Fowler&rsquo;s book <a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1490074424&amp;sr=1-1&amp;keywords=refactoring+improving+the+design+of+existing+code">Refactoring, improving the design of existing code</a> and started to use Unit Tests extensively. This lead me to the following conclusions :</p>

<ul>
<li>Tests are more efficient at producing quality software</li>
<li>Contracts can be an hindrance when trying to do baby steps refactorings as described in Martin Fowler&rsquo;s book</li>
</ul>


<p>On top of that, as DbC is not natively supported by languages, no documentation is generated, meaning that most of the time, the callers still have to look into the code. As a result, I was using contracts less and less often.</p>

<h2>Phase 5 : DbC Zen</h2>

<p>Looking back, I might not be writing a lot of <code>asserts</code> in my code, but I am still thinking in terms of contracts all the time. In fact, there are a ton of ways to use DbC without writing assertions :</p>

<ul>
<li>Use as much immutability as possible. An immutable class does not need to check its invariant all the time, just throwing from the constructor if arguments are not valid is enough.</li>
<li>Use conventions as much as possible, for example, constructor arguments should be set for all the life of the object (cf <a href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1490074450&amp;sr=1-1&amp;keywords=growing+object+oriented+software+guided+by+tests">Growing Object Oriented Software Guided by Tests</a> which describes the different ways to inject something in an object)</li>
<li>Looking back at my DbC assertions, most relate to null values. Again conventions work better ! At work, we simply forbid passing null values around. If something can be null, it means it&rsquo;s optional, Java has an <code>Optional&lt;T&gt;</code> class for just that (I&rsquo;m pretty sure it is possible to do something even better with C++ templates). In this case, if the contract is broken, NullReferenceException will eventually be our assertion.</li>
<li>Replace as many pre &amp; post conditions with invariants on the callee, the arguments or the return objects as possible. It makes sense as it&rsquo;s just making sure we are using &lsquo;valid&rsquo; objects everywhere. Again, if these objects are immutable, it makes the whole thing even simpler !</li>
<li>To take further benefit of the invariant of immutable objects, introduce new types. For example, instead of changing an object&rsquo;s state through a command with associated involved contracts, split the class in 2 and make the method a query returning an immutable object, potentially making the initial class immutable as well. Remember, immutable classes mean almost no assertions !</li>
<li>Use your language. Ex, instead of asserting that 2 lists remain of the same length, refactor to a list of pairs ! (I know that&rsquo;s an obvious example, but you get the point)</li>
<li>If you are using a statically typed language, use types ! For example, I remember at one project I worked on, we had an bug involving a duration : somewhere in the code milliseconds got mistaken for seconds &hellip; We fixed that by replacing the <code>integer</code> by <code>TimeSpan</code> all over the place. Again, that&rsquo;s so obvious !</li>
<li>Eventually, when all else fails, or when it&rsquo;s just too much overhead, use the simple asserts provided by your language or common libraries.</li>
</ul>


<p>To come back at the previous code section, this how it could be written without assertions :</p>

<p>```c++
class MovingMonkeyWrench
{</p>

<pre><code>const std::vector&lt;Part&gt; m_parts;
</code></pre>

<p>public:</p>

<pre><code>MovingMonkeyWrench() : m_parts(...) {}

const std::vector&lt;Part&gt;&amp; parts() const
{
    return this-&gt;m_parts;
}
...
</code></pre>

<p>};</p>

<p>class MonkeyWrench
{ <br/>
public:</p>

<pre><code>MovingMonkeyWrench start() const
{
    return MovingMonkeyWrench();
}
...
</code></pre>

<p>};
```</p>

<p>Details are omitted, but it&rsquo;s easy to see how shorter the code is.</p>

<h2>Conclusion</h2>

<p>When applying all the techniques above, you&rsquo;ll see that cases for explicit assertions are rare. Less assertions also workarounds the issues coming from the poor support for DbC : no documentation and intricate cases.</p>

<p>In the end, assertions made my code more &lsquo;functional&rsquo;. I&rsquo;m not alone to have done the same journey, and if you are interested you should read Eric Evans' <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1490082811&amp;sr=1-1&amp;keywords=domain+driven+design">DDD</a> book where he presents things like immutable value objects and specification objects.</p>
]]></content>
  </entry>
  
</feed>
