<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extreme programming | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/extreme-programming/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2017-09-07T08:55:47+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Throwing code away frequently]]></title>
    <link href="http://philippe.bourgau.net/throwing-code-away-frequently/"/>
    <updated>2017-09-01T06:56:00+02:00</updated>
    <id>http://philippe.bourgau.net/throwing-code-away-frequently</id>
    <content type="html"><![CDATA[<p>Here is the main feedback I got about my previous post <a href="/extreme-extreme-programming-2017/">eXtreme eXtreme Programming</a>.</p>

<blockquote><p>What do you actually mean by throwing code away ? Does it mean stoping unit testing and refactoring ?</p></blockquote>

<p><img src="../imgs/2017-09-01-throwing-code-away-frequently/shredder.jpeg" alt="A drawing of a shredder destroying some code" /></p>

<p>So I guess it deserves a bit of explanation.</p>

<h2>What is it all about ?</h2>

<p>When programming, I don&rsquo;t throw code away a lot. I tend to rely on my automated tests to change the code I already have. That might be a problem.</p>

<p>As with everything, there is no one size fits all. We should choose the best practice for our current situation. Same thing applies for incremental changes versus rewriting.</p>

<p>TDD makes incremental changes cost effective, and as such, is a key to get out of the Waterfall.</p>

<p>The idea of throwing code away frequently is to make rewriting cost effective, so we can do it more often.</p>

<h2>Why would we want to do so ?</h2>

<p>In &ldquo;<a href="https://blog.codinghorror.com/when-understanding-means-rewriting/">When Understanding means Rewriting"</a>, Jeff Atwood explains that reading code can be more difficult than writing it. There is a point where rewriting is going to be cheaper than changing.</p>

<p>The more unit test you have, the later you reach that point. The more technical debt you take, and the sooner. The bigger the part to rewrite, the more risky it becomes.</p>

<p>Let&rsquo;s imagine you knew a safe way to rewrite the module you are working on. You could be faster by taking more technical debt and writing less unit tests ! Mike Cavaliere framed it as<br/>
<a href="http://mikecavaliere.com/throw-away-your-code/">F**k Going Green: Throw Away Your Code</a>.</p>

<p>This would be great for new features, that might be removed if they don&rsquo;t bring any value. It would also be a good way to get rid of technical debt. Naresh Jain also makes the point that without tests, you&rsquo;ll have to keep things simple (<a href="https://blogs.agilefaqs.com/2008/10/07/throwing-away-code/">here</a> and <a href="https://fr.slideshare.net/nashjain/the-decline-and-fall-of-agile-antifragile-mindset-to-rescue">here</a>) !</p>

<p>Wait a minute, isn&rsquo;t that <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a> ?</p>

<h2>How to make it work</h2>

<p><a href="/extreme-extreme-programming-2017/"><img src="../imgs/2017-09-01-throwing-code-away-frequently/xxp.jpg" alt="A graph with all the practices from my previous article eXtreme eXtreme Programming" /></a></p>

<h3>How to ensure quality without unit tests ?</h3>

<p>TDD and unit testing is a cornerstone of XP. If we remove it, we need something else to build quality in. Could Mob Programming and Remote teams do the trick ?</p>

<p>&ldquo;Given enough eyeballs, all bugs are shallow&rdquo;. Pair programming and code reviews catch a lot more bugs than solo programming. Only a few bugs are likely to pass through the scrutiny of the whole team doing mob programming.</p>

<p>What about Remote ? Martin Fowler <a href="https://martinfowler.com/articles/remote-or-co-located.html">explains</a> that remote teams perform better by hiring the best. Skills of programmers have been known for a long time as a main driver of software quality.</p>

<p><a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/"><img src="../imgs/2017-09-01-throwing-code-away-frequently/ProductivityVariation.jpg" alt="People vs methodology impact on productivity" /></a><div class="image-credits">Photo from Steve McConnell on <a href="http://www.construx.com/10x_Software_Development/Origins_of_10X_%E2%80%93_How_Valid_is_the_Underlying_Research_/">Construx</a></div></p>

<p>Finally, the Cucumber team <a href="https://cucumber.io/blog/2015/12/21/the-mob-rules-ok">reported</a> that Mob Programming works well for remote teams.</p>

<h3>How to make this safer ?</h3>

<p>Even with the best team, mistakes will happen. How can we avoid pushing a rewrite that crashes the whole system ?</p>

<p>The main answer to that is good continuous deployment. We should deploy to a subset of users first. We should be able to rollback straight away if things don&rsquo;t work as expected.</p>

<p>As the system grows, <a href="https://en.wikipedia.org/wiki/Microservices">microservices</a> can keep continuous deployment under control. We can deploy, update and roll them back independently. By nature, microservices also reduce the scope of the rewrite. That alone, as we said earlier, makes rewrites safer.</p>

<p>As a last point, some technologies make building microservice systems easier and incremental. The <a href="https://stackoverflow.com/questions/16779162/what-kind-of-virtual-machine-is-beam-the-erlang-vm">Erlang VM</a>, for example, with first class actors, is one these. Time to give <a href="https://www.erlang.org/">Erlang</a> and <a href="https://elixir-lang.org/">Elixir</a> a try !</p>

<h3>Is this always a good idea ?</h3>

<p>There are good and bad situations.</p>

<p>For example, a lean startup or data driven environment seems a good fit. Suppose your team measures the adoption of new features before deciding to keep or ditch them. You&rsquo;d better not invest in unit tests straight away.</p>

<p>On the other side, software for a complex domain will be very difficult to rewrite flawlessly. I have worked in the finance industry for some years, I know what a complex domain is. I doubt I could rewrite a piece of intricate finance logic without bugs. I would stick to <a href="https://en.wikipedia.org/wiki/Domain-driven_design">DDD</a> and unit testing in these areas.</p>

<h3>How to dip your toe</h3>

<p>Here is how I intend to dip <em>my</em> toe. I won&rsquo;t drop automated testing completely yet. What I could do instead (and that I already did on side projects) is to start with end to end tests only.</p>

<p>From there every time I want to change a piece of code, I have many options :</p>

<ul>
<li>Add a new end to end test and change the code.</li>
<li>If the code is too much of a mess, I can rewrite it from scratch. I&rsquo;ll have the safety of the end to end tests.</li>
<li>If I see that the module is stabilizing, has not been rewritten for a while, and yields well to modifications. I could start splitting end to end tests into unit tests, and embark on the TDD road.</li>
</ul>


<p>Maybe later, when I have a team doing mob programming to find my mistakes, we&rsquo;ll skip the end to end tests.</p>

<h2>Other interesting links</h2>

<ul>
<li><a href="http://corgibytes.com/blog/2016/11/01/throwaway-code/">Throwaway Code</a> by M. Scott Ford</li>
<li><a href="http://wiki.c2.com/?RewriteCodeFromScratch">Rewrite Code From Scratch</a> on c2 wiki</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[eXtreme eXtreme Programming (2017)]]></title>
    <link href="http://philippe.bourgau.net/extreme-extreme-programming-2017/"/>
    <updated>2017-08-25T07:01:00+02:00</updated>
    <id>http://philippe.bourgau.net/extreme-extreme-programming-2017</id>
    <content type="html"><![CDATA[<p>What would <a href="http://www.extremeprogramming.org/">XP</a> look like if it was invented today ?</p>

<p>A few days ago, I stumbled upon these two talks that got me thinking about this question.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/cGuTmOUdFbo" frameborder="0" allowfullscreen></iframe>




<iframe width="560" height="315" src="https://www.youtube.com/embed/h62n09XtS-A" frameborder="0" allowfullscreen></iframe>


<p>So I looked deeper into the question, while sticking to the same <a href="http://www.extremeprogramming.org/values.html">values</a> and principles. Here is what I came up with.</p>

<h2>Practices</h2>

<h3>Continuous Deployment</h3>

<p>Why should we only deliver at every iteration in 2017 ? <a href="https://blog.newrelic.com/2016/02/04/data-culture-survey-results-faster-deployment/">Lot&rsquo;s of companies</a> demonstrated how to deploy every commit to safely production. Amazon for example, <a href="http://www.zdnet.com/article/how-amazon-handles-a-new-software-deployment-every-second/">deploys new software every second</a> !</p>

<h3><a href="https://en.wikipedia.org/wiki/DevOps">DevOps</a>++</h3>

<p>As a team starts doing continuous deployment, devs get more and more involved in ops. This privileged view on the users&rsquo;s behaviour can turn devs into product experts. Why not push the logic further and make them <em>the</em> product guys as well ?</p>

<h3>Test in prod</h3>

<p>Continuous deployement opens up many opportunities. Deploying safely requires bulletproof rollbacks. Once devs take care of product, code and ops they can shortcut testing and directly <a href="https://www.theguardian.com/info/developer-blog/2016/dec/05/testing-in-production-how-we-combined-tests-with-monitoring">test in prod</a> with some users ! Rollback remains an option at any time.</p>

<h3><a href="http://www.jamesshore.com/Agile-Book/no_bugs.html">#NoBugs</a></h3>

<p>That seems like wishful thinking. The idea is to fix bugs as soon as they appear, but also to prevent them in the first place. Continuous Deployment requires great engineering practices, which enable this way of working. A story cannot be &ldquo;finished&rdquo; until test in prod is over, and bugs fixed.</p>

<h3>Kanban</h3>

<p>At its core, <a href="https://en.wikipedia.org/wiki/Kanban">Kanban</a> is a way to limit the work in progress. It&rsquo;s almost a side effect of the previous practices. <a href="https://medium.com/quality-functions/the-zero-bug-policy-b0bd987be684">#noBugs almost kills interruptions for rework</a>. On top of that, devs have full control on their end to end work, so why would they multitask ?</p>

<h3>#NoBacklog</h3>

<p>In <a href="https://gettingreal.37signals.com/">Getting Real</a>, basecamp guys said that their <a href="https://gettingreal.37signals.com/ch05_Start_With_No.php">default answer to any new feature request was &ldquo;No&rdquo;</a>. Only after the same thing got asked many times would they start thinking of it. Maintaining a long backlog is a waste of time. Dumping backlog items but the current ones saves time. Important ideas will always come up again later.</p>

<h3>#NoEstimates</h3>

<p>This one is famous already. <a href="https://www.thoughtworks.com/insights/blog/how-estimating-story-counts-worked-us">Some teams</a> have saved time by using story count instead of story points. What&rsquo;s the point anyway if the team is already :</p>

<ul>
<li>working as best as it can</li>
<li>on the most important thing</li>
<li>and deploying as soon as possible</li>
</ul>


<h3>Data Driven</h3>

<p>This is how to drive the system evolution. Instead of relying on projects, backlogs and predictions, use data. Data from user logs and interviews proves if a new feature is worth building or dumping. Exploring logs of internal tools can help to continuous improve.</p>

<h3>Lean startup &amp; Hackathons</h3>

<p>Incremental improvements, in either product or organization, is not enough. As <a href="http://timharford.com/">Tim Hardford</a> explained in <a href="https://www.amazon.com/gp/product/1250007550/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1250007550&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=1f1a29f9454328c6606e12b40399eb06">Adapt</a>, survival requires testing completely new ideas. <a href="https://en.wikipedia.org/wiki/Lean_startup">Lean startup</a> &amp; <a href="https://en.wikipedia.org/wiki/Hackathon">hackathons</a> experiments can do just that.</p>

<p><a href="https://www.amazon.com/gp/product/1250007550/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1250007550&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=1f1a29f9454328c6606e12b40399eb06"><img src="../imgs/2017-08-25-extreme-extreme-programming-2017/adapt.jpg" alt="The cover of the Adapt book" /></a></p>

<h3><a href="/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-1/">Improvement kata</a></h3>

<p><a href="https://en.wikipedia.org/wiki/Toyota_Kata#The_Improvement_Kata">Improvement kata</a> is a way to drive long term continuous improvement. It&rsquo;s the main tool for that at Toyota (read <a href="https://www.amazon.com/gp/product/0071635238/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0071635238&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=93a84b0867a3e0f3dd915d87cba78b90">Toyota Kata</a> to learn more). It provides more time to think of the problem than a retrospective. It also fits perfectly in a data driven environment.</p>

<h3>Mob programming</h3>

<p>Pair programming is great for code quality and knowledge sharing. <a href="https://en.wikipedia.org/wiki/Mob_programming#cite_note-8">Mob programming</a> is the more extreme version of pairing where <em>all</em> the team codes together.</p>

<h3><a href="/throwing-code-away-frequently/">Throw code away frequently</a></h3>

<p>An alternative to refactoring with unit tests is throwaway and rewrite once it gets too bad. Companies have been doing that for years. I worked at a bank that used to throwaway and rewrite individual apps that were part of a larger system. It can be a huge waste of money if these sub systems are too large. Scaling down to individual classes or microservices could make this cost effective.</p>

<h3>Remote</h3>

<p>With access to a wider pool of talents, <a href="https://martinfowler.com/articles/remote-or-co-located.html">remote teams usually perform better</a>. It also makes everybody&rsquo;s life easier. Finally, teams have reported that mob &amp; remote programming <a href="https://www.infoq.com/presentations/distributed-teams-remote-collaboration">work great together</a>.</p>

<h2>Afterthought</h2>

<p>What&rsquo;s striking from this list is that it&rsquo;s not that far from the original XP ! For example, continuous deployment and generalists have always been part of it. Another point is that is not science fiction ! I found many teams reporting success with these practices on the internet ! A well-oiled XP team might very well get there through continuous improvement.</p>

<p>The more I look at it, the more XP stands as a unique lighthouse in the foggy Agile landscape.</p>

<p>As for me, I&rsquo;m not sure I&rsquo;d dare to swap TDD &amp; refactoring for throwaway &amp; rewrite. I&rsquo;m particularly worried about the complex domain specific heart of systems. Nothing prevents from using both strategies for different modules though.</p>

<p>I should give it a try on a side project with a microservice friendly language, such as Erlang or Elixir.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to start learning the tao of incremental code refactoring today]]></title>
    <link href="http://philippe.bourgau.net/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/"/>
    <updated>2017-07-21T08:05:00+02:00</updated>
    <id>http://philippe.bourgau.net/how-to-start-learning-the-tao-of-incremental-code-refactoring-today</id>
    <content type="html"><![CDATA[<p>In my <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">last post</a>, I explained why incremental refactoring techniques will make you both more productive and relaxed.</p>

<p>As anything worth its salt, the path to full mastery is long and requires dedication. The good news is that you&rsquo;ll start to feel the benefits long before you are a master.</p>

<h2>Dedicated Practice</h2>

<p>The quickest thing that will get you up to speed is dedicated practice. Take some time to do some exercices outside of any &lsquo;production&rsquo; code.</p>

<h3>TDD Coding Katas</h3>

<p>The most famous practice to learn TDD also works very well to learn refactoring. That shouldn&rsquo;t be a surprise as incremental refactoring is an integral part of TDD.</p>

<p>There are many ways to do your first coding kata. You could find a coding dojo near you (ask <a href="https://www.meetup.com/">meetup.com</a>). Or you could find motivated colleagues to start one at your company &hellip; I wrote in more details about how to attend a coding dojo in <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">this post</a>.</p>

<p><a href="https://www.amazon.com/gp/product/919811803X/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=919811803X&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=340ea938a5e4f00178676804ac6c2278"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/coding-dojo.jpg" alt="Emily Bache's Coding Dojo book cover" /></a></p>

<p>You can also practice katas on your own. My friend <a href="https://twitter.com/tpierrain">Thomas Pierrain</a> rehearses the same katas to discover deeper insights.</p>

<h3>Refactoring Golf</h3>

<p>The goal of incremental refactoring is to keep the code production ready all the time. Smaller commits is one happy consequence of that.</p>

<p>You can stretch your refactoring muscles by doing coding katas and keeping the code compiling all the time. You&rsquo;ll need to master your IDE and its automated refactoring. Most of all, it will shift your attention from the goal to the path !</p>

<p>I learned at <a href="https://www.spaconference.org/spa2017/">SPA conference</a> that we call this &lsquo;Refactoring golf&rsquo;. The name comes from Golf contests, <a href="http://wiki.c2.com/?PerlGolf">popular in the Perl community</a>. Their goal is to write the shortest program possible to do a specific goal. The goal of a Refactoring Golf is to go from code A to code B in the fewest transformations possible.</p>

<p>They are a few <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=refactoring+golf&amp;type=">refactoring golf repos on Github</a>, I tried one and found it fun ! Give it a try too !</p>

<h2>Study some theory</h2>

<p>Real mastery does not come by practice alone. Studying theory alongside practice yields deeper insights. Theory enables to put your practice into perspective and to find ways to improve it. It saves you from getting stuck in bad habits. It also saves you from having to rediscover everything by yourself.</p>

<h3>Develop your design taste</h3>

<p>In <a href="http://www.paulgraham.com/taste.html">Taste for Makers</a> Paul Graham explains why taste for is fundamental to programming. Taste is what allows you to judge if code is nice or bad in a few seconds. Taste is subjective, intuitive and fast, unlike rules which are objective but slower. Expert designers use taste to pinpoint issues and good points in code on the spot.</p>

<p>Within the fast TDD &ndash; Refactoring loop, taste is the tool of choice to drive the design. Guess what : we can all improve our design taste !</p>

<p><a href="https://blog.codinghorror.com/code-smells/">Code smells</a> are the first things to read about to improve your design taste. Once you know them well enough, it will be possible to spot things that might need refactoring as you code.</p>

<p>Spotting problems is nice, but finding solutions is better ! <a href="https://en.wikipedia.org/wiki/Software_design_pattern">Design Patterns</a> are just that &hellip; There has been a lot of controversy around Design Patterns. If overusing them leads to bloated code, using them to fix strong smells makes a lot of sense. There is even a book about the subject :</p>

<p><a href="https://www.amazon.com/gp/product/0321213351/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321213351&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=d79d093008fb9e77f75ea2089d6cbdae"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/refactoring-to-patterns.jpg" alt="Joshua Kerievsky's Refactoring To Patterns book cover" /></a></p>

<p>Finally, there&rsquo;s a third and most common way to improve our design taste. It&rsquo;s to read code ! The more code we read, the better our brain becomes at picking small clues about what nice and what is not. It&rsquo;s important to read clean code but also bad code. To read code in different languages. Code built on different frameworks. </p>

<p>So, read code at work, read code in books, read code in open source libraries, good code, legacy code &hellip;</p>

<h3>Learn your refactorings</h3>

<p>As with most topics in programming there is a reference book about refactoring. It&rsquo;s Martin Fowlers&rsquo;s <a href="https://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=73fc09a5a451402a7036509ae62e8c66">Refactoring, improving the design of existing code</a>. Everything is in there, smells, unit testing and a repository of refactoring walkthroughs.</p>

<p><a href="https://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=73fc09a5a451402a7036509ae62e8c66"><img src="../imgs/2017-07-21-how-to-start-learning-the-tao-of-incremental-code-refactoring-today/refactoring.jpg" alt="Martin Fowler's refactoring book cover" /></a></p>

<p>The book is said to be a difficult read, but the content is worth gold. If you have the grit, give it a try ! At the end, you should understand how your IDE does automated refactoring. You should also be able to perform all the refactorings that your IDE does not provide by hand ! This will enlarge your refactoring toolbox, and help you to drive larger refactorings from A to B.</p>

<h2>Develop a refactoring attitude</h2>

<p>Practice makes perfect. Whatever our refactoring skill, there is something to learn by practicing more.</p>

<h3>Make it a challenge</h3>

<p>As you are coding, whenever you find a refactoring to do to your code, make it a challenge to perform it in baby steps. Try to keep the code compiling and the tests green as much as possible.</p>

<p>When things go wrong, revert instead of pushing forward. Stop and think, try to find a different path.</p>

<p>If you are pairing, challenge your pair to find a safer track.</p>

<p>This might delay you a bit at first, but you&rsquo;ll also be able to submit many times per day. You&rsquo;ll see that your refactoring muscles will grow fast. You should see clear progress in only 1 or 2 weeks.</p>

<h3>Team up against long refactorings</h3>

<p>If your team prioritizes a user story that will need some re-design, try to agree on a refactoring plan. The idea is to find a coarse grain path that will allow you to commit and deliver many times. This plan might also help you to share the work on the story.</p>

<p>Having to question and explain your assumptions will speed up your learning. </p>

<h2>Legacy code</h2>

<p>Refactoring is most useful with bad legacy code. Unfortunately, it also where it is the most difficult. Next week&rsquo;s blog post will be about what we can do to learn how to refactor legacy code.</p>

<p>That was my second post in this mini-series about refactoring. First one was <a href="/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/">7 Reasons Why Learning Refactoring Techniques Will Improve Your Life as a Software Engineer</a>. The third and last is <a href="/10-things-to-know-that-will-make-you-great-at-refactoring-legacy-code/">10 things to know that will make you great at refactoring legacy code</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[7 reasons why learning refactoring techniques will improve your life as a software engineer]]></title>
    <link href="http://philippe.bourgau.net/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/"/>
    <updated>2017-07-10T09:10:00+02:00</updated>
    <id>http://philippe.bourgau.net/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer</id>
    <content type="html"><![CDATA[<p>This post is a bold promise. Mastering incremental refactoring techniques makes our lives as software engineers more enjoyable.</p>

<p>I have already made the <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">same statement about TDD before</a>. As <a href="http://www.extremeprogramming.org/rules/refactor.html">refactoring</a> is a part of TDD, one could think I am repeating myself. At the same time, a <a href="https://blogs.msdn.microsoft.com/ericgu/2017/06/22/notdd/">recent Microsoft blog post</a> argued that refactoring is more important than TDD. Even though I&rsquo;m a TDD fan, that&rsquo;s an interesting point.</p>

<p>Incremental refactoring is key to make releases non-events ! As early as 2006, using <a href="https://en.wikipedia.org/wiki/Extreme_programming">XP</a>, we were releasing mission critical software without bugs ! We would deliver a new version of our software to a horde of angry traders and go to the movies without a sweat !</p>

<p>What&rsquo;s so special about incremental refactoring ?</p>

<h2>Avoid the tunnel effect</h2>

<p><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/tunnel.jpg" alt="A long tunnel" /></p>

<p>Mastering incremental refactoring techniques allows to break a feature down to baby steps. Not only smaller commits, but also smaller releases ! You can deploy and validate every step in production before we move to the next !</p>

<p>Small releases are also a lot easier to fix than big bang deployments. That alone is a good enough reason to deploy in baby steps.</p>

<p>There are a lot of other advantages to small deployments. Merges become straightforward. Someone can take over your work if you get sick. Finally, it&rsquo;s also easier to switch to another urgent task if you need to.</p>

<h2>Deliver early</h2>

<p>When you know that you will be able to improve your work later on, it becomes possible to stick to what&rsquo;s needed <em>now</em>. After spending some time working on a feature, it might turn out that you delivered enough value. Between enhancing this feature and starting another one, pick the most valuable. Don&rsquo;t be able to switch. Incremental refactoring, makes it easy to resume later on if it makes sense.</p>

<p>Real productivity is not measured through code, but through feature value. This explains why incremental refactoring is more productive than up-front / big-bang development.</p>

<h2>Know where you stand</h2>

<p>As you&rsquo;ll work through your feature, you&rsquo;ll have to keep track of the done and remaining steps. As you go through this todo list and deliver every successive step, you get a pretty clear idea of where you stand. You&rsquo;ll know that you&rsquo;ve done 3 out of 7 steps for example. It helps everyone to know what&rsquo;s the remaining work and when you&rsquo;ll be able to work on something else.</p>

<p><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/wool-tangled.jpg" alt="Tangled wool" /></p>

<p>A few times, I fell in the trap of features that should have taken a few hours and that lingered for days. I remember how stupid I was feeling every morning, explaining to my colleagues that it was more complex than I had thought, but that it should be finished before tomorrow &hellip; Learning incremental refactoring techniques saved me from these situations.</p>

<h2>Deliver unexpected feature</h2>

<p>Incremental refactoring techniques improves the code. As a systematic team wide effort, it keeps the code healthy and evolutive. When someone requests an unexpected feature late, you&rsquo;ll be able to deliver it.</p>

<p>This should improve your relation with product people. They will be very happy when you build their latest idea without a full redesign.</p>

<h2>Avoids rewrites</h2>

<p>Joel Spolsky wrote a long time ago that rewriting a large piece of software is the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">number 1 thing not to do</a> ! All my experiences in rewriting systems have been painful and stressful.</p>

<p>It always starts very rosy. Everyone is feeling very productive with the latest tools and technologies. Unfortunately, it takes a lot of features to replace the existing system. As always with software, the time estimates for the rewrite are completely wrong. As a result, everyone starts grumbling about why this rewrite is taking so long. The fact that the legacy system is still evolving does not help either. Long story short, the greenfield project ends up cutting corners and taking technical debt pretty fast &hellip; fueling the infamous vicious circle again.</p>

<p>Incremental refactoring techniques offer an alternative. It enables to change and improve the architecture of the legacy system. It <em>looks</em> longer, but it&rsquo;s always less risky. And looking back, it&rsquo;s almost always faster as well !</p>

<h2>Ease pair programming</h2>

<p>eXtreme Programming contains a set of practices that reinforce each other. As I wrote at the beginning, refactoring goes hand in hand with TDD. <a href="/blog/categories/pair-programming/">Pair programming</a> is another practice of XP.</p>

<p><a href="http://www.extremeprogramming.org/map/code.html"><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/xp-practices.GIF" alt="Tangled wool" /></a><div class="image-credits">From <a href="http://www.extremeprogramming.org/">www.extremeprogramming.org/</a></div></p>

<p>TDD and Refactoring simplify pair programming. When a pair is doing incremental refactoring, they only need to discuss and agree on the design at hand. They know that however the design needs to evolve in the long term, they&rsquo;ll be able to refactor it. It&rsquo;s a lot easier to pair program if you don&rsquo;t have to agree on all the details of the long term design &hellip;</p>

<p>In turn, pair programming fosters <a href="http://www.extremeprogramming.org/rules/collective.html">collective code ownership</a>. Collective code ownership increases the <a href="https://en.wikipedia.org/wiki/Bus_factor">truck factor</a>. Which reduces the project risks and makes the team&rsquo;s productivity more stable. In the long run, this makes the work experience more sustainable and less stressful.</p>

<h2>Simplify remote work</h2>

<p>Refactoring will also save you from the commutes and allow you to work closer to the ones you love !</p>

<p>Refactoring techniques enable small commits. Small commits simplify code reviews, which are key to remote or distributed work. Even if you are doing <a href="/rexp-remote-extreme-programming/">remote pair programming</a>, small commits help to switch the control between buddies more often.</p>

<p><a href="https://www.amazon.com/gp/product/B00I800FFY/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00I800FFY&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=9873e69d645cba27701f4b3744acab0e"><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/remote-pairing.jpg" alt="Tangled wool" /></a></p>

<h2>To be continued</h2>

<p>I hope that by now I persuaded you to learn incremental refactoring techniques. My <a href="/how-to-start-learning-the-tao-of-incremental-code-refactoring-today/">next post</a> will dig into the details about how to do that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 SPA Conference takeaways that could make us better software professionals]]></title>
    <link href="http://philippe.bourgau.net/5-spa-conference-takeaways-that-could-make-us-better-software-professionals/"/>
    <updated>2017-07-06T22:17:00+02:00</updated>
    <id>http://philippe.bourgau.net/5-spa-conference-takeaways-that-could-make-us-better-software-professionals</id>
    <content type="html"><![CDATA[<p>Last week, my colleague <a href="https://ahmadatwi.me/">Ahmad Atwi</a> and I went to the London <a href="https://www.spaconference.org/spa2017/">SPA Conference</a> to give our <a href="https://www.youtube.com/watch?v=oJsukJhxt7E">Remote eXtreme Practice</a> talk.</p>

<p>The London <a href="http://www.extremeprogramming.org/">eXtreme Programming</a> is one of the most active in the world. You could feel an XP atmosphere at the conference. For example, people like <a href="http://www.natpryce.com/">Nat Pryce</a> and <a href="https://twitter.com/sf105">Steve Freeman</a>, authors of <a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=fcdd83a07a3cfb190f2c8e7e8b9f72c3">GOOSGT</a> book were speakers.</p>

<p><a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=fcdd83a07a3cfb190f2c8e7e8b9f72c3"><img src="../imgs/2017-07-06-5-spa-conference-takeaways-that-could-make-us-better-software-professionals/growing.jpg" alt="The cover of Growing Object-Oriented Software, Guided By Tests" /></a></p>

<p>To summarize, we had the chance to attend a lot of very interesting sessions during the 3 days of the conference. Here are 5 pearls of wisdom I took back with me.</p>

<h2>What connascences are</h2>

<p>Identifying code <a href="http://connascence.io/">connascences</a> helps to rank refactorings and keep the system maintainable.</p>

<p><a href="http://www.extremeprogramming.org/rules/refactor.html">Continuous refactoring</a> is one of the core practices of XP. For me, knowing what to refactor next has been a matter of <a href="https://martinfowler.com/bliki/CodeSmell.html">code smells</a>, discussing with my pair and gut feeling.</p>

<p>A connascence is a coupling between parts of the system. Two parts of your code are connascent if changing one implies changing the other. For example, a function call is connascent by name with the function definition. If you change one, you need to change the other.</p>

<p>Connascences are more formal than code smells. We can detect and rank them to pick the most important refactoring to do. People have listed 9 types of connascences. Some are visible in the source code, others are dynamic and difficult to spot before runtime.</p>

<p>The lowest form of connascence is <a href="http://connascence.io/name.html">&lsquo;of name&rsquo;,</a> like in the function call example above. The worst form is <a href="http://connascence.io/identity.html">&lsquo;of Identity&rsquo;</a>, when different parts of the system must reference the same object.</p>

<iframe src="http://philippe.bourgau.net//www.slideshare.net/slideshow/embed_code/key/jPvF4gxm5z6cGN?startSlide=14" width="510" height="420" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p>The higher the connascence, the more difficult it is to evolve the parts involved. Instead of relying on intuition, you can use a connascence based refactoring algorithm :</p>

<ol>
<li>Detect the highest connascence</li>
<li>Reduce or remove it</li>
<li>Repeat.</li>
</ol>


<p>Thanks <a href="https://twitter.com/xpsurgery">Kevin Rutherford</a> and <a href="https://twitter.com/mowat27">Adrian Mowat</a> for your <a href="http://xpsurgery.com/resources/connascence-hunt-slides/">Red Green then what ?</a> session about connascence.</p>

<h2>Tips for pairing with junior developers</h2>

<p><a href="https://twitter.com/irinatsyganok">Irina Tsyganok</a> and <a href="http://www.natpryce.com/">Nat Pryce</a> gave a very fun session about this topic. A lot of valuable points discussed, from which I saved a few pearls of wisdom.</p>

<blockquote class="twitter-tweet" data-lang="fr"><p lang="en" dir="ltr">Cat eating session from <a href="https://twitter.com/natpryce">@natpryce</a> at <a href="https://twitter.com/hashtag/spaconf17?src=hash">#spaconf17</a> (unless <a href="https://twitter.com/irinatsyganok">@irinatsyganok</a> stops him) <a href="https://t.co/XSiaPDp9kJ">pic.twitter.com/XSiaPDp9kJ</a></p>&mdash; Andy Longshaw (@andylongshaw) <a href="https://twitter.com/andylongshaw/status/879714743963054080">27 juin 2017</a></blockquote>


<script async src="http://philippe.bourgau.net//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>It was reassuring to hear Nat saying that &ldquo;As we gain experience, we are not expected to know everything&rdquo;. Pairing with developers out of college is an occasion to &ldquo;exchange&rdquo; skills. Hard learned design skills versus updates on the latest technologies.</p>

<p>I also learned about the <a href="http://actingcoachscotland.co.uk/blog/expert-induced-amnesia/">Expert&rsquo;s Amnesia</a> and why experts often have a hard time teaching. Expert level knowledge is by nature instinctive. At this level of skill, it becomes very difficult to detail the logic of things that seem obvious.</p>

<h2>We engineers are more mentors than coaches</h2>

<p>In the <a href="https://www.amazon.com/gp/product/0201616416/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201616416&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=dc2f9dc4f5ca106842921bfded07b405">first XP book</a>, there were only 3 roles in the team : team members, on site customer and XP coach. The XP coach should be a developer who can help the team to learn the practices and principles of XP.</p>

<p>About the same time, the personal or professional coach jobs appeared. The Scrum Master, is to Scrum what the XP coach is to XP, without the developer part. Remember the joke &ldquo;Scrum is like XP, without everything that makes it work&rdquo; (<a href="https://martinfowler.com/bliki/FlaccidScrum.html">Flaccid Scrum</a>).</p>

<p>It looks like the Agile Coach job title appeared out of all this. The problem is no one exactly knows what this is. Should he be an experienced developer like the XP coach ? A great people person ? Or someone good at introducing change ? or a mix of these ?</p>

<p><a href="http://www.selfishprogramming.com/about/">Portia Tung</a> and <a href="https://uk.linkedin.com/in/helenlisowski">Helen Lisowski</a> &rsquo;s  talk &ldquo;The power of coaching&rdquo; clarified that.</p>

<p>There is no knowledge transfer from the coach to the coachees ! On the other side, a mentor does transfer knowledge to his mentees. The coach helps his coachee take a step back and take decisions in full consciousness. The goal of the mentor is to inspire and train to new techniques.</p>

<p>I&rsquo;m fine being a mentor and not a coach ;&ndash;)</p>

<h2>Servant leaders need to be tough at times</h2>

<p>We hear a lot about servant leadership nowadays. Scrum Master should be servant leaders, as well as managers in agile organizations.</p>

<p><a href="https://fr.linkedin.com/company/bellebeck-limited">Angie Main</a> gave a very interesting session about servant leadership. She made an interesting point I had not heard about before. We all know that servant leaders should trust the team to get the work done most of the time. In spite of that, servant leaders must also be ready to step in and remove people who don&rsquo;t fit in and endanger the team !</p>

<p>This reminded me of what Jim Collins says in <a href="http://www.wikisummaries.org/wiki/Built_to_Last#Chapter_6_.E2.80.93_Cult-like_Cultures">Built to last</a> : &ldquo;People who don&rsquo;t fit are expelled like viruses !&rdquo;</p>

<p><a href="https://www.amazon.com/gp/product/0060516402/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0060516402&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=e83ad8e3dcf7bdb7f875d5b22e8eb4c6"><img src="../imgs/2017-07-06-5-spa-conference-takeaways-that-could-make-us-better-software-professionals/built-to-last.jpg" alt="The cover of Built to Last" /></a></p>

<h2>1/3000 ideas succeeds</h2>

<p>Thanks to <a href="https://twitter.com/ozzieyuce">Ozlem Yuce</a>&rsquo;s session, I learned about the &ldquo;Job To Be Done&rdquo; technique to understand the customer&rsquo;s real needs.</p>

<p>Studies measured that only 1 idea out of 3000 ends up as a successful product ! <a href="https://www.researchgate.net/file.PostFileLoader.html?id=56217976614325233f8b4567&amp;assetKey=AS%3A285916150157312%401445179130594">Here</a> seems to be the original research.</p>

<p>I&rsquo;ll remember this fact next time I&rsquo;m ask for a funky feature !</p>

<h2>To conclude</h2>

<p>At the end, we had a very good time at SPAconference. The talks were insightful, we had interesting discussions, the premises were comfortable and on top of that, food was great !</p>

<p>I&rsquo;m already eager to go to SPA conference 2018 !</p>
]]></content>
  </entry>
  
</feed>
