<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: extreme programming | Philippe Bourgau's blog]]></title>
  <link href="http://philippe.bourgau.net/blog/categories/extreme-programming/atom.xml" rel="self"/>
  <link href="http://philippe.bourgau.net/"/>
  <updated>2017-07-12T07:13:40+02:00</updated>
  <id>http://philippe.bourgau.net/</id>
  <author>
    <name><![CDATA[Philippe Bourgau]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[7 reasons why learning refactoring techniques will improve your life as a software engineer]]></title>
    <link href="http://philippe.bourgau.net/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/"/>
    <updated>2017-07-10T09:10:00+02:00</updated>
    <id>http://philippe.bourgau.net/7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer</id>
    <content type="html"><![CDATA[<p>This post is a bold promise. Mastering incremental refactoring techniques makes our lives as software engineers more enjoyable.</p>

<p>I have already made the <a href="/from-apprentice-to-master-how-to-learn-tdd-test-driven-development/">same statement about TDD before</a>. As <a href="http://www.extremeprogramming.org/rules/refactor.html">refactoring</a> is a part of TDD, one could think I am repeating myself. At the same time, a <a href="https://blogs.msdn.microsoft.com/ericgu/2017/06/22/notdd/">recent Microsoft blog post</a> argued that refactoring is more important than TDD. Even though I&rsquo;m a TDD fan, that&rsquo;s an interesting point.</p>

<p>Incremental refactoring is key to make releases non-events ! As early as 2006, using <a href="https://en.wikipedia.org/wiki/Extreme_programming">XP</a>, we were releasing mission critical software without bugs ! We would deliver a new version of our software to a horde of angry traders and go to the movies without a sweat !</p>

<p>What&rsquo;s so special about incremental refactoring ?</p>

<h2>Avoid the tunnel effect</h2>

<p><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/tunnel.jpg" alt="A long tunnel" /></p>

<p>Mastering incremental refactoring techniques allows to break a feature down to baby steps. Not only smaller commits, but also smaller releases ! You can deploy and validate every step in production before we move to the next !</p>

<p>Small releases are also a lot easier to fix than big bang deployments. That alone is a good enough reason to deploy in baby steps.</p>

<p>There are a lot of other advantages to small deployments. Merges become straightforward. Someone can take over your work if you get sick. Finally, it&rsquo;s also easier to switch to another urgent task if you need to.</p>

<h2>Deliver early</h2>

<p>When you know that you will be able to improve your work later on, it becomes possible to stick to what&rsquo;s needed <em>now</em>. After spending some time working on a feature, it might turn out that you delivered enough value. Between enhancing this feature and starting another one, pick the most valuable. Don&rsquo;t be able to switch. Incremental refactoring, makes it easy to resume later on if it makes sense.</p>

<p>Real productivity is not measured through code, but through feature value. This explains why incremental refactoring is more productive than up-front / big-bang development.</p>

<h2>Know where you stand</h2>

<p>As you&rsquo;ll work through your feature, you&rsquo;ll have to keep track of the done and remaining steps. As you go through this todo list and deliver every successive step, you get a pretty clear idea of where you stand. You&rsquo;ll know that you&rsquo;ve done 3 out of 7 steps for example. It helps everyone to know what&rsquo;s the remaining work and when you&rsquo;ll be able to work on something else.</p>

<p><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/wool-tangled.jpg" alt="Tangled wool" /></p>

<p>A few times, I fell in the trap of features that should have taken a few hours and that lingered for days. I remember how stupid I was feeling every morning, explaining to my colleagues that it was more complex than I had thought, but that it should be finished before tomorrow &hellip; Learning incremental refactoring techniques saved me from these situations.</p>

<h2>Deliver unexpected feature</h2>

<p>Incremental refactoring techniques improves the code. As a systematic team wide effort, it keeps the code healthy and evolutive. When someone requests an unexpected feature late, you&rsquo;ll be able to deliver it.</p>

<p>This should improve your relation with product people. They will be very happy when you build their latest idea without a full redesign.</p>

<h2>Avoids rewrites</h2>

<p>Joel Spolsky wrote a long time ago that rewriting a large piece of software is the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">number 1 thing not to do</a> ! All my experiences in rewriting systems have been painful and stressful.</p>

<p>It always starts very rosy. Everyone is feeling very productive with the latest tools and technologies. Unfortunately, it takes a lot of features to replace the existing system. As always with software, the time estimates for the rewrite are completely wrong. As a result, everyone starts grumbling about why this rewrite is taking so long. The fact that the legacy system is still evolving does not help either. Long story short, the greenfield project ends up cutting corners and taking technical debt pretty fast &hellip; fueling the infamous vicious circle again.</p>

<p>Incremental refactoring techniques offer an alternative. It enables to change and improve the architecture of the legacy system. It <em>looks</em> longer, but it&rsquo;s always less risky. And looking back, it&rsquo;s almost always faster as well !</p>

<h2>Ease pair programming</h2>

<p>eXtreme Programming contains a set of practices that reinforce each other. As I wrote at the beginning, refactoring goes hand in hand with TDD. <a href="/blog/categories/pair-programming/">Pair programming</a> is another practice of XP.</p>

<p><a href="http://www.extremeprogramming.org/map/code.html"><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/xp-practices.GIF" alt="Tangled wool" /></a><div class="image-credits">From <a href="http://www.extremeprogramming.org/">www.extremeprogramming.org/</a></div></p>

<p>TDD and Refactoring simplify pair programming. When a pair is doing incremental refactoring, they only need to discuss and agree on the design at hand. They know that however the design needs to evolve in the long term, they&rsquo;ll be able to refactor it. It&rsquo;s a lot easier to pair program if you don&rsquo;t have to agree on all the details of the long term design &hellip;</p>

<p>In turn, pair programming fosters <a href="http://www.extremeprogramming.org/rules/collective.html">collective code ownership</a>. Collective code ownership increases the <a href="https://en.wikipedia.org/wiki/Bus_factor">truck factor</a>. Which reduces the project risks and makes the team&rsquo;s productivity more stable. In the long run, this makes the work experience more sustainable and less stressful.</p>

<h2>Simplify remote work</h2>

<p>Refactoring will also save you from the commutes and allow you to work closer to the ones you love !</p>

<p>Refactoring techniques enable small commits. Small commits simplify code reviews, which are key to remote or distributed work. Even if you are doing <a href="/rexp-remote-extreme-programming/">remote pair programming</a>, small commits help to switch the control between buddies more often.</p>

<p><a href="https://www.amazon.com/gp/product/B00I800FFY/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B00I800FFY&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=9873e69d645cba27701f4b3744acab0e"><img src="../imgs/2017-07-10-7-reasons-why-learning-refactoring-techniques-will-improve-your-life-as-a-software-engineer/remote-pairing.jpg" alt="Tangled wool" /></a></p>

<h2>To be continued</h2>

<p>I hope that by now I persuaded you to learn incremental refactoring techniques. My next post will dig into the details about how to do that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 SPA Conference takeaways that could make us better software professionals]]></title>
    <link href="http://philippe.bourgau.net/5-spa-conference-takeaways-that-could-make-us-better-software-professionals/"/>
    <updated>2017-07-06T22:17:00+02:00</updated>
    <id>http://philippe.bourgau.net/5-spa-conference-takeaways-that-could-make-us-better-software-professionals</id>
    <content type="html"><![CDATA[<p>Last week, my colleague <a href="https://ahmadatwi.me/">Ahmad Atwi</a> and I went to the London <a href="https://www.spaconference.org/spa2017/">SPA Conference</a> to give our <a href="https://www.youtube.com/watch?v=oJsukJhxt7E">Remote eXtreme Practice</a> talk.</p>

<p>The London <a href="http://www.extremeprogramming.org/">eXtreme Programming</a> is one of the most active in the world. You could feel an XP atmosphere at the conference. For example, people like <a href="http://www.natpryce.com/">Nat Pryce</a> and <a href="https://twitter.com/sf105">Steve Freeman</a>, authors of <a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=fcdd83a07a3cfb190f2c8e7e8b9f72c3">GOOSGT</a> book were speakers.</p>

<p><a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=fcdd83a07a3cfb190f2c8e7e8b9f72c3"><img src="../imgs/2017-07-06-5-spa-conference-takeaways-that-could-make-us-better-software-professionals/growing.jpg" alt="The cover of Growing Object-Oriented Software, Guided By Tests" /></a></p>

<p>To summarize, we had the chance to attend a lot of very interesting sessions during the 3 days of the conference. Here are 5 pearls of wisdom I took back with me.</p>

<h2>What connascences are</h2>

<p>Identifying code <a href="http://connascence.io/">connascences</a> helps to rank refactorings and keep the system maintainable.</p>

<p><a href="http://www.extremeprogramming.org/rules/refactor.html">Continuous refactoring</a> is one of the core practices of XP. For me, knowing what to refactor next has been a matter of <a href="https://martinfowler.com/bliki/CodeSmell.html">code smells</a>, discussing with my pair and gut feeling.</p>

<p>A connascence is a coupling between parts of the system. Two parts of your code are connascent if changing one implies changing the other. For example, a function call is connascent by name with the function definition. If you change one, you need to change the other.</p>

<p>Connascences are more formal than code smells. We can detect and rank them to pick the most important refactoring to do. People have listed 9 types of connascences. Some are visible in the source code, others are dynamic and difficult to spot before runtime.</p>

<p>The lowest form of connascence is <a href="http://connascence.io/name.html">&lsquo;of name&rsquo;,</a> like in the function call example above. The worst form is <a href="http://connascence.io/identity.html">&lsquo;of Identity&rsquo;</a>, when different parts of the system must reference the same object.</p>

<iframe src="http://philippe.bourgau.net//www.slideshare.net/slideshow/embed_code/key/jPvF4gxm5z6cGN?startSlide=14" width="510" height="420" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p>The higher the connascence, the more difficult it is to evolve the parts involved. Instead of relying on intuition, you can use a connascence based refactoring algorithm :</p>

<ol>
<li>Detect the highest connascence</li>
<li>Reduce or remove it</li>
<li>Repeat.</li>
</ol>


<p>Thanks <a href="https://twitter.com/xpsurgery">Kevin Rutherford</a> and <a href="https://twitter.com/mowat27">Adrian Mowat</a> for your <a href="http://xpsurgery.com/resources/connascence-hunt-slides/">Red Green then what ?</a> session about connascence.</p>

<h2>Tips for pairing with junior developers</h2>

<p><a href="https://twitter.com/irinatsyganok">Irina Tsyganok</a> and <a href="http://www.natpryce.com/">Nat Pryce</a> gave a very fun session about this topic. A lot of valuable points discussed, from which I saved a few pearls of wisdom.</p>

<blockquote class="twitter-tweet" data-lang="fr"><p lang="en" dir="ltr">Cat eating session from <a href="https://twitter.com/natpryce">@natpryce</a> at <a href="https://twitter.com/hashtag/spaconf17?src=hash">#spaconf17</a> (unless <a href="https://twitter.com/irinatsyganok">@irinatsyganok</a> stops him) <a href="https://t.co/XSiaPDp9kJ">pic.twitter.com/XSiaPDp9kJ</a></p>&mdash; Andy Longshaw (@andylongshaw) <a href="https://twitter.com/andylongshaw/status/879714743963054080">27 juin 2017</a></blockquote>


<script async src="http://philippe.bourgau.net//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>It was reassuring to hear Nat saying that &ldquo;As we gain experience, we are not expected to know everything&rdquo;. Pairing with developers out of college is an occasion to &ldquo;exchange&rdquo; skills. Hard learned design skills versus updates on the latest technologies.</p>

<p>I also learned about the <a href="http://actingcoachscotland.co.uk/blog/expert-induced-amnesia/">Expert&rsquo;s Amnesia</a> and why experts often have a hard time teaching. Expert level knowledge is by nature instinctive. At this level of skill, it becomes very difficult to detail the logic of things that seem obvious.</p>

<h2>We engineers are more mentors than coaches</h2>

<p>In the <a href="https://www.amazon.com/gp/product/0201616416/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0201616416&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=dc2f9dc4f5ca106842921bfded07b405">first XP book</a>, there were only 3 roles in the team : team members, on site customer and XP coach. The XP coach should be a developer who can help the team to learn the practices and principles of XP.</p>

<p>About the same time, the personal or professional coach jobs appeared. The Scrum Master, is to Scrum what the XP coach is to XP, without the developer part. Remember the joke &ldquo;Scrum is like XP, without everything that makes it work&rdquo; (<a href="https://martinfowler.com/bliki/FlaccidScrum.html">Flaccid Scrum</a>).</p>

<p>It looks like the Agile Coach job title appeared out of all this. The problem is no one exactly knows what this is. Should he be an experienced developer like the XP coach ? A great people person ? Or someone good at introducing change ? or a mix of these ?</p>

<p><a href="http://www.selfishprogramming.com/about/">Portia Tung</a> and <a href="https://uk.linkedin.com/in/helenlisowski">Helen Lisowski</a> &rsquo;s Â talk &ldquo;The power of coaching&rdquo; clarified that.</p>

<p>There is no knowledge transfer from the coach to the coachees ! On the other side, a mentor does transfer knowledge to his mentees. The coach helps his coachee take a step back and take decisions in full consciousness. The goal of the mentor is to inspire and train to new techniques.</p>

<p>I&rsquo;m fine being a mentor and not a coach ;&ndash;)</p>

<h2>Servant leaders need to be tough at times</h2>

<p>We hear a lot about servant leadership nowadays. Scrum Master should be servant leaders, as well as managers in agile organizations.</p>

<p><a href="https://fr.linkedin.com/company/bellebeck-limited">Angie Main</a> gave a very interesting session about servant leadership. She made an interesting point I had not heard about before. We all know that servant leaders should trust the team to get the work done most of the time. In spite of that, servant leaders must also be ready to step in and remove people who don&rsquo;t fit in and endanger the team !</p>

<p>This reminded me of what Jim Collins says in <a href="http://www.wikisummaries.org/wiki/Built_to_Last#Chapter_6_.E2.80.93_Cult-like_Cultures">Built to last</a> : &ldquo;People who don&rsquo;t fit are expelled like viruses !&rdquo;</p>

<p><a href="https://www.amazon.com/gp/product/0060516402/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0060516402&amp;linkCode=as2&amp;tag=pbourgau-20&amp;linkId=e83ad8e3dcf7bdb7f875d5b22e8eb4c6"><img src="../imgs/2017-07-06-5-spa-conference-takeaways-that-could-make-us-better-software-professionals/built-to-last.jpg" alt="The cover of Built to Last" /></a></p>

<h2>1/3000 ideas succeeds</h2>

<p>Thanks to <a href="https://twitter.com/ozzieyuce">Ozlem Yuce</a>&rsquo;s session, I learned about the &ldquo;Job To Be Done&rdquo; technique to understand the customer&rsquo;s real needs.</p>

<p>Studies measured that only 1 idea out of 3000 ends up as a successful product ! <a href="https://www.researchgate.net/file.PostFileLoader.html?id=56217976614325233f8b4567&amp;assetKey=AS%3A285916150157312%401445179130594">Here</a> seems to be the original research.</p>

<p>I&rsquo;ll remember this fact next time I&rsquo;m ask for a funky feature !</p>

<h2>To conclude</h2>

<p>At the end, we had a very good time at SPAconference. The talks were insightful, we had interesting discussions, the premises were comfortable and on top of that, food was great !</p>

<p>I&rsquo;m already eager to go to SPA conference 2018 !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Incremental architecture, a cure against architecture astronauts]]></title>
    <link href="http://philippe.bourgau.net/incremental-architecture-a-cure-against-architecture-astronauts/"/>
    <updated>2017-04-24T06:52:00+02:00</updated>
    <id>http://philippe.bourgau.net/incremental-architecture-a-cure-against-architecture-astronauts</id>
    <content type="html"><![CDATA[<p>Back in 2001, when I started to code for a living, fresh out of school, I was mainly doing a form of <a href="https://en.wikipedia.org/wiki/Cowboy_coding">cowboy coding</a>. After a few months of maintaining my own mess, I started to recall my university lessons : we should be doing design before coding &hellip;</p>

<p>When I was asked to re-engineer the &lsquo;wizards UI&rsquo;, I paused my coding to design something clean from scratch. It worked quite well at first : the overall code was a lot simpler and contained a lot less duplication than before. Seeing this new shiny UI, product people asked for new features. Unfortunately, I hadn&rsquo;t thought of them when designing this little framework. I was almost back at my initial situation.</p>

<p>That&rsquo;s how I started to look for another way to design software. At about the same time the <a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_3?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1493096057&amp;sr=8-3&amp;keywords=extreme+programming">eXtreme Programming book</a> fell into my hands. That&rsquo;s where I discovered the idea of incremental design and architecture.</p>

<p><a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0201616416/ref=sr_1_3?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1493096057&amp;sr=8-3&amp;keywords=extreme+programming"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/xp-1ed.jpg" alt="Front cover of the first edition of the XP book" /></a></p>

<h2>What is Incremental Archi</h2>

<p>Let&rsquo;s start with the antithesis of incremental architecture :</p>

<h3>Astronaut Architecture</h3>

<p>The term &ldquo;Architecture Astronaut&rdquo; was coined by <a href="https://www.joelonsoftware.com">Joel Spolsky</a> back in 2001. If you haven&rsquo;t read this <a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">classic post</a> yet, I strongly encourage you to do so. Basically, he explains that we should not be impressed by architects going over their heads talking about too abstract stuff.</p>

<p>Incremental is the exact opposite of astronaut architecture</p>

<h3>Two Schools to Software Architecture</h3>

<p>Traditional architecture is about taking up-front choices that will be difficult to change. Incremental architecture is about preparing for non-stop change and taking decisions as late as possible.</p>

<p>The idea in incremental architecture is really simple : keep your code simple, clean and automatically tested in order to be able to simply adapt your code and architecture when definitely needed.</p>

<h3>Pros and Cons of incremental architecture</h3>

<p>The first reaction of most software engineers (me included, remember how my story started) is that it can only work on trivial stuff. After practicing it for about a decade, I am now convinced it works most of the time. I&rsquo;m not alone, <a href="http://www.jamesshore.com/Agile-Book/incremental_design.html">James Shore</a> (who wrote the more on the subject) also shares my view:</p>

<blockquote><p>Common thought is that distributed processing, persistence, internationalization, security, and transaction structure are so complex that you must consider them from the start of your project. I disagree; I&rsquo;ve dealt with all of them incrementally.</p>

<p>Two issues that remain difficult to change are choice of programming language and platform. I wouldn&rsquo;t want to make those decisions incrementally!</p></blockquote>

<p>I would add published APIs to this list.</p>

<p>Granted, there are situations that incremental architecture alone cannot handle, what about its good points then ?</p>

<p>In all the other cases (and that means most of the time), here is what you get :</p>

<ul>
<li>As you won&rsquo;t need to deal with future use cases, you&rsquo;ll do less work</li>
<li>That in turn, will keep your code simpler, decreasing time to release new features</li>
<li>As change is built-in, you&rsquo;ll be able to improve your architecture in ways you could not have imagined from the start !</li>
</ul>


<p><a href="https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1493096137&amp;sr=1-1&amp;keywords=the+art+of+agile+development"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/art-of-agile.jpg" alt="Front cover of the Art of Agile Software Development book" /></a></p>

<p>If you cannot see how this could possibly work ? Read on !</p>

<h2>How to do it</h2>

<h3>eXtreme Programming</h3>

<p>As I said earlier, incremental architecture emerged from eXtreme Programming. It won&rsquo;t come as a surprise that in order to work well incremental architecture requires the XP practices to be in place. In particular, the code base should be automatically tested, the continuous integration cycle should take less than 10 minutes, the design should be simple. The team should be good at doing refactoring.</p>

<p>Don&rsquo;t expect to be able to do incremental architecture without these practices in place. But this alone might be enough already !</p>

<p><a href="https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?tag=pbourgau-20&amp;amp;s=books&amp;ie=UTF8&amp;qid=1493096197&amp;sr=1-1&amp;keywords=fowler+refactoring"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/refactoring.jpg" alt="Front cover of the Martin Fowler's refactoring book" /></a></p>

<h3>Architecture Vision</h3>

<p>At work, where our team consists of 9 developers, it&rsquo;s not always that simple to coordinate and all pull in the same direction. That&rsquo;s why we find it useful to share a very long term architecture vision (<a href="https://www.thoughtworks.com/insights/blog/enabling-incremental-design-and-evolutionary-architecture">Enabling Incremental Design and Evolutionary Architecture</a>). This will help people to make coherent decisions when hesitating between 2 alternate designs.</p>

<p>The vision can be the result of the work of a pair, or a mob brainstorming or whatever. Building this vision is typically an activity where experienced programmers can contribute a lot of value.</p>

<p>Once this vision is shared and understood by the team, every time a pair has to work on a story, they can orient the design towards it. But always as little as possible to finish the work at hand, remember the XP motos <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS (Keep It Simple &amp; Stupid)</a> &amp; <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI (You Ain&rsquo;t Gonna Need It</a>.</p>

<p>One final word &hellip; a vision is just that : a vision ! It might turn out true, or false, be ready to change it as circumstances change.</p>

<h3>Spikes</h3>

<p>At times, even with a story in your hands and a long term architecture sketch on the whiteboard, you might have difficulties to know how to change your design to fulfill both.</p>

<p>As always in XP, in case of uncertainty, use <a href="http://agiledictionary.com/209/spike/">Spikes</a> ! Spikes are short time-boxed experiments of throwaway code, which goal is to answer a specific design question.</p>

<h3>How to mitigate the risks</h3>

<p>What about these topics that don&rsquo;t yield to incremental architecture ? What if you discover late that you need to change your platform ? Or your API ?</p>

<p>Obviously, you should think about these questions up-front. Hopefully, there are usually not that difficult to answer. But, over time, Non-Functional-Requirements and technologies change. Large and long living systems are particularly likely to need to change to a new platform someday.</p>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix had the answer</a> : build your system out of small tools, that do only one thing well, and that communicate through a standard protocol. Systems built that way can be re-written one piece at a time.</p>

<p><a href="https://en.wikipedia.org/wiki/Unix_philosophy"><img src="../imgs/2017-04-24-incremental-architecture-a-cure-against-architecture-astronauts/Ken_n_dennis.jpg" alt="Ken Thompson and Dennis Ritchie, the creators of Unix" /></a><div class="image-credits">Photo from <a href="https://commons.wikimedia.org/wiki/File:Ken_n_dennis.jpg">WikiMedia</a></div></p>

<p>The modern version of this is the micro-services architecture. Incremental architecture allows you to start with a monolith, split it when you need to, and replace micro-services as needed.   With the safety of simple code and a great automated test harness. Interestingly, successful software systems that were architectured up-front also take this road &hellip; without the safety !</p>

<h3>The Architect</h3>

<p>Good news : no more PowerPoints and a lot more coding with the team ! Here is what&rsquo;s expected from an incremental architect :</p>

<ul>
<li>To code with the team. As Bertrand Meyer once said &ldquo;<a href="http://stal.blogspot.fr/2008/08/architect-always-implements.html">Bubbles (aka. diagrams) don&rsquo;t crash</a>&rdquo;, it&rsquo;s plain too easy, and wrong, to mandate architecture without living with the consequences</li>
<li>To come up with more ideas when drafting the long term vision</li>
<li>To keep an eye on the &lsquo;long term&rsquo; while being the navigator in pair programming</li>
<li>In the second edition of the <a href="https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0321278658/ref=sr_1_1?tag=pbourgau-20&amp;amp;ie=UTF8&amp;qid=1493096057&amp;sr=8-1&amp;keywords=extreme+programming">XP book</a> Kent Beck suggests that the architect should write large scale tests to stress the system and demonstrate architecture issues to the team</li>
<li>To delegate as much as possible to the team. However smart the architect, the team as a whole is smarter ! Delegating architecture increases motivation and the quality of the outcome.</li>
</ul>


<h2>End of the story</h2>

<p>I&rsquo;ve been practicing incremental architecture and design for a long time now. It made my life a lot simpler ! Most architecture questions become backlog items to prioritize.</p>

<p>One last advice : be prepared to re-read <a href="https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/">Joel Spolsky&rsquo;s article</a> whenever you get caught up in architecture meetings &hellip;</p>
]]></content>
  </entry>
  
</feed>
