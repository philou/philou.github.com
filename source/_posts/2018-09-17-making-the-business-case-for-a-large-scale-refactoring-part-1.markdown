---
layout: post
title: "Making the business case for a large scale refactoring - Part 1"
date: 2018-09-20 08:58
comments: true
categories: 
 - refactoring
 - technical debt
 - business value
 - planning
 - large-scale-refactoring-sponsorship-series
keywords: "Business Case, Making the Business Case, Large Scale Refactoring, refactoring large software projects, refactoring large software systems, refactoring large code base, refactoring in large software projects"
description: "Believe it or not, making a business case for a large scale refactoring with real money figures is not rocket science. Here are starting techniques to do estimate refactoring and non-refactoring costs. With these and a bit of discipline, almost any software team can do it."
header:
  teaser: /imgs/2018-09-17-making-the-business-case-for-a-large-scale-refactoring-part-1/legacy-vs-refactoring-teaser.jpeg
---
_With a bit of discipline, we can make a factual business case for a large scale refactoring that business people won't resist._

The [previous 2 articles](/presenting-a-large-scale-refactoring-as-a-business-opportunity/) were about how to present large scale refactorings to business people. This might already get us a lot closer to having our large scale refactoring prioritized. Unfortunately, many times this won't be enough. Hopefully, we can add something to make the point to business people : numbers !

Business people love numbers. Presented well, they make decisions a lot easier to take. Making a business case is about estimating the costs of doing versus not doing a refactoring.

![Drawing of legacy and a refactoring plan in a balance. Making a business case for a large scale refactoring is all about estimating the costs of both options]({{site.url}}/imgs/2018-09-17-making-the-business-case-for-a-large-scale-refactoring-part-1/legacy-vs-refactoring.jpg)

This is the twelfth post in a [series about how to get sponsorship for large scale refactorings](/blog/categories/large-scale-refactoring-sponsorship-series/). If you haven't, I encourage you to start from [the beginning](/how-to-convince-your-business-to-sponsor-a-large-scale-refactoring/).

## Before anything

Before we start any computation, we need to know what we are talking about. This means that as a team, we must agree and specify enough the refactoring we want to do. A small group design session might be useful at this point.

> ðŸ’¡ We must detail precisely what refactoring we want before making a business case for it.

## Refactoring Cost

We pay for a refactoring only once, when we do it. The cost of the refactoring is the time it will take to do it. We can do a team estimate on the refactoring and see the numbers.

From my experience large scale refactoring estimates are pretty inaccurate. If the team is having a hard time agreeing on estimates, it's a warning! Recipes against this are :

*   Do a bit more design to better define the refactoring
*   Take a safety margin for your estimation. Times 2 is not a bad ratio to start with (cf. the risk management section of [The Art of Agile](https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675/ref=sr_1_1?ie=UTF8&qid=1536837799&sr=8-1&keywords=the+art+of+agile))

[![Cover of the book The Art of Agile Development. It contains a chapter about risk management which can be useful to make realistic long term estimates of a large scale refactoring]({{site.url}}/imgs/2018-09-17-making-the-business-case-for-a-large-scale-refactoring-part-1/art-of-agile.jpg)](https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675/ref=sr_1_1?ie=UTF8&qid=1536837799&sr=8-1&keywords=the+art+of+agile)

Eventually, be sure to convert your estimates in man.hours. If you don't, it will be difficult to compare this with the non-refactoring cost.

## Non-Refactoring Cost

Contrary to the previous one, this cost is recurring. We'll only compute it for a single period of time, let's say an iteration. It also works fine with a month, a week or whatever.

> ðŸ’¡ The cost of not doing a refactoring is the sum of all the waste work generated by the current code.

The non-refactoring can be computed like:

```
non-refactoring cost = Bug fix time + Support time + Lower productivity
```

### Bug fixes & Support time

Bad code generates bugs and support time. By doing the refactoring well, we'll almost kill these wasteful activities.

We want to get the real amount of time the team is spending on bug fixes and support time related to our refactoring. Hopefully, our ticketing software might already contain enough time tracking data. That's what I used when we did [our improvement kata](/how-we-used-the-improvement-kata-to-gain-25-percent-of-productivity-part-3/).

![Distribution of the different kind of tasks over sprints that we extracted from Jira when we did the improvement kata. Finding where the time went is useful when making a business case for a large scale refactoring]({{site.url}}/imgs/2018-09-17-making-the-business-case-for-a-large-scale-refactoring-part-1/types-of-tasks-small.jpg)

If not, we'll unfortunately need to do a bit of manual time tracking for a while. It should be fine to cover a few days, and extrapolate for a longer period. Unbelievably, some people made time tracking fun by [using Lego Blocks](https://code.joejag.com/2018/lego-workstream-visualisation.html)!

[![Joe Wright's team has had success logging time with lego blocks. Logging is time is crucial to estimate the non-refactoring cost when making a business plan]({{site.url}}/imgs/2018-09-17-making-the-business-case-for-a-large-scale-refactoring-part-1/lego_1.jpg)](https://code.joejag.com/2018/lego-workstream-visualisation.html)<div class="image-credits">By <a href="https://twitter.com/vanschoo">Nancy Van Schooenderwoert</a></div><br>

### Lower productivity

Bad code also makes us slow! By doing this large scale refactoring, we should get a productivity boost.

Here again, we are only going to measure for an iteration, and extrapolate for the future. If we are working with iterations, we should have an 'estimation' meeting of some sort. At the end of it, we should have selected a list of 'task' for next iteration.

Next time you go through this meeting, we'll need to estimate these tasks twice.

1.  Do a normal estimation
2.  Now, imagine we did the refactoring. Re-estimate.

The difference between the estimates is the non-refactoring productivity loss.

```
productivity loss = normal estimation - estimation after refactoring
```

## Payback Period

We need to convert everything in man.hours. We should now have figures for both total refactoring and recurring non-refactoring cost.

```
payback period = refactoring cost / non-refactoring cost
```

The payback period is the refactoring cost divided by the non-refactoring cost. It's the time after which the refactoring will pay for itself.

## To be continued

We're done with computations. [Next week](http://eepurl.com/dxKE95), I'll go over what to do with these numbers. We want to make business case for this large scale refactoring an unmissable offer!

This is the twelfth post in [a series about how to get sponsorship for large scale refactorings](/blog/categories/large-scale-refactoring-sponsorship-series/).
