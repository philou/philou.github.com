---
layout: post
title: "How To Keep Up With Software Technologies"
date: 2016-05-30 04:31
comments: true
categories:
 - book
 - career
 - programming
keywords: "Software Books, Learning Programming, Self Teaching Programming"
description: "How reading classic and fundamental programming books eventually helps you to stay up to date with the latest technologies"
---
Since I started to program professionally 15 years ago, a lot of things have changes. A lot of technologies appeared and became mainstream while others fell out of fashion.

As software developers, it is really challenging to stay fit and productive in new technologies. I cannot obviously say that I am an expert in all new technologies, but I can say that I can get up to speed in a pretty short time in nearly all.

If there is a single reason for that I strongly believe it is because "I studied my classics" !

{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/outdated.jpg An outdated computed covered in spider webs %}

## How does it work

At the same time I started to program all day long for my living, I also started to read a lot of programming books on my spare time. This allowed me to learn at night and practice at day, setting everything in my brain.

This might come as a surprise, but I never read a lot of books about the technologies I was using. I'd rather study fundamental programming books. These contain a lot of transportable knowledge, unlike in most books about a particular technology.

I believe this is a pretty good use of time since it made me a better programmer and also greatly reduced the time I need to master most new technologies. I can now easily relate them to some more general concept I learned before.

For example, I never read a book about UI. By the time I had to do some UI programming, I had absolutely no issue getting up to speed on the topic. I had already seen quite some UI code examples in other books, I knew that most UI frameworks are built from a set of Object Oriented patterns. Coming from a different perspective, I was even able to suggest improvements to the code that UI experts had not thought of.

That's not to say that I never read books about a particular technology, sometimes, that's just what you need to start something new. But when I do, I usually find them quite easy to read and digest. And I tend to skip things I intuitively understand and use them as cookbooks containing recipes for particular problems rather than end to end walk-through.

## My books

### [The Pragmatic Programmer: From Journeyman to Master](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=sr_1_1?ie=UTF8&qid=1464666382&sr=8-1&keywords=the+pragmatic+programmer)

[{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/the-pragmatic-programmer.jpg Cover of the pragmatic programmer book %}](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=sr_1_1?ie=UTF8&qid=1464666382&sr=8-1&keywords=the+pragmatic+programmer)

As a young programmer this book made me understand that my job was not only about writing code, but about building maintainable systems. It provided me with tools to do so, 10 years later, I can still remember "The power of plain text". This is also the book that made me have a first look into Ruby :).

### [Refactoring: Improving the Design of Existing Code](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?ie=UTF8&qid=1464666776&sr=8-1&keywords=refactoring+improving+the+design+of+existing+code)

[{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/refactoring.jpg Cover of the refactoring book %}](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672/ref=sr_1_1?ie=UTF8&qid=1464666776&sr=8-1&keywords=refactoring+improving+the+design+of+existing+code)

Here is the theory behind all automated IDE refactorings. Reading this book had a profound influence on my coding style. The examples made me understand the difference between readable and unreadable code ... It's also the foundation for any kind of incremental design and architecture. That's the book that got me started with TDD.

### [Domain-Driven Design: Tackling Complexity in the Heart of Software](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?ie=UTF8&qid=1464666833&sr=8-1&keywords=domain+driven+design+eric+evans)

[{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/ddd.jpg Cover of the DDD book %}](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/ref=sr_1_1?ie=UTF8&qid=1464666833&sr=8-1&keywords=domain+driven+design+eric+evans)

This book teaches good object oriented programming. Some say it is tough to read, but it's definitely worth doing so. Among other things, it explains how to use functional programming concept in your object oriented project, by separating Value Objects and Entities for example.

### [The C Programming Language](http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=pd_sim_14_2?ie=UTF8&dpID=41qX6YdIJ7L&dpSrc=sims&preST=_AC_UL160_SR122%2C160_&refRID=035C81Y95A0A1C6K25F6)

[{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/c.jpg Cover of the C book %}](http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=pd_sim_14_2?ie=UTF8&dpID=41qX6YdIJ7L&dpSrc=sims&preST=_AC_UL160_SR122%2C160_&refRID=035C81Y95A0A1C6K25F6)

With around 250 pages, it's pretty difficult to find a programming book with a greater value/page ratio. This one will teach you all there is to learn about C, and help you understand everything that was built on top of C (and that's quite a lot ...)

### [Structure and Interpretation of Computer Programs](http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=sr_1_1?s=books&ie=UTF8&qid=1464666981&sr=1-1&keywords=sicp)

[{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/sicp.jpg Cover of the SICP book %}](http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=sr_1_1?s=books&ie=UTF8&qid=1464666981&sr=1-1&keywords=sicp)

Compared to C, Lisp is at the other side of the language spectrum. Learning C and Lisp gives the ability to put nearly anything in contrast to these 2 languages. Lisp is dynamic, functional and meta. It can be morphed into nearly anything and SICP teaches how to do so. There's a Lisp practice that is invaluable to any programmer : use your language to express your problem as simply as possible. SICP teaches that.

### [Programming Erlang: Software for a Concurrent World](http://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X/ref=sr_1_2?s=books&ie=UTF8&qid=1464667113&sr=1-2&keywords=erlang+programming)

[{% img center /imgs/2016-05-30-how-to-keep-up-with-software-technologies/erlang.jpg Cover of the Erlang book %}](http://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X/ref=sr_1_2?s=books&ie=UTF8&qid=1464667113&sr=1-2&keywords=erlang+programming)

Neither the C book nor SICP deals with distribution and concurrency. That's what this book does. I had never programmed distributed systems before reading this book. After I read it, I learned how to code for distribution in a maintainable way. The lessons taught by Erlang are applicable in many languages.

## Not the best books

I did not and will never read all programming books available. There might be newer books that treat the same subjects better, but these books are the ones that taught me the most about our craft. My point is that learning fundamentals and things far away from our daily technologies will teach us more.
